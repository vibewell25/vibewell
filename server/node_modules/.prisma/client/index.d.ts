
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "User"
  objects: {
    transactions: LoyaltyTransactionPayload<ExtArgs>[]
    subscriptions: SubscriptionPayload<ExtArgs>[]
    referredBy: UserPayload<ExtArgs> | null
    referrals: UserPayload<ExtArgs>[]
    analyticsEvents: AnalyticsEventPayload<ExtArgs>[]
    paymentTransactions: PaymentTransactionPayload<ExtArgs>[]
    trainingProgress: TrainingProgressPayload<ExtArgs>[]
    googleCalendarToken: GoogleCalendarTokenPayload<ExtArgs> | null
    outlookCalendarToken: OutlookCalendarTokenPayload<ExtArgs> | null
    assignments: EquipmentAssignmentPayload<ExtArgs>[]
    socialPosts: SocialPostPayload<ExtArgs>[]
    postComments: PostCommentPayload<ExtArgs>[]
    eventRegistrations: EventRegistrationPayload<ExtArgs>[]
    forumThreads: ForumThreadPayload<ExtArgs>[]
    forumPosts: ForumPostPayload<ExtArgs>[]
    benefitClaims: BenefitClaimPayload<ExtArgs>[]
    payrollRecords: PayrollRecordPayload<ExtArgs>[]
    bookings: BookingPayload<ExtArgs>[]
    posts: PostPayload<ExtArgs>[]
    comments: CommentPayload<ExtArgs>[]
    twoFactorAuth: TwoFactorAuthPayload<ExtArgs> | null
    webAuthnCredentials: WebAuthnCredentialPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    auth0Id: string | null
    email: string
    name: string | null
    avatar: string | null
    role: Role
    createdAt: Date
    updatedAt: Date
    pushTokens: Prisma.JsonValue
    notificationSettings: Prisma.JsonValue
    referralCode: string
    referredById: string | null
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model User
 * 
 */
export type User = runtime.Types.DefaultSelection<UserPayload>
export type ProviderPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Provider"
  objects: {
    services: ServicePayload<ExtArgs>[]
    businesses: BusinessPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string | null
    businessName: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["provider"]>
  composites: {}
}

/**
 * Model Provider
 * 
 */
export type Provider = runtime.Types.DefaultSelection<ProviderPayload>
export type ServicePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Service"
  objects: {
    provider: ProviderPayload<ExtArgs>
    paymentTransactions: PaymentTransactionPayload<ExtArgs>[]
    bookings: BookingPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    providerId: string
    name: string
    price: number
    duration: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["service"]>
  composites: {}
}

/**
 * Model Service
 * 
 */
export type Service = runtime.Types.DefaultSelection<ServicePayload>
export type BusinessPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Business"
  objects: {
    provider: ProviderPayload<ExtArgs>
    hours: BusinessHourPayload<ExtArgs>[]
    staff: StaffPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    providerId: string
    name: string
    address: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["business"]>
  composites: {}
}

/**
 * Model Business
 * 
 */
export type Business = runtime.Types.DefaultSelection<BusinessPayload>
export type BusinessHourPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "BusinessHour"
  objects: {
    business: BusinessPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    businessId: string
    dayOfWeek: number
    openTime: string
    closeTime: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["businessHour"]>
  composites: {}
}

/**
 * Model BusinessHour
 * 
 */
export type BusinessHour = runtime.Types.DefaultSelection<BusinessHourPayload>
export type StaffPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Staff"
  objects: {
    business: BusinessPayload<ExtArgs>
    schedules: StaffSchedulePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    businessId: string
    name: string
    role: string
    email: string | null
    phone: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["staff"]>
  composites: {}
}

/**
 * Model Staff
 * 
 */
export type Staff = runtime.Types.DefaultSelection<StaffPayload>
export type StaffSchedulePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "StaffSchedule"
  objects: {
    staff: StaffPayload<ExtArgs>
    attendanceRecords: AttendanceRecordPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    staffId: string
    date: Date
    startTime: Date
    endTime: Date
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["staffSchedule"]>
  composites: {}
}

/**
 * Model StaffSchedule
 * 
 */
export type StaffSchedule = runtime.Types.DefaultSelection<StaffSchedulePayload>
export type AttendanceRecordPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "AttendanceRecord"
  objects: {
    schedule: StaffSchedulePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    scheduleId: string
    status: string
    timestamp: Date
  }, ExtArgs["result"]["attendanceRecord"]>
  composites: {}
}

/**
 * Model AttendanceRecord
 * 
 */
export type AttendanceRecord = runtime.Types.DefaultSelection<AttendanceRecordPayload>
export type TrainingModulePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "TrainingModule"
  objects: {
    trainingProgress: TrainingProgressPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    title: string
    description: string | null
    contentUrl: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["trainingModule"]>
  composites: {}
}

/**
 * Model TrainingModule
 * 
 */
export type TrainingModule = runtime.Types.DefaultSelection<TrainingModulePayload>
export type TrainingProgressPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "TrainingProgress"
  objects: {
    user: UserPayload<ExtArgs>
    module: TrainingModulePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    moduleId: string
    completedAt: Date
  }, ExtArgs["result"]["trainingProgress"]>
  composites: {}
}

/**
 * Model TrainingProgress
 * 
 */
export type TrainingProgress = runtime.Types.DefaultSelection<TrainingProgressPayload>
export type LoyaltyTierPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "LoyaltyTier"
  objects: {
    transactions: LoyaltyTransactionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    requiredPoints: number
    discount: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["loyaltyTier"]>
  composites: {}
}

/**
 * Model LoyaltyTier
 * 
 */
export type LoyaltyTier = runtime.Types.DefaultSelection<LoyaltyTierPayload>
export type LoyaltyTransactionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "LoyaltyTransaction"
  objects: {
    user: UserPayload<ExtArgs>
    tier: LoyaltyTierPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    tierId: string | null
    points: number
    type: TransactionType
    createdAt: Date
  }, ExtArgs["result"]["loyaltyTransaction"]>
  composites: {}
}

/**
 * Model LoyaltyTransaction
 * 
 */
export type LoyaltyTransaction = runtime.Types.DefaultSelection<LoyaltyTransactionPayload>
export type SubscriptionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Subscription"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    stripeSubscriptionId: string
    priceId: string
    status: string
    currentPeriodStart: Date
    currentPeriodEnd: Date
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["subscription"]>
  composites: {}
}

/**
 * Model Subscription
 * 
 */
export type Subscription = runtime.Types.DefaultSelection<SubscriptionPayload>
export type AnalyticsEventPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "AnalyticsEvent"
  objects: {
    user: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string | null
    event: string
    properties: Prisma.JsonValue | null
    createdAt: Date
  }, ExtArgs["result"]["analyticsEvent"]>
  composites: {}
}

/**
 * Model AnalyticsEvent
 * 
 */
export type AnalyticsEvent = runtime.Types.DefaultSelection<AnalyticsEventPayload>
export type PaymentTransactionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "PaymentTransaction"
  objects: {
    user: UserPayload<ExtArgs>
    service: ServicePayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    amount: number
    currency: string
    mode: string
    createdAt: Date
    serviceId: string | null
  }, ExtArgs["result"]["paymentTransaction"]>
  composites: {}
}

/**
 * Model PaymentTransaction
 * 
 */
export type PaymentTransaction = runtime.Types.DefaultSelection<PaymentTransactionPayload>
export type PromotionCodePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "PromotionCode"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    code: string
    description: string | null
    discount: number
    validFrom: Date
    validTo: Date
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["promotionCode"]>
  composites: {}
}

/**
 * Model PromotionCode
 * 
 */
export type PromotionCode = runtime.Types.DefaultSelection<PromotionCodePayload>
export type EmailCampaignPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "EmailCampaign"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    subject: string
    body: string
    scheduledAt: Date | null
    sent: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["emailCampaign"]>
  composites: {}
}

/**
 * Model EmailCampaign
 * 
 */
export type EmailCampaign = runtime.Types.DefaultSelection<EmailCampaignPayload>
export type NotificationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Notification"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    title: string
    message: string
    read: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["notification"]>
  composites: {}
}

/**
 * Model Notification
 * 
 */
export type Notification = runtime.Types.DefaultSelection<NotificationPayload>
export type GoogleCalendarTokenPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "GoogleCalendarToken"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    accessToken: string
    refreshToken: string
    scope: string | null
    tokenType: string | null
    expiryDate: Date | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["googleCalendarToken"]>
  composites: {}
}

/**
 * Model GoogleCalendarToken
 * 
 */
export type GoogleCalendarToken = runtime.Types.DefaultSelection<GoogleCalendarTokenPayload>
export type OutlookCalendarTokenPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OutlookCalendarToken"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    accessToken: string
    refreshToken: string
    scope: string | null
    tokenType: string | null
    expiryDate: Date | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["outlookCalendarToken"]>
  composites: {}
}

/**
 * Model OutlookCalendarToken
 * 
 */
export type OutlookCalendarToken = runtime.Types.DefaultSelection<OutlookCalendarTokenPayload>
export type FormDefinitionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "FormDefinition"
  objects: {
    submissions: FormSubmissionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    fields: Prisma.JsonValue
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["formDefinition"]>
  composites: {}
}

/**
 * Model FormDefinition
 * 
 */
export type FormDefinition = runtime.Types.DefaultSelection<FormDefinitionPayload>
export type FormSubmissionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "FormSubmission"
  objects: {
    definition: FormDefinitionPayload<ExtArgs>
    documents: DocumentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    definitionId: string
    data: Prisma.JsonValue
    submittedAt: Date
  }, ExtArgs["result"]["formSubmission"]>
  composites: {}
}

/**
 * Model FormSubmission
 * 
 */
export type FormSubmission = runtime.Types.DefaultSelection<FormSubmissionPayload>
export type DocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Document"
  objects: {
    submission: FormSubmissionPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    url: string
    type: string
    submissionId: string | null
    createdAt: Date
  }, ExtArgs["result"]["document"]>
  composites: {}
}

/**
 * Model Document
 * 
 */
export type Document = runtime.Types.DefaultSelection<DocumentPayload>
export type InventoryItemPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "InventoryItem"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string | null
    quantity: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["inventoryItem"]>
  composites: {}
}

/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = runtime.Types.DefaultSelection<InventoryItemPayload>
export type EquipmentItemPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "EquipmentItem"
  objects: {
    assignments: EquipmentAssignmentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string | null
    serialNumber: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["equipmentItem"]>
  composites: {}
}

/**
 * Model EquipmentItem
 * 
 */
export type EquipmentItem = runtime.Types.DefaultSelection<EquipmentItemPayload>
export type EquipmentAssignmentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "EquipmentAssignment"
  objects: {
    equipment: EquipmentItemPayload<ExtArgs>
    assignedToUser: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    equipmentId: string
    assignedTo: string
    assignedAt: Date
    returnedAt: Date | null
  }, ExtArgs["result"]["equipmentAssignment"]>
  composites: {}
}

/**
 * Model EquipmentAssignment
 * 
 */
export type EquipmentAssignment = runtime.Types.DefaultSelection<EquipmentAssignmentPayload>
export type PostPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Post"
  objects: {
    author: UserPayload<ExtArgs>
    comments: CommentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    authorId: string
    content: string
    createdAt: Date
  }, ExtArgs["result"]["post"]>
  composites: {}
}

/**
 * Model Post
 * 
 */
export type Post = runtime.Types.DefaultSelection<PostPayload>
export type CommentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Comment"
  objects: {
    post: PostPayload<ExtArgs>
    author: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    postId: string
    authorId: string
    content: string
    createdAt: Date
  }, ExtArgs["result"]["comment"]>
  composites: {}
}

/**
 * Model Comment
 * 
 */
export type Comment = runtime.Types.DefaultSelection<CommentPayload>
export type CommunityEventPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "CommunityEvent"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    title: string
    description: string | null
    startAt: Date
    endAt: Date | null
    location: string | null
    createdAt: Date
  }, ExtArgs["result"]["communityEvent"]>
  composites: {}
}

/**
 * Model CommunityEvent
 * 
 */
export type CommunityEvent = runtime.Types.DefaultSelection<CommunityEventPayload>
export type SocialPostPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "SocialPost"
  objects: {
    author: UserPayload<ExtArgs>
    comments: PostCommentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    authorId: string
    content: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["socialPost"]>
  composites: {}
}

/**
 * Model SocialPost
 * 
 */
export type SocialPost = runtime.Types.DefaultSelection<SocialPostPayload>
export type PostCommentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "PostComment"
  objects: {
    post: SocialPostPayload<ExtArgs>
    author: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    postId: string
    authorId: string
    content: string
    createdAt: Date
  }, ExtArgs["result"]["postComment"]>
  composites: {}
}

/**
 * Model PostComment
 * 
 */
export type PostComment = runtime.Types.DefaultSelection<PostCommentPayload>
export type EventPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Event"
  objects: {
    registrations: EventRegistrationPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    title: string
    description: string | null
    date: Date
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["event"]>
  composites: {}
}

/**
 * Model Event
 * 
 */
export type Event = runtime.Types.DefaultSelection<EventPayload>
export type EventRegistrationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "EventRegistration"
  objects: {
    event: EventPayload<ExtArgs>
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    eventId: string
    userId: string
    registeredAt: Date
  }, ExtArgs["result"]["eventRegistration"]>
  composites: {}
}

/**
 * Model EventRegistration
 * 
 */
export type EventRegistration = runtime.Types.DefaultSelection<EventRegistrationPayload>
export type ForumThreadPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ForumThread"
  objects: {
    author: UserPayload<ExtArgs>
    posts: ForumPostPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    title: string
    authorId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["forumThread"]>
  composites: {}
}

/**
 * Model ForumThread
 * 
 */
export type ForumThread = runtime.Types.DefaultSelection<ForumThreadPayload>
export type ForumPostPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ForumPost"
  objects: {
    thread: ForumThreadPayload<ExtArgs>
    author: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    threadId: string
    authorId: string
    content: string
    createdAt: Date
  }, ExtArgs["result"]["forumPost"]>
  composites: {}
}

/**
 * Model ForumPost
 * 
 */
export type ForumPost = runtime.Types.DefaultSelection<ForumPostPayload>
export type BenefitClaimPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "BenefitClaim"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    type: string
    status: string
    amount: number | null
    requestedAt: Date
    processedAt: Date | null
  }, ExtArgs["result"]["benefitClaim"]>
  composites: {}
}

/**
 * Model BenefitClaim
 * 
 */
export type BenefitClaim = runtime.Types.DefaultSelection<BenefitClaimPayload>
export type PayrollRecordPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "PayrollRecord"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    salary: number
    periodStart: Date
    periodEnd: Date
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["payrollRecord"]>
  composites: {}
}

/**
 * Model PayrollRecord
 * 
 */
export type PayrollRecord = runtime.Types.DefaultSelection<PayrollRecordPayload>
export type BookingPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Booking"
  objects: {
    user: UserPayload<ExtArgs>
    service: ServicePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    serviceId: string
    appointmentDate: Date
    duration: number
    specialRequests: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    googleEventId: string | null
    outlookEventId: string | null
  }, ExtArgs["result"]["booking"]>
  composites: {}
}

/**
 * Model Booking
 * 
 */
export type Booking = runtime.Types.DefaultSelection<BookingPayload>
export type TwoFactorAuthPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "TwoFactorAuth"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    secret: string
    verified: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["twoFactorAuth"]>
  composites: {}
}

/**
 * Model TwoFactorAuth
 * 
 */
export type TwoFactorAuth = runtime.Types.DefaultSelection<TwoFactorAuthPayload>
export type WebAuthnCredentialPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "WebAuthnCredential"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    credentialId: string
    publicKey: string
    counter: number
    transports: string[]
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["webAuthnCredential"]>
  composites: {}
}

/**
 * Model WebAuthnCredential
 * 
 */
export type WebAuthnCredential = runtime.Types.DefaultSelection<WebAuthnCredentialPayload>

/**
 * Enums
 */

export const Role: {
  USER: 'USER',
  PROVIDER: 'PROVIDER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const TransactionType: {
  EARN: 'EARN',
  REDEEM: 'REDEEM'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.provider`: Exposes CRUD operations for the **Provider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.provider.findMany()
    * ```
    */
  get provider(): Prisma.ProviderDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.business`: Exposes CRUD operations for the **Business** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Businesses
    * const businesses = await prisma.business.findMany()
    * ```
    */
  get business(): Prisma.BusinessDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.businessHour`: Exposes CRUD operations for the **BusinessHour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessHours
    * const businessHours = await prisma.businessHour.findMany()
    * ```
    */
  get businessHour(): Prisma.BusinessHourDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.StaffDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.staffSchedule`: Exposes CRUD operations for the **StaffSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffSchedules
    * const staffSchedules = await prisma.staffSchedule.findMany()
    * ```
    */
  get staffSchedule(): Prisma.StaffScheduleDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.attendanceRecord`: Exposes CRUD operations for the **AttendanceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceRecords
    * const attendanceRecords = await prisma.attendanceRecord.findMany()
    * ```
    */
  get attendanceRecord(): Prisma.AttendanceRecordDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.trainingModule`: Exposes CRUD operations for the **TrainingModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingModules
    * const trainingModules = await prisma.trainingModule.findMany()
    * ```
    */
  get trainingModule(): Prisma.TrainingModuleDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.trainingProgress`: Exposes CRUD operations for the **TrainingProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingProgresses
    * const trainingProgresses = await prisma.trainingProgress.findMany()
    * ```
    */
  get trainingProgress(): Prisma.TrainingProgressDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.loyaltyTier`: Exposes CRUD operations for the **LoyaltyTier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoyaltyTiers
    * const loyaltyTiers = await prisma.loyaltyTier.findMany()
    * ```
    */
  get loyaltyTier(): Prisma.LoyaltyTierDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.loyaltyTransaction`: Exposes CRUD operations for the **LoyaltyTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoyaltyTransactions
    * const loyaltyTransactions = await prisma.loyaltyTransaction.findMany()
    * ```
    */
  get loyaltyTransaction(): Prisma.LoyaltyTransactionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.analyticsEvent`: Exposes CRUD operations for the **AnalyticsEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsEvents
    * const analyticsEvents = await prisma.analyticsEvent.findMany()
    * ```
    */
  get analyticsEvent(): Prisma.AnalyticsEventDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.paymentTransaction`: Exposes CRUD operations for the **PaymentTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentTransactions
    * const paymentTransactions = await prisma.paymentTransaction.findMany()
    * ```
    */
  get paymentTransaction(): Prisma.PaymentTransactionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.promotionCode`: Exposes CRUD operations for the **PromotionCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromotionCodes
    * const promotionCodes = await prisma.promotionCode.findMany()
    * ```
    */
  get promotionCode(): Prisma.PromotionCodeDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.emailCampaign`: Exposes CRUD operations for the **EmailCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailCampaigns
    * const emailCampaigns = await prisma.emailCampaign.findMany()
    * ```
    */
  get emailCampaign(): Prisma.EmailCampaignDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.googleCalendarToken`: Exposes CRUD operations for the **GoogleCalendarToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoogleCalendarTokens
    * const googleCalendarTokens = await prisma.googleCalendarToken.findMany()
    * ```
    */
  get googleCalendarToken(): Prisma.GoogleCalendarTokenDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.outlookCalendarToken`: Exposes CRUD operations for the **OutlookCalendarToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutlookCalendarTokens
    * const outlookCalendarTokens = await prisma.outlookCalendarToken.findMany()
    * ```
    */
  get outlookCalendarToken(): Prisma.OutlookCalendarTokenDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.formDefinition`: Exposes CRUD operations for the **FormDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormDefinitions
    * const formDefinitions = await prisma.formDefinition.findMany()
    * ```
    */
  get formDefinition(): Prisma.FormDefinitionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.formSubmission`: Exposes CRUD operations for the **FormSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormSubmissions
    * const formSubmissions = await prisma.formSubmission.findMany()
    * ```
    */
  get formSubmission(): Prisma.FormSubmissionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.equipmentItem`: Exposes CRUD operations for the **EquipmentItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentItems
    * const equipmentItems = await prisma.equipmentItem.findMany()
    * ```
    */
  get equipmentItem(): Prisma.EquipmentItemDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.equipmentAssignment`: Exposes CRUD operations for the **EquipmentAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentAssignments
    * const equipmentAssignments = await prisma.equipmentAssignment.findMany()
    * ```
    */
  get equipmentAssignment(): Prisma.EquipmentAssignmentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.communityEvent`: Exposes CRUD operations for the **CommunityEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityEvents
    * const communityEvents = await prisma.communityEvent.findMany()
    * ```
    */
  get communityEvent(): Prisma.CommunityEventDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.socialPost`: Exposes CRUD operations for the **SocialPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialPosts
    * const socialPosts = await prisma.socialPost.findMany()
    * ```
    */
  get socialPost(): Prisma.SocialPostDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.postComment`: Exposes CRUD operations for the **PostComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostComments
    * const postComments = await prisma.postComment.findMany()
    * ```
    */
  get postComment(): Prisma.PostCommentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.eventRegistration`: Exposes CRUD operations for the **EventRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventRegistrations
    * const eventRegistrations = await prisma.eventRegistration.findMany()
    * ```
    */
  get eventRegistration(): Prisma.EventRegistrationDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.forumThread`: Exposes CRUD operations for the **ForumThread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumThreads
    * const forumThreads = await prisma.forumThread.findMany()
    * ```
    */
  get forumThread(): Prisma.ForumThreadDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.forumPost`: Exposes CRUD operations for the **ForumPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumPosts
    * const forumPosts = await prisma.forumPost.findMany()
    * ```
    */
  get forumPost(): Prisma.ForumPostDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.benefitClaim`: Exposes CRUD operations for the **BenefitClaim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BenefitClaims
    * const benefitClaims = await prisma.benefitClaim.findMany()
    * ```
    */
  get benefitClaim(): Prisma.BenefitClaimDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.payrollRecord`: Exposes CRUD operations for the **PayrollRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayrollRecords
    * const payrollRecords = await prisma.payrollRecord.findMany()
    * ```
    */
  get payrollRecord(): Prisma.PayrollRecordDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.twoFactorAuth`: Exposes CRUD operations for the **TwoFactorAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwoFactorAuths
    * const twoFactorAuths = await prisma.twoFactorAuth.findMany()
    * ```
    */
  get twoFactorAuth(): Prisma.TwoFactorAuthDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.webAuthnCredential`: Exposes CRUD operations for the **WebAuthnCredential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebAuthnCredentials
    * const webAuthnCredentials = await prisma.webAuthnCredential.findMany()
    * ```
    */
  get webAuthnCredential(): Prisma.WebAuthnCredentialDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Provider: 'Provider',
    Service: 'Service',
    Business: 'Business',
    BusinessHour: 'BusinessHour',
    Staff: 'Staff',
    StaffSchedule: 'StaffSchedule',
    AttendanceRecord: 'AttendanceRecord',
    TrainingModule: 'TrainingModule',
    TrainingProgress: 'TrainingProgress',
    LoyaltyTier: 'LoyaltyTier',
    LoyaltyTransaction: 'LoyaltyTransaction',
    Subscription: 'Subscription',
    AnalyticsEvent: 'AnalyticsEvent',
    PaymentTransaction: 'PaymentTransaction',
    PromotionCode: 'PromotionCode',
    EmailCampaign: 'EmailCampaign',
    Notification: 'Notification',
    GoogleCalendarToken: 'GoogleCalendarToken',
    OutlookCalendarToken: 'OutlookCalendarToken',
    FormDefinition: 'FormDefinition',
    FormSubmission: 'FormSubmission',
    Document: 'Document',
    InventoryItem: 'InventoryItem',
    EquipmentItem: 'EquipmentItem',
    EquipmentAssignment: 'EquipmentAssignment',
    Post: 'Post',
    Comment: 'Comment',
    CommunityEvent: 'CommunityEvent',
    SocialPost: 'SocialPost',
    PostComment: 'PostComment',
    Event: 'Event',
    EventRegistration: 'EventRegistration',
    ForumThread: 'ForumThread',
    ForumPost: 'ForumPost',
    BenefitClaim: 'BenefitClaim',
    PayrollRecord: 'PayrollRecord',
    Booking: 'Booking',
    TwoFactorAuth: 'TwoFactorAuth',
    WebAuthnCredential: 'WebAuthnCredential'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'provider' | 'service' | 'business' | 'businessHour' | 'staff' | 'staffSchedule' | 'attendanceRecord' | 'trainingModule' | 'trainingProgress' | 'loyaltyTier' | 'loyaltyTransaction' | 'subscription' | 'analyticsEvent' | 'paymentTransaction' | 'promotionCode' | 'emailCampaign' | 'notification' | 'googleCalendarToken' | 'outlookCalendarToken' | 'formDefinition' | 'formSubmission' | 'document' | 'inventoryItem' | 'equipmentItem' | 'equipmentAssignment' | 'post' | 'comment' | 'communityEvent' | 'socialPost' | 'postComment' | 'event' | 'eventRegistration' | 'forumThread' | 'forumPost' | 'benefitClaim' | 'payrollRecord' | 'booking' | 'twoFactorAuth' | 'webAuthnCredential'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: UserPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Provider: {
        payload: ProviderPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProviderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProviderPayload>
          }
          findFirst: {
            args: Prisma.ProviderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProviderPayload>
          }
          findMany: {
            args: Prisma.ProviderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProviderPayload>[]
          }
          create: {
            args: Prisma.ProviderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProviderPayload>
          }
          createMany: {
            args: Prisma.ProviderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProviderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProviderPayload>
          }
          update: {
            args: Prisma.ProviderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProviderPayload>
          }
          deleteMany: {
            args: Prisma.ProviderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProviderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProviderPayload>
          }
          aggregate: {
            args: Prisma.ProviderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProvider>
          }
          groupBy: {
            args: Prisma.ProviderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderCountArgs<ExtArgs>,
            result: $Utils.Optional<ProviderCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: ServicePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Business: {
        payload: BusinessPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.BusinessFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessPayload>
          }
          findFirst: {
            args: Prisma.BusinessFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessPayload>
          }
          findMany: {
            args: Prisma.BusinessFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessPayload>[]
          }
          create: {
            args: Prisma.BusinessCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessPayload>
          }
          createMany: {
            args: Prisma.BusinessCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BusinessDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessPayload>
          }
          update: {
            args: Prisma.BusinessUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessPayload>
          }
          deleteMany: {
            args: Prisma.BusinessDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BusinessUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessPayload>
          }
          aggregate: {
            args: Prisma.BusinessAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBusiness>
          }
          groupBy: {
            args: Prisma.BusinessGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BusinessGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessCountArgs<ExtArgs>,
            result: $Utils.Optional<BusinessCountAggregateOutputType> | number
          }
        }
      }
      BusinessHour: {
        payload: BusinessHourPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.BusinessHourFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessHourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessHourFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessHourPayload>
          }
          findFirst: {
            args: Prisma.BusinessHourFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessHourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessHourFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessHourPayload>
          }
          findMany: {
            args: Prisma.BusinessHourFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessHourPayload>[]
          }
          create: {
            args: Prisma.BusinessHourCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessHourPayload>
          }
          createMany: {
            args: Prisma.BusinessHourCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BusinessHourDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessHourPayload>
          }
          update: {
            args: Prisma.BusinessHourUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessHourPayload>
          }
          deleteMany: {
            args: Prisma.BusinessHourDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessHourUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BusinessHourUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessHourPayload>
          }
          aggregate: {
            args: Prisma.BusinessHourAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBusinessHour>
          }
          groupBy: {
            args: Prisma.BusinessHourGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BusinessHourGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessHourCountArgs<ExtArgs>,
            result: $Utils.Optional<BusinessHourCountAggregateOutputType> | number
          }
        }
      }
      Staff: {
        payload: StaffPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.StaffFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          findFirst: {
            args: Prisma.StaffFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          findMany: {
            args: Prisma.StaffFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>[]
          }
          create: {
            args: Prisma.StaffCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          createMany: {
            args: Prisma.StaffCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StaffDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          update: {
            args: Prisma.StaffUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          deleteMany: {
            args: Prisma.StaffDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StaffUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StaffUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStaff>
          }
          groupBy: {
            args: Prisma.StaffGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffCountArgs<ExtArgs>,
            result: $Utils.Optional<StaffCountAggregateOutputType> | number
          }
        }
      }
      StaffSchedule: {
        payload: StaffSchedulePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.StaffScheduleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffScheduleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffSchedulePayload>
          }
          findFirst: {
            args: Prisma.StaffScheduleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffScheduleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffSchedulePayload>
          }
          findMany: {
            args: Prisma.StaffScheduleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffSchedulePayload>[]
          }
          create: {
            args: Prisma.StaffScheduleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffSchedulePayload>
          }
          createMany: {
            args: Prisma.StaffScheduleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StaffScheduleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffSchedulePayload>
          }
          update: {
            args: Prisma.StaffScheduleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffSchedulePayload>
          }
          deleteMany: {
            args: Prisma.StaffScheduleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StaffScheduleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StaffScheduleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffSchedulePayload>
          }
          aggregate: {
            args: Prisma.StaffScheduleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStaffSchedule>
          }
          groupBy: {
            args: Prisma.StaffScheduleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StaffScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffScheduleCountArgs<ExtArgs>,
            result: $Utils.Optional<StaffScheduleCountAggregateOutputType> | number
          }
        }
      }
      AttendanceRecord: {
        payload: AttendanceRecordPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AttendanceRecordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AttendanceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AttendanceRecordPayload>
          }
          findFirst: {
            args: Prisma.AttendanceRecordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AttendanceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceRecordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AttendanceRecordPayload>
          }
          findMany: {
            args: Prisma.AttendanceRecordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AttendanceRecordPayload>[]
          }
          create: {
            args: Prisma.AttendanceRecordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AttendanceRecordPayload>
          }
          createMany: {
            args: Prisma.AttendanceRecordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AttendanceRecordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AttendanceRecordPayload>
          }
          update: {
            args: Prisma.AttendanceRecordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AttendanceRecordPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceRecordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceRecordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceRecordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AttendanceRecordPayload>
          }
          aggregate: {
            args: Prisma.AttendanceRecordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAttendanceRecord>
          }
          groupBy: {
            args: Prisma.AttendanceRecordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AttendanceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceRecordCountArgs<ExtArgs>,
            result: $Utils.Optional<AttendanceRecordCountAggregateOutputType> | number
          }
        }
      }
      TrainingModule: {
        payload: TrainingModulePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TrainingModuleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingModuleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingModulePayload>
          }
          findFirst: {
            args: Prisma.TrainingModuleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingModuleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingModulePayload>
          }
          findMany: {
            args: Prisma.TrainingModuleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingModulePayload>[]
          }
          create: {
            args: Prisma.TrainingModuleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingModulePayload>
          }
          createMany: {
            args: Prisma.TrainingModuleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TrainingModuleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingModulePayload>
          }
          update: {
            args: Prisma.TrainingModuleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingModulePayload>
          }
          deleteMany: {
            args: Prisma.TrainingModuleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingModuleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TrainingModuleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingModulePayload>
          }
          aggregate: {
            args: Prisma.TrainingModuleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTrainingModule>
          }
          groupBy: {
            args: Prisma.TrainingModuleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TrainingModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingModuleCountArgs<ExtArgs>,
            result: $Utils.Optional<TrainingModuleCountAggregateOutputType> | number
          }
        }
      }
      TrainingProgress: {
        payload: TrainingProgressPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TrainingProgressFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingProgressFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingProgressPayload>
          }
          findFirst: {
            args: Prisma.TrainingProgressFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingProgressFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingProgressPayload>
          }
          findMany: {
            args: Prisma.TrainingProgressFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingProgressPayload>[]
          }
          create: {
            args: Prisma.TrainingProgressCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingProgressPayload>
          }
          createMany: {
            args: Prisma.TrainingProgressCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TrainingProgressDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingProgressPayload>
          }
          update: {
            args: Prisma.TrainingProgressUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingProgressPayload>
          }
          deleteMany: {
            args: Prisma.TrainingProgressDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingProgressUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TrainingProgressUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TrainingProgressPayload>
          }
          aggregate: {
            args: Prisma.TrainingProgressAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTrainingProgress>
          }
          groupBy: {
            args: Prisma.TrainingProgressGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TrainingProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingProgressCountArgs<ExtArgs>,
            result: $Utils.Optional<TrainingProgressCountAggregateOutputType> | number
          }
        }
      }
      LoyaltyTier: {
        payload: LoyaltyTierPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.LoyaltyTierFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoyaltyTierFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTierPayload>
          }
          findFirst: {
            args: Prisma.LoyaltyTierFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoyaltyTierFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTierPayload>
          }
          findMany: {
            args: Prisma.LoyaltyTierFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTierPayload>[]
          }
          create: {
            args: Prisma.LoyaltyTierCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTierPayload>
          }
          createMany: {
            args: Prisma.LoyaltyTierCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LoyaltyTierDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTierPayload>
          }
          update: {
            args: Prisma.LoyaltyTierUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTierPayload>
          }
          deleteMany: {
            args: Prisma.LoyaltyTierDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LoyaltyTierUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LoyaltyTierUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTierPayload>
          }
          aggregate: {
            args: Prisma.LoyaltyTierAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLoyaltyTier>
          }
          groupBy: {
            args: Prisma.LoyaltyTierGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LoyaltyTierGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoyaltyTierCountArgs<ExtArgs>,
            result: $Utils.Optional<LoyaltyTierCountAggregateOutputType> | number
          }
        }
      }
      LoyaltyTransaction: {
        payload: LoyaltyTransactionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.LoyaltyTransactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTransactionPayload>
          }
          findFirst: {
            args: Prisma.LoyaltyTransactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoyaltyTransactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTransactionPayload>
          }
          findMany: {
            args: Prisma.LoyaltyTransactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTransactionPayload>[]
          }
          create: {
            args: Prisma.LoyaltyTransactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTransactionPayload>
          }
          createMany: {
            args: Prisma.LoyaltyTransactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LoyaltyTransactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTransactionPayload>
          }
          update: {
            args: Prisma.LoyaltyTransactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTransactionPayload>
          }
          deleteMany: {
            args: Prisma.LoyaltyTransactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LoyaltyTransactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LoyaltyTransactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LoyaltyTransactionPayload>
          }
          aggregate: {
            args: Prisma.LoyaltyTransactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLoyaltyTransaction>
          }
          groupBy: {
            args: Prisma.LoyaltyTransactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LoyaltyTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoyaltyTransactionCountArgs<ExtArgs>,
            result: $Utils.Optional<LoyaltyTransactionCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: SubscriptionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsEvent: {
        payload: AnalyticsEventPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AnalyticsEventFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnalyticsEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnalyticsEventPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsEventFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnalyticsEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsEventFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnalyticsEventPayload>
          }
          findMany: {
            args: Prisma.AnalyticsEventFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnalyticsEventPayload>[]
          }
          create: {
            args: Prisma.AnalyticsEventCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnalyticsEventPayload>
          }
          createMany: {
            args: Prisma.AnalyticsEventCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AnalyticsEventDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnalyticsEventPayload>
          }
          update: {
            args: Prisma.AnalyticsEventUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnalyticsEventPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsEventDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsEventUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AnalyticsEventUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnalyticsEventPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsEventAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAnalyticsEvent>
          }
          groupBy: {
            args: Prisma.AnalyticsEventGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AnalyticsEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsEventCountArgs<ExtArgs>,
            result: $Utils.Optional<AnalyticsEventCountAggregateOutputType> | number
          }
        }
      }
      PaymentTransaction: {
        payload: PaymentTransactionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PaymentTransactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentTransactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentTransactionPayload>
          }
          findFirst: {
            args: Prisma.PaymentTransactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentTransactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentTransactionPayload>
          }
          findMany: {
            args: Prisma.PaymentTransactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentTransactionPayload>[]
          }
          create: {
            args: Prisma.PaymentTransactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentTransactionPayload>
          }
          createMany: {
            args: Prisma.PaymentTransactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PaymentTransactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentTransactionPayload>
          }
          update: {
            args: Prisma.PaymentTransactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentTransactionPayload>
          }
          deleteMany: {
            args: Prisma.PaymentTransactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentTransactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PaymentTransactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentTransactionPayload>
          }
          aggregate: {
            args: Prisma.PaymentTransactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePaymentTransaction>
          }
          groupBy: {
            args: Prisma.PaymentTransactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PaymentTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentTransactionCountArgs<ExtArgs>,
            result: $Utils.Optional<PaymentTransactionCountAggregateOutputType> | number
          }
        }
      }
      PromotionCode: {
        payload: PromotionCodePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PromotionCodeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromotionCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionCodeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromotionCodePayload>
          }
          findFirst: {
            args: Prisma.PromotionCodeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromotionCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionCodeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromotionCodePayload>
          }
          findMany: {
            args: Prisma.PromotionCodeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromotionCodePayload>[]
          }
          create: {
            args: Prisma.PromotionCodeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromotionCodePayload>
          }
          createMany: {
            args: Prisma.PromotionCodeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PromotionCodeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromotionCodePayload>
          }
          update: {
            args: Prisma.PromotionCodeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromotionCodePayload>
          }
          deleteMany: {
            args: Prisma.PromotionCodeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionCodeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PromotionCodeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromotionCodePayload>
          }
          aggregate: {
            args: Prisma.PromotionCodeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePromotionCode>
          }
          groupBy: {
            args: Prisma.PromotionCodeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PromotionCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCodeCountArgs<ExtArgs>,
            result: $Utils.Optional<PromotionCodeCountAggregateOutputType> | number
          }
        }
      }
      EmailCampaign: {
        payload: EmailCampaignPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.EmailCampaignFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmailCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailCampaignFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmailCampaignPayload>
          }
          findFirst: {
            args: Prisma.EmailCampaignFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmailCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailCampaignFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmailCampaignPayload>
          }
          findMany: {
            args: Prisma.EmailCampaignFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmailCampaignPayload>[]
          }
          create: {
            args: Prisma.EmailCampaignCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmailCampaignPayload>
          }
          createMany: {
            args: Prisma.EmailCampaignCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailCampaignDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmailCampaignPayload>
          }
          update: {
            args: Prisma.EmailCampaignUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmailCampaignPayload>
          }
          deleteMany: {
            args: Prisma.EmailCampaignDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailCampaignUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailCampaignUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EmailCampaignPayload>
          }
          aggregate: {
            args: Prisma.EmailCampaignAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailCampaign>
          }
          groupBy: {
            args: Prisma.EmailCampaignGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailCampaignCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailCampaignCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: NotificationPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      GoogleCalendarToken: {
        payload: GoogleCalendarTokenPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.GoogleCalendarTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GoogleCalendarTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoogleCalendarTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GoogleCalendarTokenPayload>
          }
          findFirst: {
            args: Prisma.GoogleCalendarTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GoogleCalendarTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoogleCalendarTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GoogleCalendarTokenPayload>
          }
          findMany: {
            args: Prisma.GoogleCalendarTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GoogleCalendarTokenPayload>[]
          }
          create: {
            args: Prisma.GoogleCalendarTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GoogleCalendarTokenPayload>
          }
          createMany: {
            args: Prisma.GoogleCalendarTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GoogleCalendarTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GoogleCalendarTokenPayload>
          }
          update: {
            args: Prisma.GoogleCalendarTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GoogleCalendarTokenPayload>
          }
          deleteMany: {
            args: Prisma.GoogleCalendarTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GoogleCalendarTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GoogleCalendarTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GoogleCalendarTokenPayload>
          }
          aggregate: {
            args: Prisma.GoogleCalendarTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGoogleCalendarToken>
          }
          groupBy: {
            args: Prisma.GoogleCalendarTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GoogleCalendarTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoogleCalendarTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<GoogleCalendarTokenCountAggregateOutputType> | number
          }
        }
      }
      OutlookCalendarToken: {
        payload: OutlookCalendarTokenPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.OutlookCalendarTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutlookCalendarTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutlookCalendarTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutlookCalendarTokenPayload>
          }
          findFirst: {
            args: Prisma.OutlookCalendarTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutlookCalendarTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutlookCalendarTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutlookCalendarTokenPayload>
          }
          findMany: {
            args: Prisma.OutlookCalendarTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutlookCalendarTokenPayload>[]
          }
          create: {
            args: Prisma.OutlookCalendarTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutlookCalendarTokenPayload>
          }
          createMany: {
            args: Prisma.OutlookCalendarTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OutlookCalendarTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutlookCalendarTokenPayload>
          }
          update: {
            args: Prisma.OutlookCalendarTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutlookCalendarTokenPayload>
          }
          deleteMany: {
            args: Prisma.OutlookCalendarTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OutlookCalendarTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OutlookCalendarTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OutlookCalendarTokenPayload>
          }
          aggregate: {
            args: Prisma.OutlookCalendarTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOutlookCalendarToken>
          }
          groupBy: {
            args: Prisma.OutlookCalendarTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OutlookCalendarTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutlookCalendarTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<OutlookCalendarTokenCountAggregateOutputType> | number
          }
        }
      }
      FormDefinition: {
        payload: FormDefinitionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.FormDefinitionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormDefinitionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormDefinitionPayload>
          }
          findFirst: {
            args: Prisma.FormDefinitionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormDefinitionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormDefinitionPayload>
          }
          findMany: {
            args: Prisma.FormDefinitionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormDefinitionPayload>[]
          }
          create: {
            args: Prisma.FormDefinitionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormDefinitionPayload>
          }
          createMany: {
            args: Prisma.FormDefinitionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FormDefinitionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormDefinitionPayload>
          }
          update: {
            args: Prisma.FormDefinitionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.FormDefinitionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FormDefinitionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FormDefinitionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormDefinitionPayload>
          }
          aggregate: {
            args: Prisma.FormDefinitionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFormDefinition>
          }
          groupBy: {
            args: Prisma.FormDefinitionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FormDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormDefinitionCountArgs<ExtArgs>,
            result: $Utils.Optional<FormDefinitionCountAggregateOutputType> | number
          }
        }
      }
      FormSubmission: {
        payload: FormSubmissionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.FormSubmissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormSubmissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormSubmissionPayload>
          }
          findFirst: {
            args: Prisma.FormSubmissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormSubmissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormSubmissionPayload>
          }
          findMany: {
            args: Prisma.FormSubmissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormSubmissionPayload>[]
          }
          create: {
            args: Prisma.FormSubmissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormSubmissionPayload>
          }
          createMany: {
            args: Prisma.FormSubmissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FormSubmissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormSubmissionPayload>
          }
          update: {
            args: Prisma.FormSubmissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.FormSubmissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FormSubmissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FormSubmissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FormSubmissionPayload>
          }
          aggregate: {
            args: Prisma.FormSubmissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFormSubmission>
          }
          groupBy: {
            args: Prisma.FormSubmissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FormSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormSubmissionCountArgs<ExtArgs>,
            result: $Utils.Optional<FormSubmissionCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: DocumentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: InventoryItemPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>,
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      EquipmentItem: {
        payload: EquipmentItemPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.EquipmentItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentItemPayload>
          }
          findFirst: {
            args: Prisma.EquipmentItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentItemPayload>
          }
          findMany: {
            args: Prisma.EquipmentItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentItemPayload>[]
          }
          create: {
            args: Prisma.EquipmentItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentItemPayload>
          }
          createMany: {
            args: Prisma.EquipmentItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EquipmentItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentItemPayload>
          }
          update: {
            args: Prisma.EquipmentItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentItemPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EquipmentItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentItemPayload>
          }
          aggregate: {
            args: Prisma.EquipmentItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEquipmentItem>
          }
          groupBy: {
            args: Prisma.EquipmentItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EquipmentItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentItemCountArgs<ExtArgs>,
            result: $Utils.Optional<EquipmentItemCountAggregateOutputType> | number
          }
        }
      }
      EquipmentAssignment: {
        payload: EquipmentAssignmentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.EquipmentAssignmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentAssignmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentAssignmentPayload>
          }
          findFirst: {
            args: Prisma.EquipmentAssignmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentAssignmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentAssignmentPayload>
          }
          findMany: {
            args: Prisma.EquipmentAssignmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentAssignmentPayload>[]
          }
          create: {
            args: Prisma.EquipmentAssignmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentAssignmentPayload>
          }
          createMany: {
            args: Prisma.EquipmentAssignmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EquipmentAssignmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentAssignmentPayload>
          }
          update: {
            args: Prisma.EquipmentAssignmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentAssignmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentAssignmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EquipmentAssignmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EquipmentAssignmentPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAssignmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEquipmentAssignment>
          }
          groupBy: {
            args: Prisma.EquipmentAssignmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EquipmentAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentAssignmentCountArgs<ExtArgs>,
            result: $Utils.Optional<EquipmentAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: PostPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>,
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: CommentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      CommunityEvent: {
        payload: CommunityEventPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CommunityEventFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommunityEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityEventFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommunityEventPayload>
          }
          findFirst: {
            args: Prisma.CommunityEventFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommunityEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityEventFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommunityEventPayload>
          }
          findMany: {
            args: Prisma.CommunityEventFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommunityEventPayload>[]
          }
          create: {
            args: Prisma.CommunityEventCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommunityEventPayload>
          }
          createMany: {
            args: Prisma.CommunityEventCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommunityEventDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommunityEventPayload>
          }
          update: {
            args: Prisma.CommunityEventUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommunityEventPayload>
          }
          deleteMany: {
            args: Prisma.CommunityEventDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityEventUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommunityEventUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommunityEventPayload>
          }
          aggregate: {
            args: Prisma.CommunityEventAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommunityEvent>
          }
          groupBy: {
            args: Prisma.CommunityEventGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommunityEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityEventCountArgs<ExtArgs>,
            result: $Utils.Optional<CommunityEventCountAggregateOutputType> | number
          }
        }
      }
      SocialPost: {
        payload: SocialPostPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.SocialPostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialPostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialPostPayload>
          }
          findFirst: {
            args: Prisma.SocialPostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialPostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialPostPayload>
          }
          findMany: {
            args: Prisma.SocialPostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialPostPayload>[]
          }
          create: {
            args: Prisma.SocialPostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialPostPayload>
          }
          createMany: {
            args: Prisma.SocialPostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SocialPostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialPostPayload>
          }
          update: {
            args: Prisma.SocialPostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialPostPayload>
          }
          deleteMany: {
            args: Prisma.SocialPostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SocialPostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SocialPostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialPostPayload>
          }
          aggregate: {
            args: Prisma.SocialPostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSocialPost>
          }
          groupBy: {
            args: Prisma.SocialPostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SocialPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialPostCountArgs<ExtArgs>,
            result: $Utils.Optional<SocialPostCountAggregateOutputType> | number
          }
        }
      }
      PostComment: {
        payload: PostCommentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PostCommentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostCommentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostCommentPayload>
          }
          findFirst: {
            args: Prisma.PostCommentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostCommentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostCommentPayload>
          }
          findMany: {
            args: Prisma.PostCommentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostCommentPayload>[]
          }
          create: {
            args: Prisma.PostCommentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostCommentPayload>
          }
          createMany: {
            args: Prisma.PostCommentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PostCommentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostCommentPayload>
          }
          update: {
            args: Prisma.PostCommentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostCommentPayload>
          }
          deleteMany: {
            args: Prisma.PostCommentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PostCommentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PostCommentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PostCommentPayload>
          }
          aggregate: {
            args: Prisma.PostCommentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePostComment>
          }
          groupBy: {
            args: Prisma.PostCommentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PostCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCommentCountArgs<ExtArgs>,
            result: $Utils.Optional<PostCommentCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: EventPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>,
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      EventRegistration: {
        payload: EventRegistrationPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.EventRegistrationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventRegistrationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventRegistrationPayload>
          }
          findFirst: {
            args: Prisma.EventRegistrationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventRegistrationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventRegistrationPayload>
          }
          findMany: {
            args: Prisma.EventRegistrationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventRegistrationPayload>[]
          }
          create: {
            args: Prisma.EventRegistrationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventRegistrationPayload>
          }
          createMany: {
            args: Prisma.EventRegistrationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EventRegistrationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventRegistrationPayload>
          }
          update: {
            args: Prisma.EventRegistrationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.EventRegistrationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EventRegistrationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EventRegistrationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EventRegistrationPayload>
          }
          aggregate: {
            args: Prisma.EventRegistrationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEventRegistration>
          }
          groupBy: {
            args: Prisma.EventRegistrationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EventRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventRegistrationCountArgs<ExtArgs>,
            result: $Utils.Optional<EventRegistrationCountAggregateOutputType> | number
          }
        }
      }
      ForumThread: {
        payload: ForumThreadPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ForumThreadFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumThreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumThreadFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumThreadPayload>
          }
          findFirst: {
            args: Prisma.ForumThreadFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumThreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumThreadFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumThreadPayload>
          }
          findMany: {
            args: Prisma.ForumThreadFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumThreadPayload>[]
          }
          create: {
            args: Prisma.ForumThreadCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumThreadPayload>
          }
          createMany: {
            args: Prisma.ForumThreadCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ForumThreadDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumThreadPayload>
          }
          update: {
            args: Prisma.ForumThreadUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumThreadPayload>
          }
          deleteMany: {
            args: Prisma.ForumThreadDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ForumThreadUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ForumThreadUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumThreadPayload>
          }
          aggregate: {
            args: Prisma.ForumThreadAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateForumThread>
          }
          groupBy: {
            args: Prisma.ForumThreadGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ForumThreadGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumThreadCountArgs<ExtArgs>,
            result: $Utils.Optional<ForumThreadCountAggregateOutputType> | number
          }
        }
      }
      ForumPost: {
        payload: ForumPostPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ForumPostFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumPostFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumPostPayload>
          }
          findFirst: {
            args: Prisma.ForumPostFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumPostFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumPostPayload>
          }
          findMany: {
            args: Prisma.ForumPostFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumPostPayload>[]
          }
          create: {
            args: Prisma.ForumPostCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumPostPayload>
          }
          createMany: {
            args: Prisma.ForumPostCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ForumPostDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumPostPayload>
          }
          update: {
            args: Prisma.ForumPostUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumPostPayload>
          }
          deleteMany: {
            args: Prisma.ForumPostDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ForumPostUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ForumPostUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ForumPostPayload>
          }
          aggregate: {
            args: Prisma.ForumPostAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateForumPost>
          }
          groupBy: {
            args: Prisma.ForumPostGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ForumPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumPostCountArgs<ExtArgs>,
            result: $Utils.Optional<ForumPostCountAggregateOutputType> | number
          }
        }
      }
      BenefitClaim: {
        payload: BenefitClaimPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.BenefitClaimFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BenefitClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BenefitClaimFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BenefitClaimPayload>
          }
          findFirst: {
            args: Prisma.BenefitClaimFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BenefitClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BenefitClaimFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BenefitClaimPayload>
          }
          findMany: {
            args: Prisma.BenefitClaimFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BenefitClaimPayload>[]
          }
          create: {
            args: Prisma.BenefitClaimCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BenefitClaimPayload>
          }
          createMany: {
            args: Prisma.BenefitClaimCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BenefitClaimDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BenefitClaimPayload>
          }
          update: {
            args: Prisma.BenefitClaimUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BenefitClaimPayload>
          }
          deleteMany: {
            args: Prisma.BenefitClaimDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BenefitClaimUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BenefitClaimUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BenefitClaimPayload>
          }
          aggregate: {
            args: Prisma.BenefitClaimAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBenefitClaim>
          }
          groupBy: {
            args: Prisma.BenefitClaimGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BenefitClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.BenefitClaimCountArgs<ExtArgs>,
            result: $Utils.Optional<BenefitClaimCountAggregateOutputType> | number
          }
        }
      }
      PayrollRecord: {
        payload: PayrollRecordPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PayrollRecordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PayrollRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollRecordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PayrollRecordPayload>
          }
          findFirst: {
            args: Prisma.PayrollRecordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PayrollRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollRecordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PayrollRecordPayload>
          }
          findMany: {
            args: Prisma.PayrollRecordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PayrollRecordPayload>[]
          }
          create: {
            args: Prisma.PayrollRecordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PayrollRecordPayload>
          }
          createMany: {
            args: Prisma.PayrollRecordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PayrollRecordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PayrollRecordPayload>
          }
          update: {
            args: Prisma.PayrollRecordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PayrollRecordPayload>
          }
          deleteMany: {
            args: Prisma.PayrollRecordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollRecordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PayrollRecordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PayrollRecordPayload>
          }
          aggregate: {
            args: Prisma.PayrollRecordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePayrollRecord>
          }
          groupBy: {
            args: Prisma.PayrollRecordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PayrollRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollRecordCountArgs<ExtArgs>,
            result: $Utils.Optional<PayrollRecordCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: BookingPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>,
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      TwoFactorAuth: {
        payload: TwoFactorAuthPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TwoFactorAuthFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TwoFactorAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwoFactorAuthFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TwoFactorAuthPayload>
          }
          findFirst: {
            args: Prisma.TwoFactorAuthFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TwoFactorAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwoFactorAuthFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TwoFactorAuthPayload>
          }
          findMany: {
            args: Prisma.TwoFactorAuthFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TwoFactorAuthPayload>[]
          }
          create: {
            args: Prisma.TwoFactorAuthCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TwoFactorAuthPayload>
          }
          createMany: {
            args: Prisma.TwoFactorAuthCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TwoFactorAuthDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TwoFactorAuthPayload>
          }
          update: {
            args: Prisma.TwoFactorAuthUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TwoFactorAuthPayload>
          }
          deleteMany: {
            args: Prisma.TwoFactorAuthDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TwoFactorAuthUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TwoFactorAuthUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TwoFactorAuthPayload>
          }
          aggregate: {
            args: Prisma.TwoFactorAuthAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTwoFactorAuth>
          }
          groupBy: {
            args: Prisma.TwoFactorAuthGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TwoFactorAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwoFactorAuthCountArgs<ExtArgs>,
            result: $Utils.Optional<TwoFactorAuthCountAggregateOutputType> | number
          }
        }
      }
      WebAuthnCredential: {
        payload: WebAuthnCredentialPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.WebAuthnCredentialFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WebAuthnCredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebAuthnCredentialFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WebAuthnCredentialPayload>
          }
          findFirst: {
            args: Prisma.WebAuthnCredentialFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WebAuthnCredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebAuthnCredentialFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WebAuthnCredentialPayload>
          }
          findMany: {
            args: Prisma.WebAuthnCredentialFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WebAuthnCredentialPayload>[]
          }
          create: {
            args: Prisma.WebAuthnCredentialCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WebAuthnCredentialPayload>
          }
          createMany: {
            args: Prisma.WebAuthnCredentialCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WebAuthnCredentialDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WebAuthnCredentialPayload>
          }
          update: {
            args: Prisma.WebAuthnCredentialUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WebAuthnCredentialPayload>
          }
          deleteMany: {
            args: Prisma.WebAuthnCredentialDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WebAuthnCredentialUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WebAuthnCredentialUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WebAuthnCredentialPayload>
          }
          aggregate: {
            args: Prisma.WebAuthnCredentialAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWebAuthnCredential>
          }
          groupBy: {
            args: Prisma.WebAuthnCredentialGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WebAuthnCredentialGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebAuthnCredentialCountArgs<ExtArgs>,
            result: $Utils.Optional<WebAuthnCredentialCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    transactions: number
    subscriptions: number
    referrals: number
    analyticsEvents: number
    paymentTransactions: number
    trainingProgress: number
    assignments: number
    socialPosts: number
    postComments: number
    eventRegistrations: number
    forumThreads: number
    forumPosts: number
    benefitClaims: number
    payrollRecords: number
    bookings: number
    posts: number
    comments: number
    webAuthnCredentials: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
    referrals?: boolean | UserCountOutputTypeCountReferralsArgs
    analyticsEvents?: boolean | UserCountOutputTypeCountAnalyticsEventsArgs
    paymentTransactions?: boolean | UserCountOutputTypeCountPaymentTransactionsArgs
    trainingProgress?: boolean | UserCountOutputTypeCountTrainingProgressArgs
    assignments?: boolean | UserCountOutputTypeCountAssignmentsArgs
    socialPosts?: boolean | UserCountOutputTypeCountSocialPostsArgs
    postComments?: boolean | UserCountOutputTypeCountPostCommentsArgs
    eventRegistrations?: boolean | UserCountOutputTypeCountEventRegistrationsArgs
    forumThreads?: boolean | UserCountOutputTypeCountForumThreadsArgs
    forumPosts?: boolean | UserCountOutputTypeCountForumPostsArgs
    benefitClaims?: boolean | UserCountOutputTypeCountBenefitClaimsArgs
    payrollRecords?: boolean | UserCountOutputTypeCountPayrollRecordsArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    webAuthnCredentials?: boolean | UserCountOutputTypeCountWebAuthnCredentialsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LoyaltyTransactionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnalyticsEventsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AnalyticsEventWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentTransactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrainingProgressArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TrainingProgressWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EquipmentAssignmentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSocialPostsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SocialPostWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostCommentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PostCommentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventRegistrationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EventRegistrationWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountForumThreadsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ForumThreadWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountForumPostsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBenefitClaimsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BenefitClaimWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPayrollRecordsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PayrollRecordWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWebAuthnCredentialsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WebAuthnCredentialWhereInput
  }



  /**
   * Count Type ProviderCountOutputType
   */


  export type ProviderCountOutputType = {
    services: number
    businesses: number
  }

  export type ProviderCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    services?: boolean | ProviderCountOutputTypeCountServicesArgs
    businesses?: boolean | ProviderCountOutputTypeCountBusinessesArgs
  }

  // Custom InputTypes

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCountOutputType
     */
    select?: ProviderCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountBusinessesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
  }



  /**
   * Count Type ServiceCountOutputType
   */


  export type ServiceCountOutputType = {
    paymentTransactions: number
    bookings: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    paymentTransactions?: boolean | ServiceCountOutputTypeCountPaymentTransactionsArgs
    bookings?: boolean | ServiceCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountPaymentTransactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
  }


  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }



  /**
   * Count Type BusinessCountOutputType
   */


  export type BusinessCountOutputType = {
    hours: number
    staff: number
  }

  export type BusinessCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    hours?: boolean | BusinessCountOutputTypeCountHoursArgs
    staff?: boolean | BusinessCountOutputTypeCountStaffArgs
  }

  // Custom InputTypes

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCountOutputType
     */
    select?: BusinessCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountHoursArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BusinessHourWhereInput
  }


  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
  }



  /**
   * Count Type StaffCountOutputType
   */


  export type StaffCountOutputType = {
    schedules: number
  }

  export type StaffCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    schedules?: boolean | StaffCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffCountOutputType
     */
    select?: StaffCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StaffScheduleWhereInput
  }



  /**
   * Count Type StaffScheduleCountOutputType
   */


  export type StaffScheduleCountOutputType = {
    attendanceRecords: number
  }

  export type StaffScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    attendanceRecords?: boolean | StaffScheduleCountOutputTypeCountAttendanceRecordsArgs
  }

  // Custom InputTypes

  /**
   * StaffScheduleCountOutputType without action
   */
  export type StaffScheduleCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffScheduleCountOutputType
     */
    select?: StaffScheduleCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StaffScheduleCountOutputType without action
   */
  export type StaffScheduleCountOutputTypeCountAttendanceRecordsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }



  /**
   * Count Type TrainingModuleCountOutputType
   */


  export type TrainingModuleCountOutputType = {
    trainingProgress: number
  }

  export type TrainingModuleCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    trainingProgress?: boolean | TrainingModuleCountOutputTypeCountTrainingProgressArgs
  }

  // Custom InputTypes

  /**
   * TrainingModuleCountOutputType without action
   */
  export type TrainingModuleCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingModuleCountOutputType
     */
    select?: TrainingModuleCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TrainingModuleCountOutputType without action
   */
  export type TrainingModuleCountOutputTypeCountTrainingProgressArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TrainingProgressWhereInput
  }



  /**
   * Count Type LoyaltyTierCountOutputType
   */


  export type LoyaltyTierCountOutputType = {
    transactions: number
  }

  export type LoyaltyTierCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    transactions?: boolean | LoyaltyTierCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes

  /**
   * LoyaltyTierCountOutputType without action
   */
  export type LoyaltyTierCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTierCountOutputType
     */
    select?: LoyaltyTierCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LoyaltyTierCountOutputType without action
   */
  export type LoyaltyTierCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LoyaltyTransactionWhereInput
  }



  /**
   * Count Type FormDefinitionCountOutputType
   */


  export type FormDefinitionCountOutputType = {
    submissions: number
  }

  export type FormDefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    submissions?: boolean | FormDefinitionCountOutputTypeCountSubmissionsArgs
  }

  // Custom InputTypes

  /**
   * FormDefinitionCountOutputType without action
   */
  export type FormDefinitionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormDefinitionCountOutputType
     */
    select?: FormDefinitionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * FormDefinitionCountOutputType without action
   */
  export type FormDefinitionCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
  }



  /**
   * Count Type FormSubmissionCountOutputType
   */


  export type FormSubmissionCountOutputType = {
    documents: number
  }

  export type FormSubmissionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    documents?: boolean | FormSubmissionCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes

  /**
   * FormSubmissionCountOutputType without action
   */
  export type FormSubmissionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmissionCountOutputType
     */
    select?: FormSubmissionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * FormSubmissionCountOutputType without action
   */
  export type FormSubmissionCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }



  /**
   * Count Type EquipmentItemCountOutputType
   */


  export type EquipmentItemCountOutputType = {
    assignments: number
  }

  export type EquipmentItemCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    assignments?: boolean | EquipmentItemCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes

  /**
   * EquipmentItemCountOutputType without action
   */
  export type EquipmentItemCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentItemCountOutputType
     */
    select?: EquipmentItemCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EquipmentItemCountOutputType without action
   */
  export type EquipmentItemCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EquipmentAssignmentWhereInput
  }



  /**
   * Count Type PostCountOutputType
   */


  export type PostCountOutputType = {
    comments: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }



  /**
   * Count Type SocialPostCountOutputType
   */


  export type SocialPostCountOutputType = {
    comments: number
  }

  export type SocialPostCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    comments?: boolean | SocialPostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes

  /**
   * SocialPostCountOutputType without action
   */
  export type SocialPostCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPostCountOutputType
     */
    select?: SocialPostCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SocialPostCountOutputType without action
   */
  export type SocialPostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PostCommentWhereInput
  }



  /**
   * Count Type EventCountOutputType
   */


  export type EventCountOutputType = {
    registrations: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    registrations?: boolean | EventCountOutputTypeCountRegistrationsArgs
  }

  // Custom InputTypes

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountRegistrationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EventRegistrationWhereInput
  }



  /**
   * Count Type ForumThreadCountOutputType
   */


  export type ForumThreadCountOutputType = {
    posts: number
  }

  export type ForumThreadCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    posts?: boolean | ForumThreadCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes

  /**
   * ForumThreadCountOutputType without action
   */
  export type ForumThreadCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumThreadCountOutputType
     */
    select?: ForumThreadCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ForumThreadCountOutputType without action
   */
  export type ForumThreadCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    auth0Id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    role: Role | null
    createdAt: Date | null
    updatedAt: Date | null
    referralCode: string | null
    referredById: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    auth0Id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    role: Role | null
    createdAt: Date | null
    updatedAt: Date | null
    referralCode: string | null
    referredById: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    auth0Id: number
    email: number
    name: number
    avatar: number
    role: number
    createdAt: number
    updatedAt: number
    pushTokens: number
    notificationSettings: number
    referralCode: number
    referredById: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    auth0Id?: true
    email?: true
    name?: true
    avatar?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referredById?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    auth0Id?: true
    email?: true
    name?: true
    avatar?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referredById?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    auth0Id?: true
    email?: true
    name?: true
    avatar?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    pushTokens?: true
    notificationSettings?: true
    referralCode?: true
    referredById?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    auth0Id: string | null
    email: string
    name: string | null
    avatar: string | null
    role: Role
    createdAt: Date
    updatedAt: Date
    pushTokens: JsonValue
    notificationSettings: JsonValue
    referralCode: string
    referredById: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auth0Id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pushTokens?: boolean
    notificationSettings?: boolean
    referralCode?: boolean
    referredById?: boolean
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    referredBy?: boolean | UserArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    analyticsEvents?: boolean | User$analyticsEventsArgs<ExtArgs>
    paymentTransactions?: boolean | User$paymentTransactionsArgs<ExtArgs>
    trainingProgress?: boolean | User$trainingProgressArgs<ExtArgs>
    googleCalendarToken?: boolean | GoogleCalendarTokenArgs<ExtArgs>
    outlookCalendarToken?: boolean | OutlookCalendarTokenArgs<ExtArgs>
    assignments?: boolean | User$assignmentsArgs<ExtArgs>
    socialPosts?: boolean | User$socialPostsArgs<ExtArgs>
    postComments?: boolean | User$postCommentsArgs<ExtArgs>
    eventRegistrations?: boolean | User$eventRegistrationsArgs<ExtArgs>
    forumThreads?: boolean | User$forumThreadsArgs<ExtArgs>
    forumPosts?: boolean | User$forumPostsArgs<ExtArgs>
    benefitClaims?: boolean | User$benefitClaimsArgs<ExtArgs>
    payrollRecords?: boolean | User$payrollRecordsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    twoFactorAuth?: boolean | TwoFactorAuthArgs<ExtArgs>
    webAuthnCredentials?: boolean | User$webAuthnCredentialsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    auth0Id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pushTokens?: boolean
    notificationSettings?: boolean
    referralCode?: boolean
    referredById?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    referredBy?: boolean | UserArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    analyticsEvents?: boolean | User$analyticsEventsArgs<ExtArgs>
    paymentTransactions?: boolean | User$paymentTransactionsArgs<ExtArgs>
    trainingProgress?: boolean | User$trainingProgressArgs<ExtArgs>
    googleCalendarToken?: boolean | GoogleCalendarTokenArgs<ExtArgs>
    outlookCalendarToken?: boolean | OutlookCalendarTokenArgs<ExtArgs>
    assignments?: boolean | User$assignmentsArgs<ExtArgs>
    socialPosts?: boolean | User$socialPostsArgs<ExtArgs>
    postComments?: boolean | User$postCommentsArgs<ExtArgs>
    eventRegistrations?: boolean | User$eventRegistrationsArgs<ExtArgs>
    forumThreads?: boolean | User$forumThreadsArgs<ExtArgs>
    forumPosts?: boolean | User$forumPostsArgs<ExtArgs>
    benefitClaims?: boolean | User$benefitClaimsArgs<ExtArgs>
    payrollRecords?: boolean | User$payrollRecordsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    twoFactorAuth?: boolean | TwoFactorAuthArgs<ExtArgs>
    webAuthnCredentials?: boolean | User$webAuthnCredentialsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type UserGetPayload<S extends boolean | null | undefined | UserArgs> = $Types.GetResult<UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LoyaltyTransactionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    referredBy<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    referrals<T extends User$referralsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>| Null>;

    analyticsEvents<T extends User$analyticsEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$analyticsEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AnalyticsEventPayload<ExtArgs>, T, 'findMany', never>| Null>;

    paymentTransactions<T extends User$paymentTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PaymentTransactionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    trainingProgress<T extends User$trainingProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$trainingProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TrainingProgressPayload<ExtArgs>, T, 'findMany', never>| Null>;

    googleCalendarToken<T extends GoogleCalendarTokenArgs<ExtArgs> = {}>(args?: Subset<T, GoogleCalendarTokenArgs<ExtArgs>>): Prisma__GoogleCalendarTokenClient<$Types.GetResult<GoogleCalendarTokenPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    outlookCalendarToken<T extends OutlookCalendarTokenArgs<ExtArgs> = {}>(args?: Subset<T, OutlookCalendarTokenArgs<ExtArgs>>): Prisma__OutlookCalendarTokenClient<$Types.GetResult<OutlookCalendarTokenPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    assignments<T extends User$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EquipmentAssignmentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    socialPosts<T extends User$socialPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$socialPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<SocialPostPayload<ExtArgs>, T, 'findMany', never>| Null>;

    postComments<T extends User$postCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$postCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PostCommentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    eventRegistrations<T extends User$eventRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EventRegistrationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    forumThreads<T extends User$forumThreadsArgs<ExtArgs> = {}>(args?: Subset<T, User$forumThreadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ForumThreadPayload<ExtArgs>, T, 'findMany', never>| Null>;

    forumPosts<T extends User$forumPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$forumPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ForumPostPayload<ExtArgs>, T, 'findMany', never>| Null>;

    benefitClaims<T extends User$benefitClaimsArgs<ExtArgs> = {}>(args?: Subset<T, User$benefitClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BenefitClaimPayload<ExtArgs>, T, 'findMany', never>| Null>;

    payrollRecords<T extends User$payrollRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$payrollRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PayrollRecordPayload<ExtArgs>, T, 'findMany', never>| Null>;

    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findMany', never>| Null>;

    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PostPayload<ExtArgs>, T, 'findMany', never>| Null>;

    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    twoFactorAuth<T extends TwoFactorAuthArgs<ExtArgs> = {}>(args?: Subset<T, TwoFactorAuthArgs<ExtArgs>>): Prisma__TwoFactorAuthClient<$Types.GetResult<TwoFactorAuthPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    webAuthnCredentials<T extends User$webAuthnCredentialsArgs<ExtArgs> = {}>(args?: Subset<T, User$webAuthnCredentialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<WebAuthnCredentialPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    where?: LoyaltyTransactionWhereInput
    orderBy?: Enumerable<LoyaltyTransactionOrderByWithRelationInput>
    cursor?: LoyaltyTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LoyaltyTransactionScalarFieldEnum>
  }


  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }


  /**
   * User.referrals
   */
  export type User$referralsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User.analyticsEvents
   */
  export type User$analyticsEventsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    where?: AnalyticsEventWhereInput
    orderBy?: Enumerable<AnalyticsEventOrderByWithRelationInput>
    cursor?: AnalyticsEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AnalyticsEventScalarFieldEnum>
  }


  /**
   * User.paymentTransactions
   */
  export type User$paymentTransactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    where?: PaymentTransactionWhereInput
    orderBy?: Enumerable<PaymentTransactionOrderByWithRelationInput>
    cursor?: PaymentTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PaymentTransactionScalarFieldEnum>
  }


  /**
   * User.trainingProgress
   */
  export type User$trainingProgressArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgress
     */
    select?: TrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingProgressInclude<ExtArgs> | null
    where?: TrainingProgressWhereInput
    orderBy?: Enumerable<TrainingProgressOrderByWithRelationInput>
    cursor?: TrainingProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrainingProgressScalarFieldEnum>
  }


  /**
   * User.assignments
   */
  export type User$assignmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAssignment
     */
    select?: EquipmentAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentAssignmentInclude<ExtArgs> | null
    where?: EquipmentAssignmentWhereInput
    orderBy?: Enumerable<EquipmentAssignmentOrderByWithRelationInput>
    cursor?: EquipmentAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EquipmentAssignmentScalarFieldEnum>
  }


  /**
   * User.socialPosts
   */
  export type User$socialPostsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialPostInclude<ExtArgs> | null
    where?: SocialPostWhereInput
    orderBy?: Enumerable<SocialPostOrderByWithRelationInput>
    cursor?: SocialPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SocialPostScalarFieldEnum>
  }


  /**
   * User.postComments
   */
  export type User$postCommentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostCommentInclude<ExtArgs> | null
    where?: PostCommentWhereInput
    orderBy?: Enumerable<PostCommentOrderByWithRelationInput>
    cursor?: PostCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostCommentScalarFieldEnum>
  }


  /**
   * User.eventRegistrations
   */
  export type User$eventRegistrationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    where?: EventRegistrationWhereInput
    orderBy?: Enumerable<EventRegistrationOrderByWithRelationInput>
    cursor?: EventRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EventRegistrationScalarFieldEnum>
  }


  /**
   * User.forumThreads
   */
  export type User$forumThreadsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumThread
     */
    select?: ForumThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumThreadInclude<ExtArgs> | null
    where?: ForumThreadWhereInput
    orderBy?: Enumerable<ForumThreadOrderByWithRelationInput>
    cursor?: ForumThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ForumThreadScalarFieldEnum>
  }


  /**
   * User.forumPosts
   */
  export type User$forumPostsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumPostInclude<ExtArgs> | null
    where?: ForumPostWhereInput
    orderBy?: Enumerable<ForumPostOrderByWithRelationInput>
    cursor?: ForumPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ForumPostScalarFieldEnum>
  }


  /**
   * User.benefitClaims
   */
  export type User$benefitClaimsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitClaim
     */
    select?: BenefitClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BenefitClaimInclude<ExtArgs> | null
    where?: BenefitClaimWhereInput
    orderBy?: Enumerable<BenefitClaimOrderByWithRelationInput>
    cursor?: BenefitClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BenefitClaimScalarFieldEnum>
  }


  /**
   * User.payrollRecords
   */
  export type User$payrollRecordsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRecord
     */
    select?: PayrollRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayrollRecordInclude<ExtArgs> | null
    where?: PayrollRecordWhereInput
    orderBy?: Enumerable<PayrollRecordOrderByWithRelationInput>
    cursor?: PayrollRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PayrollRecordScalarFieldEnum>
  }


  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: Enumerable<BookingOrderByWithRelationInput>
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BookingScalarFieldEnum>
  }


  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * User.webAuthnCredentials
   */
  export type User$webAuthnCredentialsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    where?: WebAuthnCredentialWhereInput
    orderBy?: Enumerable<WebAuthnCredentialOrderByWithRelationInput>
    cursor?: WebAuthnCredentialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WebAuthnCredentialScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Provider
   */


  export type AggregateProvider = {
    _count: ProviderCountAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  export type ProviderMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    businessName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProviderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    businessName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProviderCountAggregateOutputType = {
    id: number
    name: number
    description: number
    businessName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProviderMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    businessName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProviderMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    businessName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProviderCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    businessName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProviderAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provider to aggregate.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: Enumerable<ProviderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Providers
    **/
    _count?: true | ProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderMaxAggregateInputType
  }

  export type GetProviderAggregateType<T extends ProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider[P]>
      : GetScalarType<T[P], AggregateProvider[P]>
  }




  export type ProviderGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProviderWhereInput
    orderBy?: Enumerable<ProviderOrderByWithAggregationInput>
    by: ProviderScalarFieldEnum[]
    having?: ProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderCountAggregateInputType | true
    _min?: ProviderMinAggregateInputType
    _max?: ProviderMaxAggregateInputType
  }


  export type ProviderGroupByOutputType = {
    id: string
    name: string
    description: string | null
    businessName: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProviderCountAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  type GetProviderGroupByPayload<T extends ProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderGroupByOutputType[P]>
        }
      >
    >


  export type ProviderSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    businessName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    services?: boolean | Provider$servicesArgs<ExtArgs>
    businesses?: boolean | Provider$businessesArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    businessName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProviderInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    services?: boolean | Provider$servicesArgs<ExtArgs>
    businesses?: boolean | Provider$businessesArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeArgs<ExtArgs>
  }


  type ProviderGetPayload<S extends boolean | null | undefined | ProviderArgs> = $Types.GetResult<ProviderPayload, S>

  type ProviderCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProviderFindManyArgs, 'select' | 'include'> & {
      select?: ProviderCountAggregateInputType | true
    }

  export interface ProviderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Provider'], meta: { name: 'Provider' } }
    /**
     * Find zero or one Provider that matches the filter.
     * @param {ProviderFindUniqueArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProviderFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProviderFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Provider'> extends True ? Prisma__ProviderClient<$Types.GetResult<ProviderPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProviderClient<$Types.GetResult<ProviderPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Provider that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProviderFindUniqueOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProviderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Types.GetResult<ProviderPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Provider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProviderFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProviderFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Provider'> extends True ? Prisma__ProviderClient<$Types.GetResult<ProviderPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProviderClient<$Types.GetResult<ProviderPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Provider that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProviderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Types.GetResult<ProviderPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.provider.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.provider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerWithIdOnly = await prisma.provider.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProviderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProviderPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Provider.
     * @param {ProviderCreateArgs} args - Arguments to create a Provider.
     * @example
     * // Create one Provider
     * const Provider = await prisma.provider.create({
     *   data: {
     *     // ... data to create a Provider
     *   }
     * })
     * 
    **/
    create<T extends ProviderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderCreateArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Types.GetResult<ProviderPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Providers.
     *     @param {ProviderCreateManyArgs} args - Arguments to create many Providers.
     *     @example
     *     // Create many Providers
     *     const provider = await prisma.provider.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProviderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Provider.
     * @param {ProviderDeleteArgs} args - Arguments to delete one Provider.
     * @example
     * // Delete one Provider
     * const Provider = await prisma.provider.delete({
     *   where: {
     *     // ... filter to delete one Provider
     *   }
     * })
     * 
    **/
    delete<T extends ProviderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderDeleteArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Types.GetResult<ProviderPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Provider.
     * @param {ProviderUpdateArgs} args - Arguments to update one Provider.
     * @example
     * // Update one Provider
     * const provider = await prisma.provider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProviderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderUpdateArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Types.GetResult<ProviderPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Providers.
     * @param {ProviderDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.provider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProviderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProviderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProviderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Provider.
     * @param {ProviderUpsertArgs} args - Arguments to update or create a Provider.
     * @example
     * // Update or create a Provider
     * const provider = await prisma.provider.upsert({
     *   create: {
     *     // ... data to create a Provider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider we want to update
     *   }
     * })
    **/
    upsert<T extends ProviderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProviderUpsertArgs<ExtArgs>>
    ): Prisma__ProviderClient<$Types.GetResult<ProviderPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.provider.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends ProviderCountArgs>(
      args?: Subset<T, ProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderAggregateArgs>(args: Subset<T, ProviderAggregateArgs>): Prisma.PrismaPromise<GetProviderAggregateType<T>>

    /**
     * Group by Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderGroupByArgs['orderBy'] }
        : { orderBy?: ProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Provider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProviderClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    services<T extends Provider$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Provider$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findMany', never>| Null>;

    businesses<T extends Provider$businessesArgs<ExtArgs> = {}>(args?: Subset<T, Provider$businessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BusinessPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Provider base type for findUnique actions
   */
  export type ProviderFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findUnique
   */
  export interface ProviderFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProviderFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Provider findUniqueOrThrow
   */
  export type ProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }


  /**
   * Provider base type for findFirst actions
   */
  export type ProviderFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: Enumerable<ProviderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: Enumerable<ProviderScalarFieldEnum>
  }

  /**
   * Provider findFirst
   */
  export interface ProviderFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProviderFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Provider findFirstOrThrow
   */
  export type ProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: Enumerable<ProviderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: Enumerable<ProviderScalarFieldEnum>
  }


  /**
   * Provider findMany
   */
  export type ProviderFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: Enumerable<ProviderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    distinct?: Enumerable<ProviderScalarFieldEnum>
  }


  /**
   * Provider create
   */
  export type ProviderCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a Provider.
     */
    data: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
  }


  /**
   * Provider createMany
   */
  export type ProviderCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Providers.
     */
    data: Enumerable<ProviderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Provider update
   */
  export type ProviderUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a Provider.
     */
    data: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
    /**
     * Choose, which Provider to update.
     */
    where: ProviderWhereUniqueInput
  }


  /**
   * Provider updateMany
   */
  export type ProviderUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
  }


  /**
   * Provider upsert
   */
  export type ProviderUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the Provider to update in case it exists.
     */
    where: ProviderWhereUniqueInput
    /**
     * In case the Provider found by the `where` argument doesn't exist, create a new Provider with this data.
     */
    create: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
    /**
     * In case the Provider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
  }


  /**
   * Provider delete
   */
  export type ProviderDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter which Provider to delete.
     */
    where: ProviderWhereUniqueInput
  }


  /**
   * Provider deleteMany
   */
  export type ProviderDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Providers to delete
     */
    where?: ProviderWhereInput
  }


  /**
   * Provider.services
   */
  export type Provider$servicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Provider.businesses
   */
  export type Provider$businessesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
    orderBy?: Enumerable<BusinessOrderByWithRelationInput>
    cursor?: BusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BusinessScalarFieldEnum>
  }


  /**
   * Provider without action
   */
  export type ProviderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude<ExtArgs> | null
  }



  /**
   * Model Service
   */


  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type ServiceSumAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    name: string | null
    price: number | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    name: string | null
    price: number | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    providerId: number
    name: number
    price: number
    duration: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type ServiceSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    price?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    price?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    price?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: Enumerable<ServiceOrderByWithAggregationInput>
    by: ServiceScalarFieldEnum[]
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }


  export type ServiceGroupByOutputType = {
    id: string
    providerId: string
    name: string
    price: number
    duration: number
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderArgs<ExtArgs>
    paymentTransactions?: boolean | Service$paymentTransactionsArgs<ExtArgs>
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    providerId?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderArgs<ExtArgs>
    paymentTransactions?: boolean | Service$paymentTransactionsArgs<ExtArgs>
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeArgs<ExtArgs>
  }


  type ServiceGetPayload<S extends boolean | null | undefined | ServiceArgs> = $Types.GetResult<ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Service'> extends True ? Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Service'> extends True ? Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
    **/
    create<T extends ServiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Services.
     *     @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     *     @example
     *     // Create many Services
     *     const service = await prisma.service.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
    **/
    delete<T extends ServiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    provider<T extends ProviderArgs<ExtArgs> = {}>(args?: Subset<T, ProviderArgs<ExtArgs>>): Prisma__ProviderClient<$Types.GetResult<ProviderPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    paymentTransactions<T extends Service$paymentTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Service$paymentTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PaymentTransactionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    bookings<T extends Service$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Service$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Service base type for findUnique actions
   */
  export type ServiceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUnique
   */
  export interface ServiceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service base type for findFirst actions
   */
  export type ServiceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }

  /**
   * Service findFirst
   */
  export interface ServiceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }


  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: Enumerable<ServiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }


  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }


  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }


  /**
   * Service.paymentTransactions
   */
  export type Service$paymentTransactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    where?: PaymentTransactionWhereInput
    orderBy?: Enumerable<PaymentTransactionOrderByWithRelationInput>
    cursor?: PaymentTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PaymentTransactionScalarFieldEnum>
  }


  /**
   * Service.bookings
   */
  export type Service$bookingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: Enumerable<BookingOrderByWithRelationInput>
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BookingScalarFieldEnum>
  }


  /**
   * Service without action
   */
  export type ServiceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
  }



  /**
   * Model Business
   */


  export type AggregateBusiness = {
    _count: BusinessCountAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  export type BusinessMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    name: string | null
    address: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    name: string | null
    address: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessCountAggregateOutputType = {
    id: number
    providerId: number
    name: number
    address: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessMinAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    address?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessMaxAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    address?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessCountAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    address?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Business to aggregate.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: Enumerable<BusinessOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Businesses
    **/
    _count?: true | BusinessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessMaxAggregateInputType
  }

  export type GetBusinessAggregateType<T extends BusinessAggregateArgs> = {
        [P in keyof T & keyof AggregateBusiness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusiness[P]>
      : GetScalarType<T[P], AggregateBusiness[P]>
  }




  export type BusinessGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
    orderBy?: Enumerable<BusinessOrderByWithAggregationInput>
    by: BusinessScalarFieldEnum[]
    having?: BusinessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessCountAggregateInputType | true
    _min?: BusinessMinAggregateInputType
    _max?: BusinessMaxAggregateInputType
  }


  export type BusinessGroupByOutputType = {
    id: string
    providerId: string
    name: string
    address: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: BusinessCountAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  type GetBusinessGroupByPayload<T extends BusinessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BusinessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessGroupByOutputType[P]>
        }
      >
    >


  export type BusinessSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    address?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderArgs<ExtArgs>
    hours?: boolean | Business$hoursArgs<ExtArgs>
    staff?: boolean | Business$staffArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectScalar = {
    id?: boolean
    providerId?: boolean
    name?: boolean
    address?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderArgs<ExtArgs>
    hours?: boolean | Business$hoursArgs<ExtArgs>
    staff?: boolean | Business$staffArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeArgs<ExtArgs>
  }


  type BusinessGetPayload<S extends boolean | null | undefined | BusinessArgs> = $Types.GetResult<BusinessPayload, S>

  type BusinessCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BusinessFindManyArgs, 'select' | 'include'> & {
      select?: BusinessCountAggregateInputType | true
    }

  export interface BusinessDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Business'], meta: { name: 'Business' } }
    /**
     * Find zero or one Business that matches the filter.
     * @param {BusinessFindUniqueArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BusinessFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BusinessFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Business'> extends True ? Prisma__BusinessClient<$Types.GetResult<BusinessPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BusinessClient<$Types.GetResult<BusinessPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Business that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BusinessFindUniqueOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BusinessFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BusinessClient<$Types.GetResult<BusinessPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Business that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BusinessFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BusinessFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Business'> extends True ? Prisma__BusinessClient<$Types.GetResult<BusinessPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BusinessClient<$Types.GetResult<BusinessPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Business that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BusinessFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BusinessClient<$Types.GetResult<BusinessPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Businesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Businesses
     * const businesses = await prisma.business.findMany()
     * 
     * // Get first 10 Businesses
     * const businesses = await prisma.business.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessWithIdOnly = await prisma.business.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BusinessFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BusinessPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Business.
     * @param {BusinessCreateArgs} args - Arguments to create a Business.
     * @example
     * // Create one Business
     * const Business = await prisma.business.create({
     *   data: {
     *     // ... data to create a Business
     *   }
     * })
     * 
    **/
    create<T extends BusinessCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessCreateArgs<ExtArgs>>
    ): Prisma__BusinessClient<$Types.GetResult<BusinessPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Businesses.
     *     @param {BusinessCreateManyArgs} args - Arguments to create many Businesses.
     *     @example
     *     // Create many Businesses
     *     const business = await prisma.business.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BusinessCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Business.
     * @param {BusinessDeleteArgs} args - Arguments to delete one Business.
     * @example
     * // Delete one Business
     * const Business = await prisma.business.delete({
     *   where: {
     *     // ... filter to delete one Business
     *   }
     * })
     * 
    **/
    delete<T extends BusinessDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessDeleteArgs<ExtArgs>>
    ): Prisma__BusinessClient<$Types.GetResult<BusinessPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Business.
     * @param {BusinessUpdateArgs} args - Arguments to update one Business.
     * @example
     * // Update one Business
     * const business = await prisma.business.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BusinessUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessUpdateArgs<ExtArgs>>
    ): Prisma__BusinessClient<$Types.GetResult<BusinessPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Businesses.
     * @param {BusinessDeleteManyArgs} args - Arguments to filter Businesses to delete.
     * @example
     * // Delete a few Businesses
     * const { count } = await prisma.business.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BusinessDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Businesses
     * const business = await prisma.business.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BusinessUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Business.
     * @param {BusinessUpsertArgs} args - Arguments to update or create a Business.
     * @example
     * // Update or create a Business
     * const business = await prisma.business.upsert({
     *   create: {
     *     // ... data to create a Business
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Business we want to update
     *   }
     * })
    **/
    upsert<T extends BusinessUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessUpsertArgs<ExtArgs>>
    ): Prisma__BusinessClient<$Types.GetResult<BusinessPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCountArgs} args - Arguments to filter Businesses to count.
     * @example
     * // Count the number of Businesses
     * const count = await prisma.business.count({
     *   where: {
     *     // ... the filter for the Businesses we want to count
     *   }
     * })
    **/
    count<T extends BusinessCountArgs>(
      args?: Subset<T, BusinessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessAggregateArgs>(args: Subset<T, BusinessAggregateArgs>): Prisma.PrismaPromise<GetBusinessAggregateType<T>>

    /**
     * Group by Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessGroupByArgs['orderBy'] }
        : { orderBy?: BusinessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Business.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BusinessClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    provider<T extends ProviderArgs<ExtArgs> = {}>(args?: Subset<T, ProviderArgs<ExtArgs>>): Prisma__ProviderClient<$Types.GetResult<ProviderPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    hours<T extends Business$hoursArgs<ExtArgs> = {}>(args?: Subset<T, Business$hoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BusinessHourPayload<ExtArgs>, T, 'findMany', never>| Null>;

    staff<T extends Business$staffArgs<ExtArgs> = {}>(args?: Subset<T, Business$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Business base type for findUnique actions
   */
  export type BusinessFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findUnique
   */
  export interface BusinessFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusinessFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Business findUniqueOrThrow
   */
  export type BusinessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }


  /**
   * Business base type for findFirst actions
   */
  export type BusinessFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: Enumerable<BusinessOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: Enumerable<BusinessScalarFieldEnum>
  }

  /**
   * Business findFirst
   */
  export interface BusinessFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusinessFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Business findFirstOrThrow
   */
  export type BusinessFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: Enumerable<BusinessOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: Enumerable<BusinessScalarFieldEnum>
  }


  /**
   * Business findMany
   */
  export type BusinessFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Businesses to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: Enumerable<BusinessOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    distinct?: Enumerable<BusinessScalarFieldEnum>
  }


  /**
   * Business create
   */
  export type BusinessCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to create a Business.
     */
    data: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
  }


  /**
   * Business createMany
   */
  export type BusinessCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Businesses.
     */
    data: Enumerable<BusinessCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Business update
   */
  export type BusinessUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to update a Business.
     */
    data: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
    /**
     * Choose, which Business to update.
     */
    where: BusinessWhereUniqueInput
  }


  /**
   * Business updateMany
   */
  export type BusinessUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Businesses.
     */
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyInput>
    /**
     * Filter which Businesses to update
     */
    where?: BusinessWhereInput
  }


  /**
   * Business upsert
   */
  export type BusinessUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The filter to search for the Business to update in case it exists.
     */
    where: BusinessWhereUniqueInput
    /**
     * In case the Business found by the `where` argument doesn't exist, create a new Business with this data.
     */
    create: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
    /**
     * In case the Business was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
  }


  /**
   * Business delete
   */
  export type BusinessDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter which Business to delete.
     */
    where: BusinessWhereUniqueInput
  }


  /**
   * Business deleteMany
   */
  export type BusinessDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Businesses to delete
     */
    where?: BusinessWhereInput
  }


  /**
   * Business.hours
   */
  export type Business$hoursArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessHour
     */
    select?: BusinessHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessHourInclude<ExtArgs> | null
    where?: BusinessHourWhereInput
    orderBy?: Enumerable<BusinessHourOrderByWithRelationInput>
    cursor?: BusinessHourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BusinessHourScalarFieldEnum>
  }


  /**
   * Business.staff
   */
  export type Business$staffArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    cursor?: StaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StaffScalarFieldEnum>
  }


  /**
   * Business without action
   */
  export type BusinessArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessInclude<ExtArgs> | null
  }



  /**
   * Model BusinessHour
   */


  export type AggregateBusinessHour = {
    _count: BusinessHourCountAggregateOutputType | null
    _avg: BusinessHourAvgAggregateOutputType | null
    _sum: BusinessHourSumAggregateOutputType | null
    _min: BusinessHourMinAggregateOutputType | null
    _max: BusinessHourMaxAggregateOutputType | null
  }

  export type BusinessHourAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type BusinessHourSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type BusinessHourMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    dayOfWeek: number | null
    openTime: string | null
    closeTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessHourMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    dayOfWeek: number | null
    openTime: string | null
    closeTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessHourCountAggregateOutputType = {
    id: number
    businessId: number
    dayOfWeek: number
    openTime: number
    closeTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessHourAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type BusinessHourSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type BusinessHourMinAggregateInputType = {
    id?: true
    businessId?: true
    dayOfWeek?: true
    openTime?: true
    closeTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessHourMaxAggregateInputType = {
    id?: true
    businessId?: true
    dayOfWeek?: true
    openTime?: true
    closeTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessHourCountAggregateInputType = {
    id?: true
    businessId?: true
    dayOfWeek?: true
    openTime?: true
    closeTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessHourAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessHour to aggregate.
     */
    where?: BusinessHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessHours to fetch.
     */
    orderBy?: Enumerable<BusinessHourOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessHours
    **/
    _count?: true | BusinessHourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessHourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessHourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessHourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessHourMaxAggregateInputType
  }

  export type GetBusinessHourAggregateType<T extends BusinessHourAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessHour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessHour[P]>
      : GetScalarType<T[P], AggregateBusinessHour[P]>
  }




  export type BusinessHourGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BusinessHourWhereInput
    orderBy?: Enumerable<BusinessHourOrderByWithAggregationInput>
    by: BusinessHourScalarFieldEnum[]
    having?: BusinessHourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessHourCountAggregateInputType | true
    _avg?: BusinessHourAvgAggregateInputType
    _sum?: BusinessHourSumAggregateInputType
    _min?: BusinessHourMinAggregateInputType
    _max?: BusinessHourMaxAggregateInputType
  }


  export type BusinessHourGroupByOutputType = {
    id: string
    businessId: string
    dayOfWeek: number
    openTime: string
    closeTime: string
    createdAt: Date
    updatedAt: Date
    _count: BusinessHourCountAggregateOutputType | null
    _avg: BusinessHourAvgAggregateOutputType | null
    _sum: BusinessHourSumAggregateOutputType | null
    _min: BusinessHourMinAggregateOutputType | null
    _max: BusinessHourMaxAggregateOutputType | null
  }

  type GetBusinessHourGroupByPayload<T extends BusinessHourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BusinessHourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessHourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessHourGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessHourGroupByOutputType[P]>
        }
      >
    >


  export type BusinessHourSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessArgs<ExtArgs>
  }, ExtArgs["result"]["businessHour"]>

  export type BusinessHourSelectScalar = {
    id?: boolean
    businessId?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessHourInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessArgs<ExtArgs>
  }


  type BusinessHourGetPayload<S extends boolean | null | undefined | BusinessHourArgs> = $Types.GetResult<BusinessHourPayload, S>

  type BusinessHourCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BusinessHourFindManyArgs, 'select' | 'include'> & {
      select?: BusinessHourCountAggregateInputType | true
    }

  export interface BusinessHourDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessHour'], meta: { name: 'BusinessHour' } }
    /**
     * Find zero or one BusinessHour that matches the filter.
     * @param {BusinessHourFindUniqueArgs} args - Arguments to find a BusinessHour
     * @example
     * // Get one BusinessHour
     * const businessHour = await prisma.businessHour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BusinessHourFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BusinessHourFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BusinessHour'> extends True ? Prisma__BusinessHourClient<$Types.GetResult<BusinessHourPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BusinessHourClient<$Types.GetResult<BusinessHourPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one BusinessHour that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BusinessHourFindUniqueOrThrowArgs} args - Arguments to find a BusinessHour
     * @example
     * // Get one BusinessHour
     * const businessHour = await prisma.businessHour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BusinessHourFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessHourFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BusinessHourClient<$Types.GetResult<BusinessHourPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first BusinessHour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessHourFindFirstArgs} args - Arguments to find a BusinessHour
     * @example
     * // Get one BusinessHour
     * const businessHour = await prisma.businessHour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BusinessHourFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BusinessHourFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BusinessHour'> extends True ? Prisma__BusinessHourClient<$Types.GetResult<BusinessHourPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BusinessHourClient<$Types.GetResult<BusinessHourPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first BusinessHour that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessHourFindFirstOrThrowArgs} args - Arguments to find a BusinessHour
     * @example
     * // Get one BusinessHour
     * const businessHour = await prisma.businessHour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BusinessHourFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessHourFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BusinessHourClient<$Types.GetResult<BusinessHourPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more BusinessHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessHourFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessHours
     * const businessHours = await prisma.businessHour.findMany()
     * 
     * // Get first 10 BusinessHours
     * const businessHours = await prisma.businessHour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessHourWithIdOnly = await prisma.businessHour.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BusinessHourFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessHourFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BusinessHourPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a BusinessHour.
     * @param {BusinessHourCreateArgs} args - Arguments to create a BusinessHour.
     * @example
     * // Create one BusinessHour
     * const BusinessHour = await prisma.businessHour.create({
     *   data: {
     *     // ... data to create a BusinessHour
     *   }
     * })
     * 
    **/
    create<T extends BusinessHourCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessHourCreateArgs<ExtArgs>>
    ): Prisma__BusinessHourClient<$Types.GetResult<BusinessHourPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many BusinessHours.
     *     @param {BusinessHourCreateManyArgs} args - Arguments to create many BusinessHours.
     *     @example
     *     // Create many BusinessHours
     *     const businessHour = await prisma.businessHour.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BusinessHourCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessHourCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusinessHour.
     * @param {BusinessHourDeleteArgs} args - Arguments to delete one BusinessHour.
     * @example
     * // Delete one BusinessHour
     * const BusinessHour = await prisma.businessHour.delete({
     *   where: {
     *     // ... filter to delete one BusinessHour
     *   }
     * })
     * 
    **/
    delete<T extends BusinessHourDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessHourDeleteArgs<ExtArgs>>
    ): Prisma__BusinessHourClient<$Types.GetResult<BusinessHourPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one BusinessHour.
     * @param {BusinessHourUpdateArgs} args - Arguments to update one BusinessHour.
     * @example
     * // Update one BusinessHour
     * const businessHour = await prisma.businessHour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BusinessHourUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessHourUpdateArgs<ExtArgs>>
    ): Prisma__BusinessHourClient<$Types.GetResult<BusinessHourPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more BusinessHours.
     * @param {BusinessHourDeleteManyArgs} args - Arguments to filter BusinessHours to delete.
     * @example
     * // Delete a few BusinessHours
     * const { count } = await prisma.businessHour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BusinessHourDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessHourDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessHourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessHours
     * const businessHour = await prisma.businessHour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BusinessHourUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessHourUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessHour.
     * @param {BusinessHourUpsertArgs} args - Arguments to update or create a BusinessHour.
     * @example
     * // Update or create a BusinessHour
     * const businessHour = await prisma.businessHour.upsert({
     *   create: {
     *     // ... data to create a BusinessHour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessHour we want to update
     *   }
     * })
    **/
    upsert<T extends BusinessHourUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessHourUpsertArgs<ExtArgs>>
    ): Prisma__BusinessHourClient<$Types.GetResult<BusinessHourPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of BusinessHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessHourCountArgs} args - Arguments to filter BusinessHours to count.
     * @example
     * // Count the number of BusinessHours
     * const count = await prisma.businessHour.count({
     *   where: {
     *     // ... the filter for the BusinessHours we want to count
     *   }
     * })
    **/
    count<T extends BusinessHourCountArgs>(
      args?: Subset<T, BusinessHourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessHourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessHourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessHourAggregateArgs>(args: Subset<T, BusinessHourAggregateArgs>): Prisma.PrismaPromise<GetBusinessHourAggregateType<T>>

    /**
     * Group by BusinessHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessHourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessHourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessHourGroupByArgs['orderBy'] }
        : { orderBy?: BusinessHourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessHourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessHourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessHour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BusinessHourClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    business<T extends BusinessArgs<ExtArgs> = {}>(args?: Subset<T, BusinessArgs<ExtArgs>>): Prisma__BusinessClient<$Types.GetResult<BusinessPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BusinessHour base type for findUnique actions
   */
  export type BusinessHourFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessHour
     */
    select?: BusinessHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessHourInclude<ExtArgs> | null
    /**
     * Filter, which BusinessHour to fetch.
     */
    where: BusinessHourWhereUniqueInput
  }

  /**
   * BusinessHour findUnique
   */
  export interface BusinessHourFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusinessHourFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessHour findUniqueOrThrow
   */
  export type BusinessHourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessHour
     */
    select?: BusinessHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessHourInclude<ExtArgs> | null
    /**
     * Filter, which BusinessHour to fetch.
     */
    where: BusinessHourWhereUniqueInput
  }


  /**
   * BusinessHour base type for findFirst actions
   */
  export type BusinessHourFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessHour
     */
    select?: BusinessHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessHourInclude<ExtArgs> | null
    /**
     * Filter, which BusinessHour to fetch.
     */
    where?: BusinessHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessHours to fetch.
     */
    orderBy?: Enumerable<BusinessHourOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessHours.
     */
    cursor?: BusinessHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessHours.
     */
    distinct?: Enumerable<BusinessHourScalarFieldEnum>
  }

  /**
   * BusinessHour findFirst
   */
  export interface BusinessHourFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusinessHourFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessHour findFirstOrThrow
   */
  export type BusinessHourFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessHour
     */
    select?: BusinessHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessHourInclude<ExtArgs> | null
    /**
     * Filter, which BusinessHour to fetch.
     */
    where?: BusinessHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessHours to fetch.
     */
    orderBy?: Enumerable<BusinessHourOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessHours.
     */
    cursor?: BusinessHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessHours.
     */
    distinct?: Enumerable<BusinessHourScalarFieldEnum>
  }


  /**
   * BusinessHour findMany
   */
  export type BusinessHourFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessHour
     */
    select?: BusinessHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessHourInclude<ExtArgs> | null
    /**
     * Filter, which BusinessHours to fetch.
     */
    where?: BusinessHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessHours to fetch.
     */
    orderBy?: Enumerable<BusinessHourOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessHours.
     */
    cursor?: BusinessHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessHours.
     */
    skip?: number
    distinct?: Enumerable<BusinessHourScalarFieldEnum>
  }


  /**
   * BusinessHour create
   */
  export type BusinessHourCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessHour
     */
    select?: BusinessHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessHourInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessHour.
     */
    data: XOR<BusinessHourCreateInput, BusinessHourUncheckedCreateInput>
  }


  /**
   * BusinessHour createMany
   */
  export type BusinessHourCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessHours.
     */
    data: Enumerable<BusinessHourCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BusinessHour update
   */
  export type BusinessHourUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessHour
     */
    select?: BusinessHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessHourInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessHour.
     */
    data: XOR<BusinessHourUpdateInput, BusinessHourUncheckedUpdateInput>
    /**
     * Choose, which BusinessHour to update.
     */
    where: BusinessHourWhereUniqueInput
  }


  /**
   * BusinessHour updateMany
   */
  export type BusinessHourUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessHours.
     */
    data: XOR<BusinessHourUpdateManyMutationInput, BusinessHourUncheckedUpdateManyInput>
    /**
     * Filter which BusinessHours to update
     */
    where?: BusinessHourWhereInput
  }


  /**
   * BusinessHour upsert
   */
  export type BusinessHourUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessHour
     */
    select?: BusinessHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessHourInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessHour to update in case it exists.
     */
    where: BusinessHourWhereUniqueInput
    /**
     * In case the BusinessHour found by the `where` argument doesn't exist, create a new BusinessHour with this data.
     */
    create: XOR<BusinessHourCreateInput, BusinessHourUncheckedCreateInput>
    /**
     * In case the BusinessHour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessHourUpdateInput, BusinessHourUncheckedUpdateInput>
  }


  /**
   * BusinessHour delete
   */
  export type BusinessHourDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessHour
     */
    select?: BusinessHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessHourInclude<ExtArgs> | null
    /**
     * Filter which BusinessHour to delete.
     */
    where: BusinessHourWhereUniqueInput
  }


  /**
   * BusinessHour deleteMany
   */
  export type BusinessHourDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessHours to delete
     */
    where?: BusinessHourWhereInput
  }


  /**
   * BusinessHour without action
   */
  export type BusinessHourArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessHour
     */
    select?: BusinessHourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessHourInclude<ExtArgs> | null
  }



  /**
   * Model Staff
   */


  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    role: string | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    role: string | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    businessId: number
    name: number
    role: number
    email: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffMinAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    role?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    role?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    role?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to aggregate.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
    orderBy?: Enumerable<StaffOrderByWithAggregationInput>
    by: StaffScalarFieldEnum[]
    having?: StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }


  export type StaffGroupByOutputType = {
    id: string
    businessId: string
    name: string
    role: string
    email: string | null
    phone: string | null
    createdAt: Date
    updatedAt: Date
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type StaffSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessArgs<ExtArgs>
    schedules?: boolean | Staff$schedulesArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectScalar = {
    id?: boolean
    businessId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessArgs<ExtArgs>
    schedules?: boolean | Staff$schedulesArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeArgs<ExtArgs>
  }


  type StaffGetPayload<S extends boolean | null | undefined | StaffArgs> = $Types.GetResult<StaffPayload, S>

  type StaffCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StaffFindManyArgs, 'select' | 'include'> & {
      select?: StaffCountAggregateInputType | true
    }

  export interface StaffDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Staff'], meta: { name: 'Staff' } }
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StaffFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StaffFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Staff'> extends True ? Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Staff that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StaffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StaffFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StaffFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StaffFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Staff'> extends True ? Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Staff that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StaffFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StaffFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
    **/
    create<T extends StaffCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffCreateArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Staff.
     *     @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     *     @example
     *     // Create many Staff
     *     const staff = await prisma.staff.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StaffCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
    **/
    delete<T extends StaffDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StaffDeleteArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StaffUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffUpdateArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StaffDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StaffUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StaffUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
    **/
    upsert<T extends StaffUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StaffUpsertArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): Prisma.PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StaffClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    business<T extends BusinessArgs<ExtArgs> = {}>(args?: Subset<T, BusinessArgs<ExtArgs>>): Prisma__BusinessClient<$Types.GetResult<BusinessPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    schedules<T extends Staff$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Staff$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<StaffSchedulePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Staff base type for findUnique actions
   */
  export type StaffFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findUnique
   */
  export interface StaffFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends StaffFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Staff findUniqueOrThrow
   */
  export type StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }


  /**
   * Staff base type for findFirst actions
   */
  export type StaffFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: Enumerable<StaffScalarFieldEnum>
  }

  /**
   * Staff findFirst
   */
  export interface StaffFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends StaffFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Staff findFirstOrThrow
   */
  export type StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: Enumerable<StaffScalarFieldEnum>
  }


  /**
   * Staff findMany
   */
  export type StaffFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    distinct?: Enumerable<StaffScalarFieldEnum>
  }


  /**
   * Staff create
   */
  export type StaffCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to create a Staff.
     */
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>
  }


  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Staff.
     */
    data: Enumerable<StaffCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Staff update
   */
  export type StaffUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to update a Staff.
     */
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
    /**
     * Choose, which Staff to update.
     */
    where: StaffWhereUniqueInput
  }


  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
  }


  /**
   * Staff upsert
   */
  export type StaffUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The filter to search for the Staff to update in case it exists.
     */
    where: StaffWhereUniqueInput
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     */
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
  }


  /**
   * Staff delete
   */
  export type StaffDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter which Staff to delete.
     */
    where: StaffWhereUniqueInput
  }


  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to delete
     */
    where?: StaffWhereInput
  }


  /**
   * Staff.schedules
   */
  export type Staff$schedulesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffSchedule
     */
    select?: StaffScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffScheduleInclude<ExtArgs> | null
    where?: StaffScheduleWhereInput
    orderBy?: Enumerable<StaffScheduleOrderByWithRelationInput>
    cursor?: StaffScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StaffScheduleScalarFieldEnum>
  }


  /**
   * Staff without action
   */
  export type StaffArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
  }



  /**
   * Model StaffSchedule
   */


  export type AggregateStaffSchedule = {
    _count: StaffScheduleCountAggregateOutputType | null
    _min: StaffScheduleMinAggregateOutputType | null
    _max: StaffScheduleMaxAggregateOutputType | null
  }

  export type StaffScheduleMinAggregateOutputType = {
    id: string | null
    staffId: string | null
    date: Date | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffScheduleMaxAggregateOutputType = {
    id: string | null
    staffId: string | null
    date: Date | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffScheduleCountAggregateOutputType = {
    id: number
    staffId: number
    date: number
    startTime: number
    endTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffScheduleMinAggregateInputType = {
    id?: true
    staffId?: true
    date?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffScheduleMaxAggregateInputType = {
    id?: true
    staffId?: true
    date?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffScheduleCountAggregateInputType = {
    id?: true
    staffId?: true
    date?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffScheduleAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffSchedule to aggregate.
     */
    where?: StaffScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffSchedules to fetch.
     */
    orderBy?: Enumerable<StaffScheduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffSchedules
    **/
    _count?: true | StaffScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffScheduleMaxAggregateInputType
  }

  export type GetStaffScheduleAggregateType<T extends StaffScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffSchedule[P]>
      : GetScalarType<T[P], AggregateStaffSchedule[P]>
  }




  export type StaffScheduleGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StaffScheduleWhereInput
    orderBy?: Enumerable<StaffScheduleOrderByWithAggregationInput>
    by: StaffScheduleScalarFieldEnum[]
    having?: StaffScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffScheduleCountAggregateInputType | true
    _min?: StaffScheduleMinAggregateInputType
    _max?: StaffScheduleMaxAggregateInputType
  }


  export type StaffScheduleGroupByOutputType = {
    id: string
    staffId: string
    date: Date
    startTime: Date
    endTime: Date
    createdAt: Date
    updatedAt: Date
    _count: StaffScheduleCountAggregateOutputType | null
    _min: StaffScheduleMinAggregateOutputType | null
    _max: StaffScheduleMaxAggregateOutputType | null
  }

  type GetStaffScheduleGroupByPayload<T extends StaffScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<StaffScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], StaffScheduleGroupByOutputType[P]>
        }
      >
    >


  export type StaffScheduleSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffArgs<ExtArgs>
    attendanceRecords?: boolean | StaffSchedule$attendanceRecordsArgs<ExtArgs>
    _count?: boolean | StaffScheduleCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["staffSchedule"]>

  export type StaffScheduleSelectScalar = {
    id?: boolean
    staffId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffScheduleInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffArgs<ExtArgs>
    attendanceRecords?: boolean | StaffSchedule$attendanceRecordsArgs<ExtArgs>
    _count?: boolean | StaffScheduleCountOutputTypeArgs<ExtArgs>
  }


  type StaffScheduleGetPayload<S extends boolean | null | undefined | StaffScheduleArgs> = $Types.GetResult<StaffSchedulePayload, S>

  type StaffScheduleCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StaffScheduleFindManyArgs, 'select' | 'include'> & {
      select?: StaffScheduleCountAggregateInputType | true
    }

  export interface StaffScheduleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffSchedule'], meta: { name: 'StaffSchedule' } }
    /**
     * Find zero or one StaffSchedule that matches the filter.
     * @param {StaffScheduleFindUniqueArgs} args - Arguments to find a StaffSchedule
     * @example
     * // Get one StaffSchedule
     * const staffSchedule = await prisma.staffSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StaffScheduleFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StaffScheduleFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StaffSchedule'> extends True ? Prisma__StaffScheduleClient<$Types.GetResult<StaffSchedulePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__StaffScheduleClient<$Types.GetResult<StaffSchedulePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one StaffSchedule that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StaffScheduleFindUniqueOrThrowArgs} args - Arguments to find a StaffSchedule
     * @example
     * // Get one StaffSchedule
     * const staffSchedule = await prisma.staffSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StaffScheduleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffScheduleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StaffScheduleClient<$Types.GetResult<StaffSchedulePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first StaffSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffScheduleFindFirstArgs} args - Arguments to find a StaffSchedule
     * @example
     * // Get one StaffSchedule
     * const staffSchedule = await prisma.staffSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StaffScheduleFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StaffScheduleFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StaffSchedule'> extends True ? Prisma__StaffScheduleClient<$Types.GetResult<StaffSchedulePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__StaffScheduleClient<$Types.GetResult<StaffSchedulePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first StaffSchedule that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffScheduleFindFirstOrThrowArgs} args - Arguments to find a StaffSchedule
     * @example
     * // Get one StaffSchedule
     * const staffSchedule = await prisma.staffSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StaffScheduleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffScheduleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StaffScheduleClient<$Types.GetResult<StaffSchedulePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more StaffSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffScheduleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffSchedules
     * const staffSchedules = await prisma.staffSchedule.findMany()
     * 
     * // Get first 10 StaffSchedules
     * const staffSchedules = await prisma.staffSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffScheduleWithIdOnly = await prisma.staffSchedule.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StaffScheduleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffScheduleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<StaffSchedulePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a StaffSchedule.
     * @param {StaffScheduleCreateArgs} args - Arguments to create a StaffSchedule.
     * @example
     * // Create one StaffSchedule
     * const StaffSchedule = await prisma.staffSchedule.create({
     *   data: {
     *     // ... data to create a StaffSchedule
     *   }
     * })
     * 
    **/
    create<T extends StaffScheduleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffScheduleCreateArgs<ExtArgs>>
    ): Prisma__StaffScheduleClient<$Types.GetResult<StaffSchedulePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many StaffSchedules.
     *     @param {StaffScheduleCreateManyArgs} args - Arguments to create many StaffSchedules.
     *     @example
     *     // Create many StaffSchedules
     *     const staffSchedule = await prisma.staffSchedule.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StaffScheduleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffScheduleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StaffSchedule.
     * @param {StaffScheduleDeleteArgs} args - Arguments to delete one StaffSchedule.
     * @example
     * // Delete one StaffSchedule
     * const StaffSchedule = await prisma.staffSchedule.delete({
     *   where: {
     *     // ... filter to delete one StaffSchedule
     *   }
     * })
     * 
    **/
    delete<T extends StaffScheduleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StaffScheduleDeleteArgs<ExtArgs>>
    ): Prisma__StaffScheduleClient<$Types.GetResult<StaffSchedulePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one StaffSchedule.
     * @param {StaffScheduleUpdateArgs} args - Arguments to update one StaffSchedule.
     * @example
     * // Update one StaffSchedule
     * const staffSchedule = await prisma.staffSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StaffScheduleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffScheduleUpdateArgs<ExtArgs>>
    ): Prisma__StaffScheduleClient<$Types.GetResult<StaffSchedulePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more StaffSchedules.
     * @param {StaffScheduleDeleteManyArgs} args - Arguments to filter StaffSchedules to delete.
     * @example
     * // Delete a few StaffSchedules
     * const { count } = await prisma.staffSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StaffScheduleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffScheduleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffSchedules
     * const staffSchedule = await prisma.staffSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StaffScheduleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StaffScheduleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StaffSchedule.
     * @param {StaffScheduleUpsertArgs} args - Arguments to update or create a StaffSchedule.
     * @example
     * // Update or create a StaffSchedule
     * const staffSchedule = await prisma.staffSchedule.upsert({
     *   create: {
     *     // ... data to create a StaffSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffSchedule we want to update
     *   }
     * })
    **/
    upsert<T extends StaffScheduleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StaffScheduleUpsertArgs<ExtArgs>>
    ): Prisma__StaffScheduleClient<$Types.GetResult<StaffSchedulePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of StaffSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffScheduleCountArgs} args - Arguments to filter StaffSchedules to count.
     * @example
     * // Count the number of StaffSchedules
     * const count = await prisma.staffSchedule.count({
     *   where: {
     *     // ... the filter for the StaffSchedules we want to count
     *   }
     * })
    **/
    count<T extends StaffScheduleCountArgs>(
      args?: Subset<T, StaffScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffScheduleAggregateArgs>(args: Subset<T, StaffScheduleAggregateArgs>): Prisma.PrismaPromise<GetStaffScheduleAggregateType<T>>

    /**
     * Group by StaffSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffScheduleGroupByArgs['orderBy'] }
        : { orderBy?: StaffScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StaffScheduleClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    staff<T extends StaffArgs<ExtArgs> = {}>(args?: Subset<T, StaffArgs<ExtArgs>>): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    attendanceRecords<T extends StaffSchedule$attendanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, StaffSchedule$attendanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AttendanceRecordPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * StaffSchedule base type for findUnique actions
   */
  export type StaffScheduleFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffSchedule
     */
    select?: StaffScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffScheduleInclude<ExtArgs> | null
    /**
     * Filter, which StaffSchedule to fetch.
     */
    where: StaffScheduleWhereUniqueInput
  }

  /**
   * StaffSchedule findUnique
   */
  export interface StaffScheduleFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends StaffScheduleFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StaffSchedule findUniqueOrThrow
   */
  export type StaffScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffSchedule
     */
    select?: StaffScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffScheduleInclude<ExtArgs> | null
    /**
     * Filter, which StaffSchedule to fetch.
     */
    where: StaffScheduleWhereUniqueInput
  }


  /**
   * StaffSchedule base type for findFirst actions
   */
  export type StaffScheduleFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffSchedule
     */
    select?: StaffScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffScheduleInclude<ExtArgs> | null
    /**
     * Filter, which StaffSchedule to fetch.
     */
    where?: StaffScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffSchedules to fetch.
     */
    orderBy?: Enumerable<StaffScheduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffSchedules.
     */
    cursor?: StaffScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffSchedules.
     */
    distinct?: Enumerable<StaffScheduleScalarFieldEnum>
  }

  /**
   * StaffSchedule findFirst
   */
  export interface StaffScheduleFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends StaffScheduleFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StaffSchedule findFirstOrThrow
   */
  export type StaffScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffSchedule
     */
    select?: StaffScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffScheduleInclude<ExtArgs> | null
    /**
     * Filter, which StaffSchedule to fetch.
     */
    where?: StaffScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffSchedules to fetch.
     */
    orderBy?: Enumerable<StaffScheduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffSchedules.
     */
    cursor?: StaffScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffSchedules.
     */
    distinct?: Enumerable<StaffScheduleScalarFieldEnum>
  }


  /**
   * StaffSchedule findMany
   */
  export type StaffScheduleFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffSchedule
     */
    select?: StaffScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffScheduleInclude<ExtArgs> | null
    /**
     * Filter, which StaffSchedules to fetch.
     */
    where?: StaffScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffSchedules to fetch.
     */
    orderBy?: Enumerable<StaffScheduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffSchedules.
     */
    cursor?: StaffScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffSchedules.
     */
    skip?: number
    distinct?: Enumerable<StaffScheduleScalarFieldEnum>
  }


  /**
   * StaffSchedule create
   */
  export type StaffScheduleCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffSchedule
     */
    select?: StaffScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffSchedule.
     */
    data: XOR<StaffScheduleCreateInput, StaffScheduleUncheckedCreateInput>
  }


  /**
   * StaffSchedule createMany
   */
  export type StaffScheduleCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaffSchedules.
     */
    data: Enumerable<StaffScheduleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StaffSchedule update
   */
  export type StaffScheduleUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffSchedule
     */
    select?: StaffScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffSchedule.
     */
    data: XOR<StaffScheduleUpdateInput, StaffScheduleUncheckedUpdateInput>
    /**
     * Choose, which StaffSchedule to update.
     */
    where: StaffScheduleWhereUniqueInput
  }


  /**
   * StaffSchedule updateMany
   */
  export type StaffScheduleUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffSchedules.
     */
    data: XOR<StaffScheduleUpdateManyMutationInput, StaffScheduleUncheckedUpdateManyInput>
    /**
     * Filter which StaffSchedules to update
     */
    where?: StaffScheduleWhereInput
  }


  /**
   * StaffSchedule upsert
   */
  export type StaffScheduleUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffSchedule
     */
    select?: StaffScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffSchedule to update in case it exists.
     */
    where: StaffScheduleWhereUniqueInput
    /**
     * In case the StaffSchedule found by the `where` argument doesn't exist, create a new StaffSchedule with this data.
     */
    create: XOR<StaffScheduleCreateInput, StaffScheduleUncheckedCreateInput>
    /**
     * In case the StaffSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffScheduleUpdateInput, StaffScheduleUncheckedUpdateInput>
  }


  /**
   * StaffSchedule delete
   */
  export type StaffScheduleDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffSchedule
     */
    select?: StaffScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffScheduleInclude<ExtArgs> | null
    /**
     * Filter which StaffSchedule to delete.
     */
    where: StaffScheduleWhereUniqueInput
  }


  /**
   * StaffSchedule deleteMany
   */
  export type StaffScheduleDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffSchedules to delete
     */
    where?: StaffScheduleWhereInput
  }


  /**
   * StaffSchedule.attendanceRecords
   */
  export type StaffSchedule$attendanceRecordsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: Enumerable<AttendanceRecordOrderByWithRelationInput>
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AttendanceRecordScalarFieldEnum>
  }


  /**
   * StaffSchedule without action
   */
  export type StaffScheduleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffSchedule
     */
    select?: StaffScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffScheduleInclude<ExtArgs> | null
  }



  /**
   * Model AttendanceRecord
   */


  export type AggregateAttendanceRecord = {
    _count: AttendanceRecordCountAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  export type AttendanceRecordMinAggregateOutputType = {
    id: string | null
    scheduleId: string | null
    status: string | null
    timestamp: Date | null
  }

  export type AttendanceRecordMaxAggregateOutputType = {
    id: string | null
    scheduleId: string | null
    status: string | null
    timestamp: Date | null
  }

  export type AttendanceRecordCountAggregateOutputType = {
    id: number
    scheduleId: number
    status: number
    timestamp: number
    _all: number
  }


  export type AttendanceRecordMinAggregateInputType = {
    id?: true
    scheduleId?: true
    status?: true
    timestamp?: true
  }

  export type AttendanceRecordMaxAggregateInputType = {
    id?: true
    scheduleId?: true
    status?: true
    timestamp?: true
  }

  export type AttendanceRecordCountAggregateInputType = {
    id?: true
    scheduleId?: true
    status?: true
    timestamp?: true
    _all?: true
  }

  export type AttendanceRecordAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecord to aggregate.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: Enumerable<AttendanceRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceRecords
    **/
    _count?: true | AttendanceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type GetAttendanceRecordAggregateType<T extends AttendanceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceRecord[P]>
      : GetScalarType<T[P], AggregateAttendanceRecord[P]>
  }




  export type AttendanceRecordGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
    orderBy?: Enumerable<AttendanceRecordOrderByWithAggregationInput>
    by: AttendanceRecordScalarFieldEnum[]
    having?: AttendanceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceRecordCountAggregateInputType | true
    _min?: AttendanceRecordMinAggregateInputType
    _max?: AttendanceRecordMaxAggregateInputType
  }


  export type AttendanceRecordGroupByOutputType = {
    id: string
    scheduleId: string
    status: string
    timestamp: Date
    _count: AttendanceRecordCountAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  type GetAttendanceRecordGroupByPayload<T extends AttendanceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AttendanceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceRecordSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduleId?: boolean
    status?: boolean
    timestamp?: boolean
    schedule?: boolean | StaffScheduleArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectScalar = {
    id?: boolean
    scheduleId?: boolean
    status?: boolean
    timestamp?: boolean
  }

  export type AttendanceRecordInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    schedule?: boolean | StaffScheduleArgs<ExtArgs>
  }


  type AttendanceRecordGetPayload<S extends boolean | null | undefined | AttendanceRecordArgs> = $Types.GetResult<AttendanceRecordPayload, S>

  type AttendanceRecordCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AttendanceRecordFindManyArgs, 'select' | 'include'> & {
      select?: AttendanceRecordCountAggregateInputType | true
    }

  export interface AttendanceRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceRecord'], meta: { name: 'AttendanceRecord' } }
    /**
     * Find zero or one AttendanceRecord that matches the filter.
     * @param {AttendanceRecordFindUniqueArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AttendanceRecordFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AttendanceRecordFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AttendanceRecord'> extends True ? Prisma__AttendanceRecordClient<$Types.GetResult<AttendanceRecordPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AttendanceRecordClient<$Types.GetResult<AttendanceRecordPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one AttendanceRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AttendanceRecordFindUniqueOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AttendanceRecordClient<$Types.GetResult<AttendanceRecordPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first AttendanceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AttendanceRecordFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AttendanceRecordFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AttendanceRecord'> extends True ? Prisma__AttendanceRecordClient<$Types.GetResult<AttendanceRecordPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AttendanceRecordClient<$Types.GetResult<AttendanceRecordPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first AttendanceRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AttendanceRecordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AttendanceRecordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AttendanceRecordClient<$Types.GetResult<AttendanceRecordPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more AttendanceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany()
     * 
     * // Get first 10 AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AttendanceRecordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AttendanceRecordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AttendanceRecordPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a AttendanceRecord.
     * @param {AttendanceRecordCreateArgs} args - Arguments to create a AttendanceRecord.
     * @example
     * // Create one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.create({
     *   data: {
     *     // ... data to create a AttendanceRecord
     *   }
     * })
     * 
    **/
    create<T extends AttendanceRecordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AttendanceRecordCreateArgs<ExtArgs>>
    ): Prisma__AttendanceRecordClient<$Types.GetResult<AttendanceRecordPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many AttendanceRecords.
     *     @param {AttendanceRecordCreateManyArgs} args - Arguments to create many AttendanceRecords.
     *     @example
     *     // Create many AttendanceRecords
     *     const attendanceRecord = await prisma.attendanceRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AttendanceRecordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AttendanceRecordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AttendanceRecord.
     * @param {AttendanceRecordDeleteArgs} args - Arguments to delete one AttendanceRecord.
     * @example
     * // Delete one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.delete({
     *   where: {
     *     // ... filter to delete one AttendanceRecord
     *   }
     * })
     * 
    **/
    delete<T extends AttendanceRecordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AttendanceRecordDeleteArgs<ExtArgs>>
    ): Prisma__AttendanceRecordClient<$Types.GetResult<AttendanceRecordPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one AttendanceRecord.
     * @param {AttendanceRecordUpdateArgs} args - Arguments to update one AttendanceRecord.
     * @example
     * // Update one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AttendanceRecordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AttendanceRecordUpdateArgs<ExtArgs>>
    ): Prisma__AttendanceRecordClient<$Types.GetResult<AttendanceRecordPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more AttendanceRecords.
     * @param {AttendanceRecordDeleteManyArgs} args - Arguments to filter AttendanceRecords to delete.
     * @example
     * // Delete a few AttendanceRecords
     * const { count } = await prisma.attendanceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AttendanceRecordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AttendanceRecordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AttendanceRecordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AttendanceRecordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttendanceRecord.
     * @param {AttendanceRecordUpsertArgs} args - Arguments to update or create a AttendanceRecord.
     * @example
     * // Update or create a AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.upsert({
     *   create: {
     *     // ... data to create a AttendanceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceRecord we want to update
     *   }
     * })
    **/
    upsert<T extends AttendanceRecordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AttendanceRecordUpsertArgs<ExtArgs>>
    ): Prisma__AttendanceRecordClient<$Types.GetResult<AttendanceRecordPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordCountArgs} args - Arguments to filter AttendanceRecords to count.
     * @example
     * // Count the number of AttendanceRecords
     * const count = await prisma.attendanceRecord.count({
     *   where: {
     *     // ... the filter for the AttendanceRecords we want to count
     *   }
     * })
    **/
    count<T extends AttendanceRecordCountArgs>(
      args?: Subset<T, AttendanceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceRecordAggregateArgs>(args: Subset<T, AttendanceRecordAggregateArgs>): Prisma.PrismaPromise<GetAttendanceRecordAggregateType<T>>

    /**
     * Group by AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceRecordGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AttendanceRecordClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    schedule<T extends StaffScheduleArgs<ExtArgs> = {}>(args?: Subset<T, StaffScheduleArgs<ExtArgs>>): Prisma__StaffScheduleClient<$Types.GetResult<StaffSchedulePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AttendanceRecord base type for findUnique actions
   */
  export type AttendanceRecordFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findUnique
   */
  export interface AttendanceRecordFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AttendanceRecordFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AttendanceRecord findUniqueOrThrow
   */
  export type AttendanceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }


  /**
   * AttendanceRecord base type for findFirst actions
   */
  export type AttendanceRecordFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: Enumerable<AttendanceRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: Enumerable<AttendanceRecordScalarFieldEnum>
  }

  /**
   * AttendanceRecord findFirst
   */
  export interface AttendanceRecordFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AttendanceRecordFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AttendanceRecord findFirstOrThrow
   */
  export type AttendanceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: Enumerable<AttendanceRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: Enumerable<AttendanceRecordScalarFieldEnum>
  }


  /**
   * AttendanceRecord findMany
   */
  export type AttendanceRecordFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecords to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: Enumerable<AttendanceRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    distinct?: Enumerable<AttendanceRecordScalarFieldEnum>
  }


  /**
   * AttendanceRecord create
   */
  export type AttendanceRecordCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceRecord.
     */
    data: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
  }


  /**
   * AttendanceRecord createMany
   */
  export type AttendanceRecordCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceRecords.
     */
    data: Enumerable<AttendanceRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AttendanceRecord update
   */
  export type AttendanceRecordUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceRecord.
     */
    data: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
    /**
     * Choose, which AttendanceRecord to update.
     */
    where: AttendanceRecordWhereUniqueInput
  }


  /**
   * AttendanceRecord updateMany
   */
  export type AttendanceRecordUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceRecords.
     */
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceRecords to update
     */
    where?: AttendanceRecordWhereInput
  }


  /**
   * AttendanceRecord upsert
   */
  export type AttendanceRecordUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceRecord to update in case it exists.
     */
    where: AttendanceRecordWhereUniqueInput
    /**
     * In case the AttendanceRecord found by the `where` argument doesn't exist, create a new AttendanceRecord with this data.
     */
    create: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
    /**
     * In case the AttendanceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
  }


  /**
   * AttendanceRecord delete
   */
  export type AttendanceRecordDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter which AttendanceRecord to delete.
     */
    where: AttendanceRecordWhereUniqueInput
  }


  /**
   * AttendanceRecord deleteMany
   */
  export type AttendanceRecordDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecords to delete
     */
    where?: AttendanceRecordWhereInput
  }


  /**
   * AttendanceRecord without action
   */
  export type AttendanceRecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
  }



  /**
   * Model TrainingModule
   */


  export type AggregateTrainingModule = {
    _count: TrainingModuleCountAggregateOutputType | null
    _min: TrainingModuleMinAggregateOutputType | null
    _max: TrainingModuleMaxAggregateOutputType | null
  }

  export type TrainingModuleMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    contentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingModuleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    contentUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingModuleCountAggregateOutputType = {
    id: number
    title: number
    description: number
    contentUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingModuleMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    contentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingModuleMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    contentUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingModuleCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    contentUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingModuleAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingModule to aggregate.
     */
    where?: TrainingModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingModules to fetch.
     */
    orderBy?: Enumerable<TrainingModuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingModules
    **/
    _count?: true | TrainingModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingModuleMaxAggregateInputType
  }

  export type GetTrainingModuleAggregateType<T extends TrainingModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingModule[P]>
      : GetScalarType<T[P], AggregateTrainingModule[P]>
  }




  export type TrainingModuleGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TrainingModuleWhereInput
    orderBy?: Enumerable<TrainingModuleOrderByWithAggregationInput>
    by: TrainingModuleScalarFieldEnum[]
    having?: TrainingModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingModuleCountAggregateInputType | true
    _min?: TrainingModuleMinAggregateInputType
    _max?: TrainingModuleMaxAggregateInputType
  }


  export type TrainingModuleGroupByOutputType = {
    id: string
    title: string
    description: string | null
    contentUrl: string
    createdAt: Date
    updatedAt: Date
    _count: TrainingModuleCountAggregateOutputType | null
    _min: TrainingModuleMinAggregateOutputType | null
    _max: TrainingModuleMaxAggregateOutputType | null
  }

  type GetTrainingModuleGroupByPayload<T extends TrainingModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TrainingModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingModuleGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingModuleGroupByOutputType[P]>
        }
      >
    >


  export type TrainingModuleSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    contentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingProgress?: boolean | TrainingModule$trainingProgressArgs<ExtArgs>
    _count?: boolean | TrainingModuleCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["trainingModule"]>

  export type TrainingModuleSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    contentUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingModuleInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    trainingProgress?: boolean | TrainingModule$trainingProgressArgs<ExtArgs>
    _count?: boolean | TrainingModuleCountOutputTypeArgs<ExtArgs>
  }


  type TrainingModuleGetPayload<S extends boolean | null | undefined | TrainingModuleArgs> = $Types.GetResult<TrainingModulePayload, S>

  type TrainingModuleCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TrainingModuleFindManyArgs, 'select' | 'include'> & {
      select?: TrainingModuleCountAggregateInputType | true
    }

  export interface TrainingModuleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingModule'], meta: { name: 'TrainingModule' } }
    /**
     * Find zero or one TrainingModule that matches the filter.
     * @param {TrainingModuleFindUniqueArgs} args - Arguments to find a TrainingModule
     * @example
     * // Get one TrainingModule
     * const trainingModule = await prisma.trainingModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrainingModuleFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TrainingModuleFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TrainingModule'> extends True ? Prisma__TrainingModuleClient<$Types.GetResult<TrainingModulePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TrainingModuleClient<$Types.GetResult<TrainingModulePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one TrainingModule that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TrainingModuleFindUniqueOrThrowArgs} args - Arguments to find a TrainingModule
     * @example
     * // Get one TrainingModule
     * const trainingModule = await prisma.trainingModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrainingModuleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingModuleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TrainingModuleClient<$Types.GetResult<TrainingModulePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first TrainingModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingModuleFindFirstArgs} args - Arguments to find a TrainingModule
     * @example
     * // Get one TrainingModule
     * const trainingModule = await prisma.trainingModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrainingModuleFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TrainingModuleFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TrainingModule'> extends True ? Prisma__TrainingModuleClient<$Types.GetResult<TrainingModulePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TrainingModuleClient<$Types.GetResult<TrainingModulePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first TrainingModule that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingModuleFindFirstOrThrowArgs} args - Arguments to find a TrainingModule
     * @example
     * // Get one TrainingModule
     * const trainingModule = await prisma.trainingModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrainingModuleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingModuleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TrainingModuleClient<$Types.GetResult<TrainingModulePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more TrainingModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingModuleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingModules
     * const trainingModules = await prisma.trainingModule.findMany()
     * 
     * // Get first 10 TrainingModules
     * const trainingModules = await prisma.trainingModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingModuleWithIdOnly = await prisma.trainingModule.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TrainingModuleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingModuleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TrainingModulePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a TrainingModule.
     * @param {TrainingModuleCreateArgs} args - Arguments to create a TrainingModule.
     * @example
     * // Create one TrainingModule
     * const TrainingModule = await prisma.trainingModule.create({
     *   data: {
     *     // ... data to create a TrainingModule
     *   }
     * })
     * 
    **/
    create<T extends TrainingModuleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingModuleCreateArgs<ExtArgs>>
    ): Prisma__TrainingModuleClient<$Types.GetResult<TrainingModulePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many TrainingModules.
     *     @param {TrainingModuleCreateManyArgs} args - Arguments to create many TrainingModules.
     *     @example
     *     // Create many TrainingModules
     *     const trainingModule = await prisma.trainingModule.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrainingModuleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingModuleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrainingModule.
     * @param {TrainingModuleDeleteArgs} args - Arguments to delete one TrainingModule.
     * @example
     * // Delete one TrainingModule
     * const TrainingModule = await prisma.trainingModule.delete({
     *   where: {
     *     // ... filter to delete one TrainingModule
     *   }
     * })
     * 
    **/
    delete<T extends TrainingModuleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingModuleDeleteArgs<ExtArgs>>
    ): Prisma__TrainingModuleClient<$Types.GetResult<TrainingModulePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one TrainingModule.
     * @param {TrainingModuleUpdateArgs} args - Arguments to update one TrainingModule.
     * @example
     * // Update one TrainingModule
     * const trainingModule = await prisma.trainingModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrainingModuleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingModuleUpdateArgs<ExtArgs>>
    ): Prisma__TrainingModuleClient<$Types.GetResult<TrainingModulePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more TrainingModules.
     * @param {TrainingModuleDeleteManyArgs} args - Arguments to filter TrainingModules to delete.
     * @example
     * // Delete a few TrainingModules
     * const { count } = await prisma.trainingModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrainingModuleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingModuleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingModules
     * const trainingModule = await prisma.trainingModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrainingModuleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingModuleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingModule.
     * @param {TrainingModuleUpsertArgs} args - Arguments to update or create a TrainingModule.
     * @example
     * // Update or create a TrainingModule
     * const trainingModule = await prisma.trainingModule.upsert({
     *   create: {
     *     // ... data to create a TrainingModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingModule we want to update
     *   }
     * })
    **/
    upsert<T extends TrainingModuleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingModuleUpsertArgs<ExtArgs>>
    ): Prisma__TrainingModuleClient<$Types.GetResult<TrainingModulePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of TrainingModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingModuleCountArgs} args - Arguments to filter TrainingModules to count.
     * @example
     * // Count the number of TrainingModules
     * const count = await prisma.trainingModule.count({
     *   where: {
     *     // ... the filter for the TrainingModules we want to count
     *   }
     * })
    **/
    count<T extends TrainingModuleCountArgs>(
      args?: Subset<T, TrainingModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingModuleAggregateArgs>(args: Subset<T, TrainingModuleAggregateArgs>): Prisma.PrismaPromise<GetTrainingModuleAggregateType<T>>

    /**
     * Group by TrainingModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingModuleGroupByArgs['orderBy'] }
        : { orderBy?: TrainingModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TrainingModuleClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    trainingProgress<T extends TrainingModule$trainingProgressArgs<ExtArgs> = {}>(args?: Subset<T, TrainingModule$trainingProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TrainingProgressPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TrainingModule base type for findUnique actions
   */
  export type TrainingModuleFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingModule
     */
    select?: TrainingModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingModuleInclude<ExtArgs> | null
    /**
     * Filter, which TrainingModule to fetch.
     */
    where: TrainingModuleWhereUniqueInput
  }

  /**
   * TrainingModule findUnique
   */
  export interface TrainingModuleFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TrainingModuleFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TrainingModule findUniqueOrThrow
   */
  export type TrainingModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingModule
     */
    select?: TrainingModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingModuleInclude<ExtArgs> | null
    /**
     * Filter, which TrainingModule to fetch.
     */
    where: TrainingModuleWhereUniqueInput
  }


  /**
   * TrainingModule base type for findFirst actions
   */
  export type TrainingModuleFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingModule
     */
    select?: TrainingModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingModuleInclude<ExtArgs> | null
    /**
     * Filter, which TrainingModule to fetch.
     */
    where?: TrainingModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingModules to fetch.
     */
    orderBy?: Enumerable<TrainingModuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingModules.
     */
    cursor?: TrainingModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingModules.
     */
    distinct?: Enumerable<TrainingModuleScalarFieldEnum>
  }

  /**
   * TrainingModule findFirst
   */
  export interface TrainingModuleFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TrainingModuleFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TrainingModule findFirstOrThrow
   */
  export type TrainingModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingModule
     */
    select?: TrainingModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingModuleInclude<ExtArgs> | null
    /**
     * Filter, which TrainingModule to fetch.
     */
    where?: TrainingModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingModules to fetch.
     */
    orderBy?: Enumerable<TrainingModuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingModules.
     */
    cursor?: TrainingModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingModules.
     */
    distinct?: Enumerable<TrainingModuleScalarFieldEnum>
  }


  /**
   * TrainingModule findMany
   */
  export type TrainingModuleFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingModule
     */
    select?: TrainingModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingModuleInclude<ExtArgs> | null
    /**
     * Filter, which TrainingModules to fetch.
     */
    where?: TrainingModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingModules to fetch.
     */
    orderBy?: Enumerable<TrainingModuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingModules.
     */
    cursor?: TrainingModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingModules.
     */
    skip?: number
    distinct?: Enumerable<TrainingModuleScalarFieldEnum>
  }


  /**
   * TrainingModule create
   */
  export type TrainingModuleCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingModule
     */
    select?: TrainingModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingModule.
     */
    data: XOR<TrainingModuleCreateInput, TrainingModuleUncheckedCreateInput>
  }


  /**
   * TrainingModule createMany
   */
  export type TrainingModuleCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingModules.
     */
    data: Enumerable<TrainingModuleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TrainingModule update
   */
  export type TrainingModuleUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingModule
     */
    select?: TrainingModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingModule.
     */
    data: XOR<TrainingModuleUpdateInput, TrainingModuleUncheckedUpdateInput>
    /**
     * Choose, which TrainingModule to update.
     */
    where: TrainingModuleWhereUniqueInput
  }


  /**
   * TrainingModule updateMany
   */
  export type TrainingModuleUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingModules.
     */
    data: XOR<TrainingModuleUpdateManyMutationInput, TrainingModuleUncheckedUpdateManyInput>
    /**
     * Filter which TrainingModules to update
     */
    where?: TrainingModuleWhereInput
  }


  /**
   * TrainingModule upsert
   */
  export type TrainingModuleUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingModule
     */
    select?: TrainingModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingModule to update in case it exists.
     */
    where: TrainingModuleWhereUniqueInput
    /**
     * In case the TrainingModule found by the `where` argument doesn't exist, create a new TrainingModule with this data.
     */
    create: XOR<TrainingModuleCreateInput, TrainingModuleUncheckedCreateInput>
    /**
     * In case the TrainingModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingModuleUpdateInput, TrainingModuleUncheckedUpdateInput>
  }


  /**
   * TrainingModule delete
   */
  export type TrainingModuleDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingModule
     */
    select?: TrainingModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingModuleInclude<ExtArgs> | null
    /**
     * Filter which TrainingModule to delete.
     */
    where: TrainingModuleWhereUniqueInput
  }


  /**
   * TrainingModule deleteMany
   */
  export type TrainingModuleDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingModules to delete
     */
    where?: TrainingModuleWhereInput
  }


  /**
   * TrainingModule.trainingProgress
   */
  export type TrainingModule$trainingProgressArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgress
     */
    select?: TrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingProgressInclude<ExtArgs> | null
    where?: TrainingProgressWhereInput
    orderBy?: Enumerable<TrainingProgressOrderByWithRelationInput>
    cursor?: TrainingProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrainingProgressScalarFieldEnum>
  }


  /**
   * TrainingModule without action
   */
  export type TrainingModuleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingModule
     */
    select?: TrainingModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingModuleInclude<ExtArgs> | null
  }



  /**
   * Model TrainingProgress
   */


  export type AggregateTrainingProgress = {
    _count: TrainingProgressCountAggregateOutputType | null
    _min: TrainingProgressMinAggregateOutputType | null
    _max: TrainingProgressMaxAggregateOutputType | null
  }

  export type TrainingProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    moduleId: string | null
    completedAt: Date | null
  }

  export type TrainingProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    moduleId: string | null
    completedAt: Date | null
  }

  export type TrainingProgressCountAggregateOutputType = {
    id: number
    userId: number
    moduleId: number
    completedAt: number
    _all: number
  }


  export type TrainingProgressMinAggregateInputType = {
    id?: true
    userId?: true
    moduleId?: true
    completedAt?: true
  }

  export type TrainingProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    moduleId?: true
    completedAt?: true
  }

  export type TrainingProgressCountAggregateInputType = {
    id?: true
    userId?: true
    moduleId?: true
    completedAt?: true
    _all?: true
  }

  export type TrainingProgressAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingProgress to aggregate.
     */
    where?: TrainingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingProgresses to fetch.
     */
    orderBy?: Enumerable<TrainingProgressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingProgresses
    **/
    _count?: true | TrainingProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingProgressMaxAggregateInputType
  }

  export type GetTrainingProgressAggregateType<T extends TrainingProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingProgress[P]>
      : GetScalarType<T[P], AggregateTrainingProgress[P]>
  }




  export type TrainingProgressGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TrainingProgressWhereInput
    orderBy?: Enumerable<TrainingProgressOrderByWithAggregationInput>
    by: TrainingProgressScalarFieldEnum[]
    having?: TrainingProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingProgressCountAggregateInputType | true
    _min?: TrainingProgressMinAggregateInputType
    _max?: TrainingProgressMaxAggregateInputType
  }


  export type TrainingProgressGroupByOutputType = {
    id: string
    userId: string
    moduleId: string
    completedAt: Date
    _count: TrainingProgressCountAggregateOutputType | null
    _min: TrainingProgressMinAggregateOutputType | null
    _max: TrainingProgressMaxAggregateOutputType | null
  }

  type GetTrainingProgressGroupByPayload<T extends TrainingProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TrainingProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingProgressGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingProgressGroupByOutputType[P]>
        }
      >
    >


  export type TrainingProgressSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    moduleId?: boolean
    completedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
    module?: boolean | TrainingModuleArgs<ExtArgs>
  }, ExtArgs["result"]["trainingProgress"]>

  export type TrainingProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    moduleId?: boolean
    completedAt?: boolean
  }

  export type TrainingProgressInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    module?: boolean | TrainingModuleArgs<ExtArgs>
  }


  type TrainingProgressGetPayload<S extends boolean | null | undefined | TrainingProgressArgs> = $Types.GetResult<TrainingProgressPayload, S>

  type TrainingProgressCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TrainingProgressFindManyArgs, 'select' | 'include'> & {
      select?: TrainingProgressCountAggregateInputType | true
    }

  export interface TrainingProgressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingProgress'], meta: { name: 'TrainingProgress' } }
    /**
     * Find zero or one TrainingProgress that matches the filter.
     * @param {TrainingProgressFindUniqueArgs} args - Arguments to find a TrainingProgress
     * @example
     * // Get one TrainingProgress
     * const trainingProgress = await prisma.trainingProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrainingProgressFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TrainingProgressFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TrainingProgress'> extends True ? Prisma__TrainingProgressClient<$Types.GetResult<TrainingProgressPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TrainingProgressClient<$Types.GetResult<TrainingProgressPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one TrainingProgress that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TrainingProgressFindUniqueOrThrowArgs} args - Arguments to find a TrainingProgress
     * @example
     * // Get one TrainingProgress
     * const trainingProgress = await prisma.trainingProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrainingProgressFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingProgressFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TrainingProgressClient<$Types.GetResult<TrainingProgressPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first TrainingProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProgressFindFirstArgs} args - Arguments to find a TrainingProgress
     * @example
     * // Get one TrainingProgress
     * const trainingProgress = await prisma.trainingProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrainingProgressFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TrainingProgressFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TrainingProgress'> extends True ? Prisma__TrainingProgressClient<$Types.GetResult<TrainingProgressPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TrainingProgressClient<$Types.GetResult<TrainingProgressPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first TrainingProgress that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProgressFindFirstOrThrowArgs} args - Arguments to find a TrainingProgress
     * @example
     * // Get one TrainingProgress
     * const trainingProgress = await prisma.trainingProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrainingProgressFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingProgressFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TrainingProgressClient<$Types.GetResult<TrainingProgressPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more TrainingProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProgressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingProgresses
     * const trainingProgresses = await prisma.trainingProgress.findMany()
     * 
     * // Get first 10 TrainingProgresses
     * const trainingProgresses = await prisma.trainingProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingProgressWithIdOnly = await prisma.trainingProgress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TrainingProgressFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingProgressFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TrainingProgressPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a TrainingProgress.
     * @param {TrainingProgressCreateArgs} args - Arguments to create a TrainingProgress.
     * @example
     * // Create one TrainingProgress
     * const TrainingProgress = await prisma.trainingProgress.create({
     *   data: {
     *     // ... data to create a TrainingProgress
     *   }
     * })
     * 
    **/
    create<T extends TrainingProgressCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingProgressCreateArgs<ExtArgs>>
    ): Prisma__TrainingProgressClient<$Types.GetResult<TrainingProgressPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many TrainingProgresses.
     *     @param {TrainingProgressCreateManyArgs} args - Arguments to create many TrainingProgresses.
     *     @example
     *     // Create many TrainingProgresses
     *     const trainingProgress = await prisma.trainingProgress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrainingProgressCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingProgressCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrainingProgress.
     * @param {TrainingProgressDeleteArgs} args - Arguments to delete one TrainingProgress.
     * @example
     * // Delete one TrainingProgress
     * const TrainingProgress = await prisma.trainingProgress.delete({
     *   where: {
     *     // ... filter to delete one TrainingProgress
     *   }
     * })
     * 
    **/
    delete<T extends TrainingProgressDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingProgressDeleteArgs<ExtArgs>>
    ): Prisma__TrainingProgressClient<$Types.GetResult<TrainingProgressPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one TrainingProgress.
     * @param {TrainingProgressUpdateArgs} args - Arguments to update one TrainingProgress.
     * @example
     * // Update one TrainingProgress
     * const trainingProgress = await prisma.trainingProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrainingProgressUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingProgressUpdateArgs<ExtArgs>>
    ): Prisma__TrainingProgressClient<$Types.GetResult<TrainingProgressPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more TrainingProgresses.
     * @param {TrainingProgressDeleteManyArgs} args - Arguments to filter TrainingProgresses to delete.
     * @example
     * // Delete a few TrainingProgresses
     * const { count } = await prisma.trainingProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrainingProgressDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrainingProgressDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingProgresses
     * const trainingProgress = await prisma.trainingProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrainingProgressUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingProgressUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingProgress.
     * @param {TrainingProgressUpsertArgs} args - Arguments to update or create a TrainingProgress.
     * @example
     * // Update or create a TrainingProgress
     * const trainingProgress = await prisma.trainingProgress.upsert({
     *   create: {
     *     // ... data to create a TrainingProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingProgress we want to update
     *   }
     * })
    **/
    upsert<T extends TrainingProgressUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TrainingProgressUpsertArgs<ExtArgs>>
    ): Prisma__TrainingProgressClient<$Types.GetResult<TrainingProgressPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of TrainingProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProgressCountArgs} args - Arguments to filter TrainingProgresses to count.
     * @example
     * // Count the number of TrainingProgresses
     * const count = await prisma.trainingProgress.count({
     *   where: {
     *     // ... the filter for the TrainingProgresses we want to count
     *   }
     * })
    **/
    count<T extends TrainingProgressCountArgs>(
      args?: Subset<T, TrainingProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingProgressAggregateArgs>(args: Subset<T, TrainingProgressAggregateArgs>): Prisma.PrismaPromise<GetTrainingProgressAggregateType<T>>

    /**
     * Group by TrainingProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingProgressGroupByArgs['orderBy'] }
        : { orderBy?: TrainingProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TrainingProgressClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    module<T extends TrainingModuleArgs<ExtArgs> = {}>(args?: Subset<T, TrainingModuleArgs<ExtArgs>>): Prisma__TrainingModuleClient<$Types.GetResult<TrainingModulePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TrainingProgress base type for findUnique actions
   */
  export type TrainingProgressFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgress
     */
    select?: TrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingProgressInclude<ExtArgs> | null
    /**
     * Filter, which TrainingProgress to fetch.
     */
    where: TrainingProgressWhereUniqueInput
  }

  /**
   * TrainingProgress findUnique
   */
  export interface TrainingProgressFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TrainingProgressFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TrainingProgress findUniqueOrThrow
   */
  export type TrainingProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgress
     */
    select?: TrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingProgressInclude<ExtArgs> | null
    /**
     * Filter, which TrainingProgress to fetch.
     */
    where: TrainingProgressWhereUniqueInput
  }


  /**
   * TrainingProgress base type for findFirst actions
   */
  export type TrainingProgressFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgress
     */
    select?: TrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingProgressInclude<ExtArgs> | null
    /**
     * Filter, which TrainingProgress to fetch.
     */
    where?: TrainingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingProgresses to fetch.
     */
    orderBy?: Enumerable<TrainingProgressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingProgresses.
     */
    cursor?: TrainingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingProgresses.
     */
    distinct?: Enumerable<TrainingProgressScalarFieldEnum>
  }

  /**
   * TrainingProgress findFirst
   */
  export interface TrainingProgressFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TrainingProgressFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TrainingProgress findFirstOrThrow
   */
  export type TrainingProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgress
     */
    select?: TrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingProgressInclude<ExtArgs> | null
    /**
     * Filter, which TrainingProgress to fetch.
     */
    where?: TrainingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingProgresses to fetch.
     */
    orderBy?: Enumerable<TrainingProgressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingProgresses.
     */
    cursor?: TrainingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingProgresses.
     */
    distinct?: Enumerable<TrainingProgressScalarFieldEnum>
  }


  /**
   * TrainingProgress findMany
   */
  export type TrainingProgressFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgress
     */
    select?: TrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingProgressInclude<ExtArgs> | null
    /**
     * Filter, which TrainingProgresses to fetch.
     */
    where?: TrainingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingProgresses to fetch.
     */
    orderBy?: Enumerable<TrainingProgressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingProgresses.
     */
    cursor?: TrainingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingProgresses.
     */
    skip?: number
    distinct?: Enumerable<TrainingProgressScalarFieldEnum>
  }


  /**
   * TrainingProgress create
   */
  export type TrainingProgressCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgress
     */
    select?: TrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingProgress.
     */
    data: XOR<TrainingProgressCreateInput, TrainingProgressUncheckedCreateInput>
  }


  /**
   * TrainingProgress createMany
   */
  export type TrainingProgressCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingProgresses.
     */
    data: Enumerable<TrainingProgressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TrainingProgress update
   */
  export type TrainingProgressUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgress
     */
    select?: TrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingProgress.
     */
    data: XOR<TrainingProgressUpdateInput, TrainingProgressUncheckedUpdateInput>
    /**
     * Choose, which TrainingProgress to update.
     */
    where: TrainingProgressWhereUniqueInput
  }


  /**
   * TrainingProgress updateMany
   */
  export type TrainingProgressUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingProgresses.
     */
    data: XOR<TrainingProgressUpdateManyMutationInput, TrainingProgressUncheckedUpdateManyInput>
    /**
     * Filter which TrainingProgresses to update
     */
    where?: TrainingProgressWhereInput
  }


  /**
   * TrainingProgress upsert
   */
  export type TrainingProgressUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgress
     */
    select?: TrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingProgress to update in case it exists.
     */
    where: TrainingProgressWhereUniqueInput
    /**
     * In case the TrainingProgress found by the `where` argument doesn't exist, create a new TrainingProgress with this data.
     */
    create: XOR<TrainingProgressCreateInput, TrainingProgressUncheckedCreateInput>
    /**
     * In case the TrainingProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingProgressUpdateInput, TrainingProgressUncheckedUpdateInput>
  }


  /**
   * TrainingProgress delete
   */
  export type TrainingProgressDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgress
     */
    select?: TrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingProgressInclude<ExtArgs> | null
    /**
     * Filter which TrainingProgress to delete.
     */
    where: TrainingProgressWhereUniqueInput
  }


  /**
   * TrainingProgress deleteMany
   */
  export type TrainingProgressDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingProgresses to delete
     */
    where?: TrainingProgressWhereInput
  }


  /**
   * TrainingProgress without action
   */
  export type TrainingProgressArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProgress
     */
    select?: TrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrainingProgressInclude<ExtArgs> | null
  }



  /**
   * Model LoyaltyTier
   */


  export type AggregateLoyaltyTier = {
    _count: LoyaltyTierCountAggregateOutputType | null
    _avg: LoyaltyTierAvgAggregateOutputType | null
    _sum: LoyaltyTierSumAggregateOutputType | null
    _min: LoyaltyTierMinAggregateOutputType | null
    _max: LoyaltyTierMaxAggregateOutputType | null
  }

  export type LoyaltyTierAvgAggregateOutputType = {
    requiredPoints: number | null
    discount: number | null
  }

  export type LoyaltyTierSumAggregateOutputType = {
    requiredPoints: number | null
    discount: number | null
  }

  export type LoyaltyTierMinAggregateOutputType = {
    id: string | null
    name: string | null
    requiredPoints: number | null
    discount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyTierMaxAggregateOutputType = {
    id: string | null
    name: string | null
    requiredPoints: number | null
    discount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyTierCountAggregateOutputType = {
    id: number
    name: number
    requiredPoints: number
    discount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoyaltyTierAvgAggregateInputType = {
    requiredPoints?: true
    discount?: true
  }

  export type LoyaltyTierSumAggregateInputType = {
    requiredPoints?: true
    discount?: true
  }

  export type LoyaltyTierMinAggregateInputType = {
    id?: true
    name?: true
    requiredPoints?: true
    discount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyTierMaxAggregateInputType = {
    id?: true
    name?: true
    requiredPoints?: true
    discount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyTierCountAggregateInputType = {
    id?: true
    name?: true
    requiredPoints?: true
    discount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoyaltyTierAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyTier to aggregate.
     */
    where?: LoyaltyTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTiers to fetch.
     */
    orderBy?: Enumerable<LoyaltyTierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoyaltyTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoyaltyTiers
    **/
    _count?: true | LoyaltyTierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoyaltyTierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoyaltyTierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoyaltyTierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoyaltyTierMaxAggregateInputType
  }

  export type GetLoyaltyTierAggregateType<T extends LoyaltyTierAggregateArgs> = {
        [P in keyof T & keyof AggregateLoyaltyTier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoyaltyTier[P]>
      : GetScalarType<T[P], AggregateLoyaltyTier[P]>
  }




  export type LoyaltyTierGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LoyaltyTierWhereInput
    orderBy?: Enumerable<LoyaltyTierOrderByWithAggregationInput>
    by: LoyaltyTierScalarFieldEnum[]
    having?: LoyaltyTierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoyaltyTierCountAggregateInputType | true
    _avg?: LoyaltyTierAvgAggregateInputType
    _sum?: LoyaltyTierSumAggregateInputType
    _min?: LoyaltyTierMinAggregateInputType
    _max?: LoyaltyTierMaxAggregateInputType
  }


  export type LoyaltyTierGroupByOutputType = {
    id: string
    name: string
    requiredPoints: number
    discount: number
    createdAt: Date
    updatedAt: Date
    _count: LoyaltyTierCountAggregateOutputType | null
    _avg: LoyaltyTierAvgAggregateOutputType | null
    _sum: LoyaltyTierSumAggregateOutputType | null
    _min: LoyaltyTierMinAggregateOutputType | null
    _max: LoyaltyTierMaxAggregateOutputType | null
  }

  type GetLoyaltyTierGroupByPayload<T extends LoyaltyTierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LoyaltyTierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoyaltyTierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoyaltyTierGroupByOutputType[P]>
            : GetScalarType<T[P], LoyaltyTierGroupByOutputType[P]>
        }
      >
    >


  export type LoyaltyTierSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    requiredPoints?: boolean
    discount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactions?: boolean | LoyaltyTier$transactionsArgs<ExtArgs>
    _count?: boolean | LoyaltyTierCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyTier"]>

  export type LoyaltyTierSelectScalar = {
    id?: boolean
    name?: boolean
    requiredPoints?: boolean
    discount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoyaltyTierInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    transactions?: boolean | LoyaltyTier$transactionsArgs<ExtArgs>
    _count?: boolean | LoyaltyTierCountOutputTypeArgs<ExtArgs>
  }


  type LoyaltyTierGetPayload<S extends boolean | null | undefined | LoyaltyTierArgs> = $Types.GetResult<LoyaltyTierPayload, S>

  type LoyaltyTierCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LoyaltyTierFindManyArgs, 'select' | 'include'> & {
      select?: LoyaltyTierCountAggregateInputType | true
    }

  export interface LoyaltyTierDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoyaltyTier'], meta: { name: 'LoyaltyTier' } }
    /**
     * Find zero or one LoyaltyTier that matches the filter.
     * @param {LoyaltyTierFindUniqueArgs} args - Arguments to find a LoyaltyTier
     * @example
     * // Get one LoyaltyTier
     * const loyaltyTier = await prisma.loyaltyTier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LoyaltyTierFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LoyaltyTierFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LoyaltyTier'> extends True ? Prisma__LoyaltyTierClient<$Types.GetResult<LoyaltyTierPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__LoyaltyTierClient<$Types.GetResult<LoyaltyTierPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one LoyaltyTier that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LoyaltyTierFindUniqueOrThrowArgs} args - Arguments to find a LoyaltyTier
     * @example
     * // Get one LoyaltyTier
     * const loyaltyTier = await prisma.loyaltyTier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LoyaltyTierFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LoyaltyTierFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LoyaltyTierClient<$Types.GetResult<LoyaltyTierPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first LoyaltyTier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTierFindFirstArgs} args - Arguments to find a LoyaltyTier
     * @example
     * // Get one LoyaltyTier
     * const loyaltyTier = await prisma.loyaltyTier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LoyaltyTierFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LoyaltyTierFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LoyaltyTier'> extends True ? Prisma__LoyaltyTierClient<$Types.GetResult<LoyaltyTierPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__LoyaltyTierClient<$Types.GetResult<LoyaltyTierPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first LoyaltyTier that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTierFindFirstOrThrowArgs} args - Arguments to find a LoyaltyTier
     * @example
     * // Get one LoyaltyTier
     * const loyaltyTier = await prisma.loyaltyTier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LoyaltyTierFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LoyaltyTierFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LoyaltyTierClient<$Types.GetResult<LoyaltyTierPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more LoyaltyTiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoyaltyTiers
     * const loyaltyTiers = await prisma.loyaltyTier.findMany()
     * 
     * // Get first 10 LoyaltyTiers
     * const loyaltyTiers = await prisma.loyaltyTier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loyaltyTierWithIdOnly = await prisma.loyaltyTier.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LoyaltyTierFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoyaltyTierFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<LoyaltyTierPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a LoyaltyTier.
     * @param {LoyaltyTierCreateArgs} args - Arguments to create a LoyaltyTier.
     * @example
     * // Create one LoyaltyTier
     * const LoyaltyTier = await prisma.loyaltyTier.create({
     *   data: {
     *     // ... data to create a LoyaltyTier
     *   }
     * })
     * 
    **/
    create<T extends LoyaltyTierCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LoyaltyTierCreateArgs<ExtArgs>>
    ): Prisma__LoyaltyTierClient<$Types.GetResult<LoyaltyTierPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many LoyaltyTiers.
     *     @param {LoyaltyTierCreateManyArgs} args - Arguments to create many LoyaltyTiers.
     *     @example
     *     // Create many LoyaltyTiers
     *     const loyaltyTier = await prisma.loyaltyTier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LoyaltyTierCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoyaltyTierCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LoyaltyTier.
     * @param {LoyaltyTierDeleteArgs} args - Arguments to delete one LoyaltyTier.
     * @example
     * // Delete one LoyaltyTier
     * const LoyaltyTier = await prisma.loyaltyTier.delete({
     *   where: {
     *     // ... filter to delete one LoyaltyTier
     *   }
     * })
     * 
    **/
    delete<T extends LoyaltyTierDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LoyaltyTierDeleteArgs<ExtArgs>>
    ): Prisma__LoyaltyTierClient<$Types.GetResult<LoyaltyTierPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one LoyaltyTier.
     * @param {LoyaltyTierUpdateArgs} args - Arguments to update one LoyaltyTier.
     * @example
     * // Update one LoyaltyTier
     * const loyaltyTier = await prisma.loyaltyTier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LoyaltyTierUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LoyaltyTierUpdateArgs<ExtArgs>>
    ): Prisma__LoyaltyTierClient<$Types.GetResult<LoyaltyTierPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more LoyaltyTiers.
     * @param {LoyaltyTierDeleteManyArgs} args - Arguments to filter LoyaltyTiers to delete.
     * @example
     * // Delete a few LoyaltyTiers
     * const { count } = await prisma.loyaltyTier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LoyaltyTierDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoyaltyTierDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoyaltyTiers
     * const loyaltyTier = await prisma.loyaltyTier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LoyaltyTierUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LoyaltyTierUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LoyaltyTier.
     * @param {LoyaltyTierUpsertArgs} args - Arguments to update or create a LoyaltyTier.
     * @example
     * // Update or create a LoyaltyTier
     * const loyaltyTier = await prisma.loyaltyTier.upsert({
     *   create: {
     *     // ... data to create a LoyaltyTier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoyaltyTier we want to update
     *   }
     * })
    **/
    upsert<T extends LoyaltyTierUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LoyaltyTierUpsertArgs<ExtArgs>>
    ): Prisma__LoyaltyTierClient<$Types.GetResult<LoyaltyTierPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of LoyaltyTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTierCountArgs} args - Arguments to filter LoyaltyTiers to count.
     * @example
     * // Count the number of LoyaltyTiers
     * const count = await prisma.loyaltyTier.count({
     *   where: {
     *     // ... the filter for the LoyaltyTiers we want to count
     *   }
     * })
    **/
    count<T extends LoyaltyTierCountArgs>(
      args?: Subset<T, LoyaltyTierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoyaltyTierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoyaltyTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoyaltyTierAggregateArgs>(args: Subset<T, LoyaltyTierAggregateArgs>): Prisma.PrismaPromise<GetLoyaltyTierAggregateType<T>>

    /**
     * Group by LoyaltyTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoyaltyTierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoyaltyTierGroupByArgs['orderBy'] }
        : { orderBy?: LoyaltyTierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoyaltyTierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoyaltyTierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LoyaltyTier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LoyaltyTierClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    transactions<T extends LoyaltyTier$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyTier$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LoyaltyTransactionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LoyaltyTier base type for findUnique actions
   */
  export type LoyaltyTierFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTier
     */
    select?: LoyaltyTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTierInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTier to fetch.
     */
    where: LoyaltyTierWhereUniqueInput
  }

  /**
   * LoyaltyTier findUnique
   */
  export interface LoyaltyTierFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LoyaltyTierFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LoyaltyTier findUniqueOrThrow
   */
  export type LoyaltyTierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTier
     */
    select?: LoyaltyTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTierInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTier to fetch.
     */
    where: LoyaltyTierWhereUniqueInput
  }


  /**
   * LoyaltyTier base type for findFirst actions
   */
  export type LoyaltyTierFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTier
     */
    select?: LoyaltyTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTierInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTier to fetch.
     */
    where?: LoyaltyTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTiers to fetch.
     */
    orderBy?: Enumerable<LoyaltyTierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyTiers.
     */
    cursor?: LoyaltyTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyTiers.
     */
    distinct?: Enumerable<LoyaltyTierScalarFieldEnum>
  }

  /**
   * LoyaltyTier findFirst
   */
  export interface LoyaltyTierFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LoyaltyTierFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LoyaltyTier findFirstOrThrow
   */
  export type LoyaltyTierFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTier
     */
    select?: LoyaltyTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTierInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTier to fetch.
     */
    where?: LoyaltyTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTiers to fetch.
     */
    orderBy?: Enumerable<LoyaltyTierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyTiers.
     */
    cursor?: LoyaltyTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyTiers.
     */
    distinct?: Enumerable<LoyaltyTierScalarFieldEnum>
  }


  /**
   * LoyaltyTier findMany
   */
  export type LoyaltyTierFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTier
     */
    select?: LoyaltyTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTierInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTiers to fetch.
     */
    where?: LoyaltyTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTiers to fetch.
     */
    orderBy?: Enumerable<LoyaltyTierOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoyaltyTiers.
     */
    cursor?: LoyaltyTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTiers.
     */
    skip?: number
    distinct?: Enumerable<LoyaltyTierScalarFieldEnum>
  }


  /**
   * LoyaltyTier create
   */
  export type LoyaltyTierCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTier
     */
    select?: LoyaltyTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTierInclude<ExtArgs> | null
    /**
     * The data needed to create a LoyaltyTier.
     */
    data: XOR<LoyaltyTierCreateInput, LoyaltyTierUncheckedCreateInput>
  }


  /**
   * LoyaltyTier createMany
   */
  export type LoyaltyTierCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoyaltyTiers.
     */
    data: Enumerable<LoyaltyTierCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LoyaltyTier update
   */
  export type LoyaltyTierUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTier
     */
    select?: LoyaltyTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTierInclude<ExtArgs> | null
    /**
     * The data needed to update a LoyaltyTier.
     */
    data: XOR<LoyaltyTierUpdateInput, LoyaltyTierUncheckedUpdateInput>
    /**
     * Choose, which LoyaltyTier to update.
     */
    where: LoyaltyTierWhereUniqueInput
  }


  /**
   * LoyaltyTier updateMany
   */
  export type LoyaltyTierUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoyaltyTiers.
     */
    data: XOR<LoyaltyTierUpdateManyMutationInput, LoyaltyTierUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyTiers to update
     */
    where?: LoyaltyTierWhereInput
  }


  /**
   * LoyaltyTier upsert
   */
  export type LoyaltyTierUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTier
     */
    select?: LoyaltyTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTierInclude<ExtArgs> | null
    /**
     * The filter to search for the LoyaltyTier to update in case it exists.
     */
    where: LoyaltyTierWhereUniqueInput
    /**
     * In case the LoyaltyTier found by the `where` argument doesn't exist, create a new LoyaltyTier with this data.
     */
    create: XOR<LoyaltyTierCreateInput, LoyaltyTierUncheckedCreateInput>
    /**
     * In case the LoyaltyTier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoyaltyTierUpdateInput, LoyaltyTierUncheckedUpdateInput>
  }


  /**
   * LoyaltyTier delete
   */
  export type LoyaltyTierDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTier
     */
    select?: LoyaltyTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTierInclude<ExtArgs> | null
    /**
     * Filter which LoyaltyTier to delete.
     */
    where: LoyaltyTierWhereUniqueInput
  }


  /**
   * LoyaltyTier deleteMany
   */
  export type LoyaltyTierDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyTiers to delete
     */
    where?: LoyaltyTierWhereInput
  }


  /**
   * LoyaltyTier.transactions
   */
  export type LoyaltyTier$transactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    where?: LoyaltyTransactionWhereInput
    orderBy?: Enumerable<LoyaltyTransactionOrderByWithRelationInput>
    cursor?: LoyaltyTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LoyaltyTransactionScalarFieldEnum>
  }


  /**
   * LoyaltyTier without action
   */
  export type LoyaltyTierArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTier
     */
    select?: LoyaltyTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTierInclude<ExtArgs> | null
  }



  /**
   * Model LoyaltyTransaction
   */


  export type AggregateLoyaltyTransaction = {
    _count: LoyaltyTransactionCountAggregateOutputType | null
    _avg: LoyaltyTransactionAvgAggregateOutputType | null
    _sum: LoyaltyTransactionSumAggregateOutputType | null
    _min: LoyaltyTransactionMinAggregateOutputType | null
    _max: LoyaltyTransactionMaxAggregateOutputType | null
  }

  export type LoyaltyTransactionAvgAggregateOutputType = {
    points: number | null
  }

  export type LoyaltyTransactionSumAggregateOutputType = {
    points: number | null
  }

  export type LoyaltyTransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tierId: string | null
    points: number | null
    type: TransactionType | null
    createdAt: Date | null
  }

  export type LoyaltyTransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tierId: string | null
    points: number | null
    type: TransactionType | null
    createdAt: Date | null
  }

  export type LoyaltyTransactionCountAggregateOutputType = {
    id: number
    userId: number
    tierId: number
    points: number
    type: number
    createdAt: number
    _all: number
  }


  export type LoyaltyTransactionAvgAggregateInputType = {
    points?: true
  }

  export type LoyaltyTransactionSumAggregateInputType = {
    points?: true
  }

  export type LoyaltyTransactionMinAggregateInputType = {
    id?: true
    userId?: true
    tierId?: true
    points?: true
    type?: true
    createdAt?: true
  }

  export type LoyaltyTransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    tierId?: true
    points?: true
    type?: true
    createdAt?: true
  }

  export type LoyaltyTransactionCountAggregateInputType = {
    id?: true
    userId?: true
    tierId?: true
    points?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type LoyaltyTransactionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyTransaction to aggregate.
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTransactions to fetch.
     */
    orderBy?: Enumerable<LoyaltyTransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoyaltyTransactions
    **/
    _count?: true | LoyaltyTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoyaltyTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoyaltyTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoyaltyTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoyaltyTransactionMaxAggregateInputType
  }

  export type GetLoyaltyTransactionAggregateType<T extends LoyaltyTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateLoyaltyTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoyaltyTransaction[P]>
      : GetScalarType<T[P], AggregateLoyaltyTransaction[P]>
  }




  export type LoyaltyTransactionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LoyaltyTransactionWhereInput
    orderBy?: Enumerable<LoyaltyTransactionOrderByWithAggregationInput>
    by: LoyaltyTransactionScalarFieldEnum[]
    having?: LoyaltyTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoyaltyTransactionCountAggregateInputType | true
    _avg?: LoyaltyTransactionAvgAggregateInputType
    _sum?: LoyaltyTransactionSumAggregateInputType
    _min?: LoyaltyTransactionMinAggregateInputType
    _max?: LoyaltyTransactionMaxAggregateInputType
  }


  export type LoyaltyTransactionGroupByOutputType = {
    id: string
    userId: string
    tierId: string | null
    points: number
    type: TransactionType
    createdAt: Date
    _count: LoyaltyTransactionCountAggregateOutputType | null
    _avg: LoyaltyTransactionAvgAggregateOutputType | null
    _sum: LoyaltyTransactionSumAggregateOutputType | null
    _min: LoyaltyTransactionMinAggregateOutputType | null
    _max: LoyaltyTransactionMaxAggregateOutputType | null
  }

  type GetLoyaltyTransactionGroupByPayload<T extends LoyaltyTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LoyaltyTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoyaltyTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoyaltyTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], LoyaltyTransactionGroupByOutputType[P]>
        }
      >
    >


  export type LoyaltyTransactionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tierId?: boolean
    points?: boolean
    type?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
    tier?: boolean | LoyaltyTierArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyTransaction"]>

  export type LoyaltyTransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    tierId?: boolean
    points?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type LoyaltyTransactionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    tier?: boolean | LoyaltyTierArgs<ExtArgs>
  }


  type LoyaltyTransactionGetPayload<S extends boolean | null | undefined | LoyaltyTransactionArgs> = $Types.GetResult<LoyaltyTransactionPayload, S>

  type LoyaltyTransactionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LoyaltyTransactionFindManyArgs, 'select' | 'include'> & {
      select?: LoyaltyTransactionCountAggregateInputType | true
    }

  export interface LoyaltyTransactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoyaltyTransaction'], meta: { name: 'LoyaltyTransaction' } }
    /**
     * Find zero or one LoyaltyTransaction that matches the filter.
     * @param {LoyaltyTransactionFindUniqueArgs} args - Arguments to find a LoyaltyTransaction
     * @example
     * // Get one LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LoyaltyTransactionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LoyaltyTransactionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LoyaltyTransaction'> extends True ? Prisma__LoyaltyTransactionClient<$Types.GetResult<LoyaltyTransactionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__LoyaltyTransactionClient<$Types.GetResult<LoyaltyTransactionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one LoyaltyTransaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LoyaltyTransactionFindUniqueOrThrowArgs} args - Arguments to find a LoyaltyTransaction
     * @example
     * // Get one LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LoyaltyTransactionClient<$Types.GetResult<LoyaltyTransactionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first LoyaltyTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionFindFirstArgs} args - Arguments to find a LoyaltyTransaction
     * @example
     * // Get one LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LoyaltyTransactionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LoyaltyTransactionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LoyaltyTransaction'> extends True ? Prisma__LoyaltyTransactionClient<$Types.GetResult<LoyaltyTransactionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__LoyaltyTransactionClient<$Types.GetResult<LoyaltyTransactionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first LoyaltyTransaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionFindFirstOrThrowArgs} args - Arguments to find a LoyaltyTransaction
     * @example
     * // Get one LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LoyaltyTransactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LoyaltyTransactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LoyaltyTransactionClient<$Types.GetResult<LoyaltyTransactionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more LoyaltyTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoyaltyTransactions
     * const loyaltyTransactions = await prisma.loyaltyTransaction.findMany()
     * 
     * // Get first 10 LoyaltyTransactions
     * const loyaltyTransactions = await prisma.loyaltyTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loyaltyTransactionWithIdOnly = await prisma.loyaltyTransaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LoyaltyTransactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoyaltyTransactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<LoyaltyTransactionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a LoyaltyTransaction.
     * @param {LoyaltyTransactionCreateArgs} args - Arguments to create a LoyaltyTransaction.
     * @example
     * // Create one LoyaltyTransaction
     * const LoyaltyTransaction = await prisma.loyaltyTransaction.create({
     *   data: {
     *     // ... data to create a LoyaltyTransaction
     *   }
     * })
     * 
    **/
    create<T extends LoyaltyTransactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LoyaltyTransactionCreateArgs<ExtArgs>>
    ): Prisma__LoyaltyTransactionClient<$Types.GetResult<LoyaltyTransactionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many LoyaltyTransactions.
     *     @param {LoyaltyTransactionCreateManyArgs} args - Arguments to create many LoyaltyTransactions.
     *     @example
     *     // Create many LoyaltyTransactions
     *     const loyaltyTransaction = await prisma.loyaltyTransaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LoyaltyTransactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoyaltyTransactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LoyaltyTransaction.
     * @param {LoyaltyTransactionDeleteArgs} args - Arguments to delete one LoyaltyTransaction.
     * @example
     * // Delete one LoyaltyTransaction
     * const LoyaltyTransaction = await prisma.loyaltyTransaction.delete({
     *   where: {
     *     // ... filter to delete one LoyaltyTransaction
     *   }
     * })
     * 
    **/
    delete<T extends LoyaltyTransactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LoyaltyTransactionDeleteArgs<ExtArgs>>
    ): Prisma__LoyaltyTransactionClient<$Types.GetResult<LoyaltyTransactionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one LoyaltyTransaction.
     * @param {LoyaltyTransactionUpdateArgs} args - Arguments to update one LoyaltyTransaction.
     * @example
     * // Update one LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LoyaltyTransactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LoyaltyTransactionUpdateArgs<ExtArgs>>
    ): Prisma__LoyaltyTransactionClient<$Types.GetResult<LoyaltyTransactionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more LoyaltyTransactions.
     * @param {LoyaltyTransactionDeleteManyArgs} args - Arguments to filter LoyaltyTransactions to delete.
     * @example
     * // Delete a few LoyaltyTransactions
     * const { count } = await prisma.loyaltyTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LoyaltyTransactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoyaltyTransactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoyaltyTransactions
     * const loyaltyTransaction = await prisma.loyaltyTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LoyaltyTransactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LoyaltyTransactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LoyaltyTransaction.
     * @param {LoyaltyTransactionUpsertArgs} args - Arguments to update or create a LoyaltyTransaction.
     * @example
     * // Update or create a LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.upsert({
     *   create: {
     *     // ... data to create a LoyaltyTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoyaltyTransaction we want to update
     *   }
     * })
    **/
    upsert<T extends LoyaltyTransactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LoyaltyTransactionUpsertArgs<ExtArgs>>
    ): Prisma__LoyaltyTransactionClient<$Types.GetResult<LoyaltyTransactionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of LoyaltyTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionCountArgs} args - Arguments to filter LoyaltyTransactions to count.
     * @example
     * // Count the number of LoyaltyTransactions
     * const count = await prisma.loyaltyTransaction.count({
     *   where: {
     *     // ... the filter for the LoyaltyTransactions we want to count
     *   }
     * })
    **/
    count<T extends LoyaltyTransactionCountArgs>(
      args?: Subset<T, LoyaltyTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoyaltyTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoyaltyTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoyaltyTransactionAggregateArgs>(args: Subset<T, LoyaltyTransactionAggregateArgs>): Prisma.PrismaPromise<GetLoyaltyTransactionAggregateType<T>>

    /**
     * Group by LoyaltyTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoyaltyTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoyaltyTransactionGroupByArgs['orderBy'] }
        : { orderBy?: LoyaltyTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoyaltyTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoyaltyTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LoyaltyTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LoyaltyTransactionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    tier<T extends LoyaltyTierArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyTierArgs<ExtArgs>>): Prisma__LoyaltyTierClient<$Types.GetResult<LoyaltyTierPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LoyaltyTransaction base type for findUnique actions
   */
  export type LoyaltyTransactionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTransaction to fetch.
     */
    where: LoyaltyTransactionWhereUniqueInput
  }

  /**
   * LoyaltyTransaction findUnique
   */
  export interface LoyaltyTransactionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LoyaltyTransactionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LoyaltyTransaction findUniqueOrThrow
   */
  export type LoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTransaction to fetch.
     */
    where: LoyaltyTransactionWhereUniqueInput
  }


  /**
   * LoyaltyTransaction base type for findFirst actions
   */
  export type LoyaltyTransactionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTransaction to fetch.
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTransactions to fetch.
     */
    orderBy?: Enumerable<LoyaltyTransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyTransactions.
     */
    cursor?: LoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyTransactions.
     */
    distinct?: Enumerable<LoyaltyTransactionScalarFieldEnum>
  }

  /**
   * LoyaltyTransaction findFirst
   */
  export interface LoyaltyTransactionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LoyaltyTransactionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LoyaltyTransaction findFirstOrThrow
   */
  export type LoyaltyTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTransaction to fetch.
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTransactions to fetch.
     */
    orderBy?: Enumerable<LoyaltyTransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyTransactions.
     */
    cursor?: LoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyTransactions.
     */
    distinct?: Enumerable<LoyaltyTransactionScalarFieldEnum>
  }


  /**
   * LoyaltyTransaction findMany
   */
  export type LoyaltyTransactionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTransactions to fetch.
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTransactions to fetch.
     */
    orderBy?: Enumerable<LoyaltyTransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoyaltyTransactions.
     */
    cursor?: LoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTransactions.
     */
    skip?: number
    distinct?: Enumerable<LoyaltyTransactionScalarFieldEnum>
  }


  /**
   * LoyaltyTransaction create
   */
  export type LoyaltyTransactionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a LoyaltyTransaction.
     */
    data: XOR<LoyaltyTransactionCreateInput, LoyaltyTransactionUncheckedCreateInput>
  }


  /**
   * LoyaltyTransaction createMany
   */
  export type LoyaltyTransactionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoyaltyTransactions.
     */
    data: Enumerable<LoyaltyTransactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LoyaltyTransaction update
   */
  export type LoyaltyTransactionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a LoyaltyTransaction.
     */
    data: XOR<LoyaltyTransactionUpdateInput, LoyaltyTransactionUncheckedUpdateInput>
    /**
     * Choose, which LoyaltyTransaction to update.
     */
    where: LoyaltyTransactionWhereUniqueInput
  }


  /**
   * LoyaltyTransaction updateMany
   */
  export type LoyaltyTransactionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoyaltyTransactions.
     */
    data: XOR<LoyaltyTransactionUpdateManyMutationInput, LoyaltyTransactionUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyTransactions to update
     */
    where?: LoyaltyTransactionWhereInput
  }


  /**
   * LoyaltyTransaction upsert
   */
  export type LoyaltyTransactionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the LoyaltyTransaction to update in case it exists.
     */
    where: LoyaltyTransactionWhereUniqueInput
    /**
     * In case the LoyaltyTransaction found by the `where` argument doesn't exist, create a new LoyaltyTransaction with this data.
     */
    create: XOR<LoyaltyTransactionCreateInput, LoyaltyTransactionUncheckedCreateInput>
    /**
     * In case the LoyaltyTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoyaltyTransactionUpdateInput, LoyaltyTransactionUncheckedUpdateInput>
  }


  /**
   * LoyaltyTransaction delete
   */
  export type LoyaltyTransactionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter which LoyaltyTransaction to delete.
     */
    where: LoyaltyTransactionWhereUniqueInput
  }


  /**
   * LoyaltyTransaction deleteMany
   */
  export type LoyaltyTransactionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyTransactions to delete
     */
    where?: LoyaltyTransactionWhereInput
  }


  /**
   * LoyaltyTransaction without action
   */
  export type LoyaltyTransactionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
  }



  /**
   * Model Subscription
   */


  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    stripeSubscriptionId: string | null
    priceId: string | null
    status: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    stripeSubscriptionId: string | null
    priceId: string | null
    status: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    stripeSubscriptionId: number
    priceId: number
    status: number
    currentPeriodStart: number
    currentPeriodEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    stripeSubscriptionId?: true
    priceId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    stripeSubscriptionId?: true
    priceId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    stripeSubscriptionId?: true
    priceId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: Enumerable<SubscriptionOrderByWithAggregationInput>
    by: SubscriptionScalarFieldEnum[]
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }


  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    stripeSubscriptionId: string
    priceId: string
    status: string
    currentPeriodStart: Date
    currentPeriodEnd: Date
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeSubscriptionId?: boolean
    priceId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    stripeSubscriptionId?: boolean
    priceId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionArgs> = $Types.GetResult<SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubscriptionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Subscription'> extends True ? Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubscriptionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Subscription'> extends True ? Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubscriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
    **/
    create<T extends SubscriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Subscriptions.
     *     @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     *     @example
     *     // Create many Subscriptions
     *     const subscription = await prisma.subscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubscriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
    **/
    delete<T extends SubscriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubscriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubscriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubscriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
    **/
    upsert<T extends SubscriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Subscription base type for findUnique actions
   */
  export type SubscriptionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUnique
   */
  export interface SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SubscriptionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription base type for findFirst actions
   */
  export type SubscriptionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }

  /**
   * Subscription findFirst
   */
  export interface SubscriptionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SubscriptionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }


  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }


  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }


  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: Enumerable<SubscriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }


  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription without action
   */
  export type SubscriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }



  /**
   * Model AnalyticsEvent
   */


  export type AggregateAnalyticsEvent = {
    _count: AnalyticsEventCountAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  export type AnalyticsEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    event: string | null
    createdAt: Date | null
  }

  export type AnalyticsEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    event: string | null
    createdAt: Date | null
  }

  export type AnalyticsEventCountAggregateOutputType = {
    id: number
    userId: number
    event: number
    properties: number
    createdAt: number
    _all: number
  }


  export type AnalyticsEventMinAggregateInputType = {
    id?: true
    userId?: true
    event?: true
    createdAt?: true
  }

  export type AnalyticsEventMaxAggregateInputType = {
    id?: true
    userId?: true
    event?: true
    createdAt?: true
  }

  export type AnalyticsEventCountAggregateInputType = {
    id?: true
    userId?: true
    event?: true
    properties?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticsEventAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvent to aggregate.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: Enumerable<AnalyticsEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsEvents
    **/
    _count?: true | AnalyticsEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type GetAnalyticsEventAggregateType<T extends AnalyticsEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
      : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
  }




  export type AnalyticsEventGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AnalyticsEventWhereInput
    orderBy?: Enumerable<AnalyticsEventOrderByWithAggregationInput>
    by: AnalyticsEventScalarFieldEnum[]
    having?: AnalyticsEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsEventCountAggregateInputType | true
    _min?: AnalyticsEventMinAggregateInputType
    _max?: AnalyticsEventMaxAggregateInputType
  }


  export type AnalyticsEventGroupByOutputType = {
    id: string
    userId: string | null
    event: string
    properties: JsonValue | null
    createdAt: Date
    _count: AnalyticsEventCountAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  type GetAnalyticsEventGroupByPayload<T extends AnalyticsEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AnalyticsEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsEventSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    event?: boolean
    properties?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectScalar = {
    id?: boolean
    userId?: boolean
    event?: boolean
    properties?: boolean
    createdAt?: boolean
  }

  export type AnalyticsEventInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type AnalyticsEventGetPayload<S extends boolean | null | undefined | AnalyticsEventArgs> = $Types.GetResult<AnalyticsEventPayload, S>

  type AnalyticsEventCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AnalyticsEventFindManyArgs, 'select' | 'include'> & {
      select?: AnalyticsEventCountAggregateInputType | true
    }

  export interface AnalyticsEventDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsEvent'], meta: { name: 'AnalyticsEvent' } }
    /**
     * Find zero or one AnalyticsEvent that matches the filter.
     * @param {AnalyticsEventFindUniqueArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AnalyticsEventFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AnalyticsEventFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AnalyticsEvent'> extends True ? Prisma__AnalyticsEventClient<$Types.GetResult<AnalyticsEventPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AnalyticsEventClient<$Types.GetResult<AnalyticsEventPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one AnalyticsEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AnalyticsEventFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AnalyticsEventClient<$Types.GetResult<AnalyticsEventPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first AnalyticsEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AnalyticsEventFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AnalyticsEventFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AnalyticsEvent'> extends True ? Prisma__AnalyticsEventClient<$Types.GetResult<AnalyticsEventPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AnalyticsEventClient<$Types.GetResult<AnalyticsEventPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first AnalyticsEvent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AnalyticsEventFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnalyticsEventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AnalyticsEventClient<$Types.GetResult<AnalyticsEventPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more AnalyticsEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany()
     * 
     * // Get first 10 AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AnalyticsEventFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnalyticsEventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AnalyticsEventPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a AnalyticsEvent.
     * @param {AnalyticsEventCreateArgs} args - Arguments to create a AnalyticsEvent.
     * @example
     * // Create one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.create({
     *   data: {
     *     // ... data to create a AnalyticsEvent
     *   }
     * })
     * 
    **/
    create<T extends AnalyticsEventCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AnalyticsEventCreateArgs<ExtArgs>>
    ): Prisma__AnalyticsEventClient<$Types.GetResult<AnalyticsEventPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many AnalyticsEvents.
     *     @param {AnalyticsEventCreateManyArgs} args - Arguments to create many AnalyticsEvents.
     *     @example
     *     // Create many AnalyticsEvents
     *     const analyticsEvent = await prisma.analyticsEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AnalyticsEventCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnalyticsEventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AnalyticsEvent.
     * @param {AnalyticsEventDeleteArgs} args - Arguments to delete one AnalyticsEvent.
     * @example
     * // Delete one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsEvent
     *   }
     * })
     * 
    **/
    delete<T extends AnalyticsEventDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AnalyticsEventDeleteArgs<ExtArgs>>
    ): Prisma__AnalyticsEventClient<$Types.GetResult<AnalyticsEventPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one AnalyticsEvent.
     * @param {AnalyticsEventUpdateArgs} args - Arguments to update one AnalyticsEvent.
     * @example
     * // Update one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AnalyticsEventUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AnalyticsEventUpdateArgs<ExtArgs>>
    ): Prisma__AnalyticsEventClient<$Types.GetResult<AnalyticsEventPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more AnalyticsEvents.
     * @param {AnalyticsEventDeleteManyArgs} args - Arguments to filter AnalyticsEvents to delete.
     * @example
     * // Delete a few AnalyticsEvents
     * const { count } = await prisma.analyticsEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AnalyticsEventDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnalyticsEventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AnalyticsEventUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AnalyticsEventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnalyticsEvent.
     * @param {AnalyticsEventUpsertArgs} args - Arguments to update or create a AnalyticsEvent.
     * @example
     * // Update or create a AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.upsert({
     *   create: {
     *     // ... data to create a AnalyticsEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsEvent we want to update
     *   }
     * })
    **/
    upsert<T extends AnalyticsEventUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AnalyticsEventUpsertArgs<ExtArgs>>
    ): Prisma__AnalyticsEventClient<$Types.GetResult<AnalyticsEventPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventCountArgs} args - Arguments to filter AnalyticsEvents to count.
     * @example
     * // Count the number of AnalyticsEvents
     * const count = await prisma.analyticsEvent.count({
     *   where: {
     *     // ... the filter for the AnalyticsEvents we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsEventCountArgs>(
      args?: Subset<T, AnalyticsEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsEventAggregateArgs>(args: Subset<T, AnalyticsEventAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsEventAggregateType<T>>

    /**
     * Group by AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsEventGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AnalyticsEventClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AnalyticsEvent base type for findUnique actions
   */
  export type AnalyticsEventFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findUnique
   */
  export interface AnalyticsEventFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AnalyticsEventFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AnalyticsEvent findUniqueOrThrow
   */
  export type AnalyticsEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }


  /**
   * AnalyticsEvent base type for findFirst actions
   */
  export type AnalyticsEventFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: Enumerable<AnalyticsEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: Enumerable<AnalyticsEventScalarFieldEnum>
  }

  /**
   * AnalyticsEvent findFirst
   */
  export interface AnalyticsEventFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AnalyticsEventFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AnalyticsEvent findFirstOrThrow
   */
  export type AnalyticsEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: Enumerable<AnalyticsEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: Enumerable<AnalyticsEventScalarFieldEnum>
  }


  /**
   * AnalyticsEvent findMany
   */
  export type AnalyticsEventFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvents to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: Enumerable<AnalyticsEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    distinct?: Enumerable<AnalyticsEventScalarFieldEnum>
  }


  /**
   * AnalyticsEvent create
   */
  export type AnalyticsEventCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
  }


  /**
   * AnalyticsEvent createMany
   */
  export type AnalyticsEventCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: Enumerable<AnalyticsEventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AnalyticsEvent update
   */
  export type AnalyticsEventUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsEvent to update.
     */
    where: AnalyticsEventWhereUniqueInput
  }


  /**
   * AnalyticsEvent updateMany
   */
  export type AnalyticsEventUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsEvents.
     */
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEvents to update
     */
    where?: AnalyticsEventWhereInput
  }


  /**
   * AnalyticsEvent upsert
   */
  export type AnalyticsEventUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsEvent to update in case it exists.
     */
    where: AnalyticsEventWhereUniqueInput
    /**
     * In case the AnalyticsEvent found by the `where` argument doesn't exist, create a new AnalyticsEvent with this data.
     */
    create: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
    /**
     * In case the AnalyticsEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
  }


  /**
   * AnalyticsEvent delete
   */
  export type AnalyticsEventDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter which AnalyticsEvent to delete.
     */
    where: AnalyticsEventWhereUniqueInput
  }


  /**
   * AnalyticsEvent deleteMany
   */
  export type AnalyticsEventDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvents to delete
     */
    where?: AnalyticsEventWhereInput
  }


  /**
   * AnalyticsEvent without action
   */
  export type AnalyticsEventArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
  }



  /**
   * Model PaymentTransaction
   */


  export type AggregatePaymentTransaction = {
    _count: PaymentTransactionCountAggregateOutputType | null
    _avg: PaymentTransactionAvgAggregateOutputType | null
    _sum: PaymentTransactionSumAggregateOutputType | null
    _min: PaymentTransactionMinAggregateOutputType | null
    _max: PaymentTransactionMaxAggregateOutputType | null
  }

  export type PaymentTransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentTransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentTransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    mode: string | null
    createdAt: Date | null
    serviceId: string | null
  }

  export type PaymentTransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    mode: string | null
    createdAt: Date | null
    serviceId: string | null
  }

  export type PaymentTransactionCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    currency: number
    mode: number
    createdAt: number
    serviceId: number
    _all: number
  }


  export type PaymentTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentTransactionSumAggregateInputType = {
    amount?: true
  }

  export type PaymentTransactionMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    mode?: true
    createdAt?: true
    serviceId?: true
  }

  export type PaymentTransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    mode?: true
    createdAt?: true
    serviceId?: true
  }

  export type PaymentTransactionCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    mode?: true
    createdAt?: true
    serviceId?: true
    _all?: true
  }

  export type PaymentTransactionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTransaction to aggregate.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: Enumerable<PaymentTransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentTransactions
    **/
    _count?: true | PaymentTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentTransactionMaxAggregateInputType
  }

  export type GetPaymentTransactionAggregateType<T extends PaymentTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentTransaction[P]>
      : GetScalarType<T[P], AggregatePaymentTransaction[P]>
  }




  export type PaymentTransactionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
    orderBy?: Enumerable<PaymentTransactionOrderByWithAggregationInput>
    by: PaymentTransactionScalarFieldEnum[]
    having?: PaymentTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentTransactionCountAggregateInputType | true
    _avg?: PaymentTransactionAvgAggregateInputType
    _sum?: PaymentTransactionSumAggregateInputType
    _min?: PaymentTransactionMinAggregateInputType
    _max?: PaymentTransactionMaxAggregateInputType
  }


  export type PaymentTransactionGroupByOutputType = {
    id: string
    userId: string
    amount: number
    currency: string
    mode: string
    createdAt: Date
    serviceId: string | null
    _count: PaymentTransactionCountAggregateOutputType | null
    _avg: PaymentTransactionAvgAggregateOutputType | null
    _sum: PaymentTransactionSumAggregateOutputType | null
    _min: PaymentTransactionMinAggregateOutputType | null
    _max: PaymentTransactionMaxAggregateOutputType | null
  }

  type GetPaymentTransactionGroupByPayload<T extends PaymentTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PaymentTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentTransactionGroupByOutputType[P]>
        }
      >
    >


  export type PaymentTransactionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    mode?: boolean
    createdAt?: boolean
    serviceId?: boolean
    user?: boolean | UserArgs<ExtArgs>
    service?: boolean | ServiceArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    mode?: boolean
    createdAt?: boolean
    serviceId?: boolean
  }

  export type PaymentTransactionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    service?: boolean | ServiceArgs<ExtArgs>
  }


  type PaymentTransactionGetPayload<S extends boolean | null | undefined | PaymentTransactionArgs> = $Types.GetResult<PaymentTransactionPayload, S>

  type PaymentTransactionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PaymentTransactionFindManyArgs, 'select' | 'include'> & {
      select?: PaymentTransactionCountAggregateInputType | true
    }

  export interface PaymentTransactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentTransaction'], meta: { name: 'PaymentTransaction' } }
    /**
     * Find zero or one PaymentTransaction that matches the filter.
     * @param {PaymentTransactionFindUniqueArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentTransactionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentTransactionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PaymentTransaction'> extends True ? Prisma__PaymentTransactionClient<$Types.GetResult<PaymentTransactionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PaymentTransactionClient<$Types.GetResult<PaymentTransactionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one PaymentTransaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PaymentTransactionFindUniqueOrThrowArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentTransactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentTransactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentTransactionClient<$Types.GetResult<PaymentTransactionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first PaymentTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindFirstArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentTransactionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentTransactionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PaymentTransaction'> extends True ? Prisma__PaymentTransactionClient<$Types.GetResult<PaymentTransactionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PaymentTransactionClient<$Types.GetResult<PaymentTransactionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first PaymentTransaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindFirstOrThrowArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentTransactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentTransactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentTransactionClient<$Types.GetResult<PaymentTransactionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more PaymentTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentTransactions
     * const paymentTransactions = await prisma.paymentTransaction.findMany()
     * 
     * // Get first 10 PaymentTransactions
     * const paymentTransactions = await prisma.paymentTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentTransactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentTransactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PaymentTransactionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a PaymentTransaction.
     * @param {PaymentTransactionCreateArgs} args - Arguments to create a PaymentTransaction.
     * @example
     * // Create one PaymentTransaction
     * const PaymentTransaction = await prisma.paymentTransaction.create({
     *   data: {
     *     // ... data to create a PaymentTransaction
     *   }
     * })
     * 
    **/
    create<T extends PaymentTransactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentTransactionCreateArgs<ExtArgs>>
    ): Prisma__PaymentTransactionClient<$Types.GetResult<PaymentTransactionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many PaymentTransactions.
     *     @param {PaymentTransactionCreateManyArgs} args - Arguments to create many PaymentTransactions.
     *     @example
     *     // Create many PaymentTransactions
     *     const paymentTransaction = await prisma.paymentTransaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentTransactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentTransactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentTransaction.
     * @param {PaymentTransactionDeleteArgs} args - Arguments to delete one PaymentTransaction.
     * @example
     * // Delete one PaymentTransaction
     * const PaymentTransaction = await prisma.paymentTransaction.delete({
     *   where: {
     *     // ... filter to delete one PaymentTransaction
     *   }
     * })
     * 
    **/
    delete<T extends PaymentTransactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentTransactionDeleteArgs<ExtArgs>>
    ): Prisma__PaymentTransactionClient<$Types.GetResult<PaymentTransactionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one PaymentTransaction.
     * @param {PaymentTransactionUpdateArgs} args - Arguments to update one PaymentTransaction.
     * @example
     * // Update one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentTransactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentTransactionUpdateArgs<ExtArgs>>
    ): Prisma__PaymentTransactionClient<$Types.GetResult<PaymentTransactionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more PaymentTransactions.
     * @param {PaymentTransactionDeleteManyArgs} args - Arguments to filter PaymentTransactions to delete.
     * @example
     * // Delete a few PaymentTransactions
     * const { count } = await prisma.paymentTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentTransactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentTransactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentTransactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentTransactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentTransaction.
     * @param {PaymentTransactionUpsertArgs} args - Arguments to update or create a PaymentTransaction.
     * @example
     * // Update or create a PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.upsert({
     *   create: {
     *     // ... data to create a PaymentTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentTransaction we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentTransactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentTransactionUpsertArgs<ExtArgs>>
    ): Prisma__PaymentTransactionClient<$Types.GetResult<PaymentTransactionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of PaymentTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionCountArgs} args - Arguments to filter PaymentTransactions to count.
     * @example
     * // Count the number of PaymentTransactions
     * const count = await prisma.paymentTransaction.count({
     *   where: {
     *     // ... the filter for the PaymentTransactions we want to count
     *   }
     * })
    **/
    count<T extends PaymentTransactionCountArgs>(
      args?: Subset<T, PaymentTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentTransactionAggregateArgs>(args: Subset<T, PaymentTransactionAggregateArgs>): Prisma.PrismaPromise<GetPaymentTransactionAggregateType<T>>

    /**
     * Group by PaymentTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentTransactionGroupByArgs['orderBy'] }
        : { orderBy?: PaymentTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentTransactionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    service<T extends ServiceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceArgs<ExtArgs>>): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PaymentTransaction base type for findUnique actions
   */
  export type PaymentTransactionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction findUnique
   */
  export interface PaymentTransactionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PaymentTransactionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PaymentTransaction findUniqueOrThrow
   */
  export type PaymentTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where: PaymentTransactionWhereUniqueInput
  }


  /**
   * PaymentTransaction base type for findFirst actions
   */
  export type PaymentTransactionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: Enumerable<PaymentTransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTransactions.
     */
    distinct?: Enumerable<PaymentTransactionScalarFieldEnum>
  }

  /**
   * PaymentTransaction findFirst
   */
  export interface PaymentTransactionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PaymentTransactionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PaymentTransaction findFirstOrThrow
   */
  export type PaymentTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: Enumerable<PaymentTransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTransactions.
     */
    distinct?: Enumerable<PaymentTransactionScalarFieldEnum>
  }


  /**
   * PaymentTransaction findMany
   */
  export type PaymentTransactionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransactions to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: Enumerable<PaymentTransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    distinct?: Enumerable<PaymentTransactionScalarFieldEnum>
  }


  /**
   * PaymentTransaction create
   */
  export type PaymentTransactionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentTransaction.
     */
    data: XOR<PaymentTransactionCreateInput, PaymentTransactionUncheckedCreateInput>
  }


  /**
   * PaymentTransaction createMany
   */
  export type PaymentTransactionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentTransactions.
     */
    data: Enumerable<PaymentTransactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PaymentTransaction update
   */
  export type PaymentTransactionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentTransaction.
     */
    data: XOR<PaymentTransactionUpdateInput, PaymentTransactionUncheckedUpdateInput>
    /**
     * Choose, which PaymentTransaction to update.
     */
    where: PaymentTransactionWhereUniqueInput
  }


  /**
   * PaymentTransaction updateMany
   */
  export type PaymentTransactionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentTransactions.
     */
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTransactions to update
     */
    where?: PaymentTransactionWhereInput
  }


  /**
   * PaymentTransaction upsert
   */
  export type PaymentTransactionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentTransaction to update in case it exists.
     */
    where: PaymentTransactionWhereUniqueInput
    /**
     * In case the PaymentTransaction found by the `where` argument doesn't exist, create a new PaymentTransaction with this data.
     */
    create: XOR<PaymentTransactionCreateInput, PaymentTransactionUncheckedCreateInput>
    /**
     * In case the PaymentTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentTransactionUpdateInput, PaymentTransactionUncheckedUpdateInput>
  }


  /**
   * PaymentTransaction delete
   */
  export type PaymentTransactionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter which PaymentTransaction to delete.
     */
    where: PaymentTransactionWhereUniqueInput
  }


  /**
   * PaymentTransaction deleteMany
   */
  export type PaymentTransactionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTransactions to delete
     */
    where?: PaymentTransactionWhereInput
  }


  /**
   * PaymentTransaction without action
   */
  export type PaymentTransactionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
  }



  /**
   * Model PromotionCode
   */


  export type AggregatePromotionCode = {
    _count: PromotionCodeCountAggregateOutputType | null
    _avg: PromotionCodeAvgAggregateOutputType | null
    _sum: PromotionCodeSumAggregateOutputType | null
    _min: PromotionCodeMinAggregateOutputType | null
    _max: PromotionCodeMaxAggregateOutputType | null
  }

  export type PromotionCodeAvgAggregateOutputType = {
    discount: number | null
  }

  export type PromotionCodeSumAggregateOutputType = {
    discount: number | null
  }

  export type PromotionCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    discount: number | null
    validFrom: Date | null
    validTo: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    discount: number | null
    validFrom: Date | null
    validTo: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionCodeCountAggregateOutputType = {
    id: number
    code: number
    description: number
    discount: number
    validFrom: number
    validTo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromotionCodeAvgAggregateInputType = {
    discount?: true
  }

  export type PromotionCodeSumAggregateInputType = {
    discount?: true
  }

  export type PromotionCodeMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discount?: true
    validFrom?: true
    validTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionCodeMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discount?: true
    validFrom?: true
    validTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionCodeCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discount?: true
    validFrom?: true
    validTo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromotionCodeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionCode to aggregate.
     */
    where?: PromotionCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionCodes to fetch.
     */
    orderBy?: Enumerable<PromotionCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromotionCodes
    **/
    _count?: true | PromotionCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionCodeMaxAggregateInputType
  }

  export type GetPromotionCodeAggregateType<T extends PromotionCodeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotionCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotionCode[P]>
      : GetScalarType<T[P], AggregatePromotionCode[P]>
  }




  export type PromotionCodeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PromotionCodeWhereInput
    orderBy?: Enumerable<PromotionCodeOrderByWithAggregationInput>
    by: PromotionCodeScalarFieldEnum[]
    having?: PromotionCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCodeCountAggregateInputType | true
    _avg?: PromotionCodeAvgAggregateInputType
    _sum?: PromotionCodeSumAggregateInputType
    _min?: PromotionCodeMinAggregateInputType
    _max?: PromotionCodeMaxAggregateInputType
  }


  export type PromotionCodeGroupByOutputType = {
    id: string
    code: string
    description: string | null
    discount: number
    validFrom: Date
    validTo: Date
    createdAt: Date
    updatedAt: Date
    _count: PromotionCodeCountAggregateOutputType | null
    _avg: PromotionCodeAvgAggregateOutputType | null
    _sum: PromotionCodeSumAggregateOutputType | null
    _min: PromotionCodeMinAggregateOutputType | null
    _max: PromotionCodeMaxAggregateOutputType | null
  }

  type GetPromotionCodeGroupByPayload<T extends PromotionCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PromotionCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionCodeGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionCodeGroupByOutputType[P]>
        }
      >
    >


  export type PromotionCodeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discount?: boolean
    validFrom?: boolean
    validTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promotionCode"]>

  export type PromotionCodeSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    discount?: boolean
    validFrom?: boolean
    validTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type PromotionCodeGetPayload<S extends boolean | null | undefined | PromotionCodeArgs> = $Types.GetResult<PromotionCodePayload, S>

  type PromotionCodeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PromotionCodeFindManyArgs, 'select' | 'include'> & {
      select?: PromotionCodeCountAggregateInputType | true
    }

  export interface PromotionCodeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromotionCode'], meta: { name: 'PromotionCode' } }
    /**
     * Find zero or one PromotionCode that matches the filter.
     * @param {PromotionCodeFindUniqueArgs} args - Arguments to find a PromotionCode
     * @example
     * // Get one PromotionCode
     * const promotionCode = await prisma.promotionCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PromotionCodeFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PromotionCodeFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PromotionCode'> extends True ? Prisma__PromotionCodeClient<$Types.GetResult<PromotionCodePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PromotionCodeClient<$Types.GetResult<PromotionCodePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one PromotionCode that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PromotionCodeFindUniqueOrThrowArgs} args - Arguments to find a PromotionCode
     * @example
     * // Get one PromotionCode
     * const promotionCode = await prisma.promotionCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PromotionCodeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionCodeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PromotionCodeClient<$Types.GetResult<PromotionCodePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first PromotionCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCodeFindFirstArgs} args - Arguments to find a PromotionCode
     * @example
     * // Get one PromotionCode
     * const promotionCode = await prisma.promotionCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PromotionCodeFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PromotionCodeFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PromotionCode'> extends True ? Prisma__PromotionCodeClient<$Types.GetResult<PromotionCodePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PromotionCodeClient<$Types.GetResult<PromotionCodePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first PromotionCode that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCodeFindFirstOrThrowArgs} args - Arguments to find a PromotionCode
     * @example
     * // Get one PromotionCode
     * const promotionCode = await prisma.promotionCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PromotionCodeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionCodeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PromotionCodeClient<$Types.GetResult<PromotionCodePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more PromotionCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCodeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromotionCodes
     * const promotionCodes = await prisma.promotionCode.findMany()
     * 
     * // Get first 10 PromotionCodes
     * const promotionCodes = await prisma.promotionCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionCodeWithIdOnly = await prisma.promotionCode.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PromotionCodeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionCodeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PromotionCodePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a PromotionCode.
     * @param {PromotionCodeCreateArgs} args - Arguments to create a PromotionCode.
     * @example
     * // Create one PromotionCode
     * const PromotionCode = await prisma.promotionCode.create({
     *   data: {
     *     // ... data to create a PromotionCode
     *   }
     * })
     * 
    **/
    create<T extends PromotionCodeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionCodeCreateArgs<ExtArgs>>
    ): Prisma__PromotionCodeClient<$Types.GetResult<PromotionCodePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many PromotionCodes.
     *     @param {PromotionCodeCreateManyArgs} args - Arguments to create many PromotionCodes.
     *     @example
     *     // Create many PromotionCodes
     *     const promotionCode = await prisma.promotionCode.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PromotionCodeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionCodeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PromotionCode.
     * @param {PromotionCodeDeleteArgs} args - Arguments to delete one PromotionCode.
     * @example
     * // Delete one PromotionCode
     * const PromotionCode = await prisma.promotionCode.delete({
     *   where: {
     *     // ... filter to delete one PromotionCode
     *   }
     * })
     * 
    **/
    delete<T extends PromotionCodeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionCodeDeleteArgs<ExtArgs>>
    ): Prisma__PromotionCodeClient<$Types.GetResult<PromotionCodePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one PromotionCode.
     * @param {PromotionCodeUpdateArgs} args - Arguments to update one PromotionCode.
     * @example
     * // Update one PromotionCode
     * const promotionCode = await prisma.promotionCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PromotionCodeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionCodeUpdateArgs<ExtArgs>>
    ): Prisma__PromotionCodeClient<$Types.GetResult<PromotionCodePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more PromotionCodes.
     * @param {PromotionCodeDeleteManyArgs} args - Arguments to filter PromotionCodes to delete.
     * @example
     * // Delete a few PromotionCodes
     * const { count } = await prisma.promotionCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PromotionCodeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromotionCodeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromotionCodes
     * const promotionCode = await prisma.promotionCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PromotionCodeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionCodeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromotionCode.
     * @param {PromotionCodeUpsertArgs} args - Arguments to update or create a PromotionCode.
     * @example
     * // Update or create a PromotionCode
     * const promotionCode = await prisma.promotionCode.upsert({
     *   create: {
     *     // ... data to create a PromotionCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromotionCode we want to update
     *   }
     * })
    **/
    upsert<T extends PromotionCodeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PromotionCodeUpsertArgs<ExtArgs>>
    ): Prisma__PromotionCodeClient<$Types.GetResult<PromotionCodePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of PromotionCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCodeCountArgs} args - Arguments to filter PromotionCodes to count.
     * @example
     * // Count the number of PromotionCodes
     * const count = await prisma.promotionCode.count({
     *   where: {
     *     // ... the filter for the PromotionCodes we want to count
     *   }
     * })
    **/
    count<T extends PromotionCodeCountArgs>(
      args?: Subset<T, PromotionCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromotionCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionCodeAggregateArgs>(args: Subset<T, PromotionCodeAggregateArgs>): Prisma.PrismaPromise<GetPromotionCodeAggregateType<T>>

    /**
     * Group by PromotionCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionCodeGroupByArgs['orderBy'] }
        : { orderBy?: PromotionCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PromotionCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PromotionCodeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PromotionCode base type for findUnique actions
   */
  export type PromotionCodeFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCode
     */
    select?: PromotionCodeSelect<ExtArgs> | null
    /**
     * Filter, which PromotionCode to fetch.
     */
    where: PromotionCodeWhereUniqueInput
  }

  /**
   * PromotionCode findUnique
   */
  export interface PromotionCodeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PromotionCodeFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PromotionCode findUniqueOrThrow
   */
  export type PromotionCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCode
     */
    select?: PromotionCodeSelect<ExtArgs> | null
    /**
     * Filter, which PromotionCode to fetch.
     */
    where: PromotionCodeWhereUniqueInput
  }


  /**
   * PromotionCode base type for findFirst actions
   */
  export type PromotionCodeFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCode
     */
    select?: PromotionCodeSelect<ExtArgs> | null
    /**
     * Filter, which PromotionCode to fetch.
     */
    where?: PromotionCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionCodes to fetch.
     */
    orderBy?: Enumerable<PromotionCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionCodes.
     */
    cursor?: PromotionCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionCodes.
     */
    distinct?: Enumerable<PromotionCodeScalarFieldEnum>
  }

  /**
   * PromotionCode findFirst
   */
  export interface PromotionCodeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PromotionCodeFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PromotionCode findFirstOrThrow
   */
  export type PromotionCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCode
     */
    select?: PromotionCodeSelect<ExtArgs> | null
    /**
     * Filter, which PromotionCode to fetch.
     */
    where?: PromotionCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionCodes to fetch.
     */
    orderBy?: Enumerable<PromotionCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionCodes.
     */
    cursor?: PromotionCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionCodes.
     */
    distinct?: Enumerable<PromotionCodeScalarFieldEnum>
  }


  /**
   * PromotionCode findMany
   */
  export type PromotionCodeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCode
     */
    select?: PromotionCodeSelect<ExtArgs> | null
    /**
     * Filter, which PromotionCodes to fetch.
     */
    where?: PromotionCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionCodes to fetch.
     */
    orderBy?: Enumerable<PromotionCodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromotionCodes.
     */
    cursor?: PromotionCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionCodes.
     */
    skip?: number
    distinct?: Enumerable<PromotionCodeScalarFieldEnum>
  }


  /**
   * PromotionCode create
   */
  export type PromotionCodeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCode
     */
    select?: PromotionCodeSelect<ExtArgs> | null
    /**
     * The data needed to create a PromotionCode.
     */
    data: XOR<PromotionCodeCreateInput, PromotionCodeUncheckedCreateInput>
  }


  /**
   * PromotionCode createMany
   */
  export type PromotionCodeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromotionCodes.
     */
    data: Enumerable<PromotionCodeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PromotionCode update
   */
  export type PromotionCodeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCode
     */
    select?: PromotionCodeSelect<ExtArgs> | null
    /**
     * The data needed to update a PromotionCode.
     */
    data: XOR<PromotionCodeUpdateInput, PromotionCodeUncheckedUpdateInput>
    /**
     * Choose, which PromotionCode to update.
     */
    where: PromotionCodeWhereUniqueInput
  }


  /**
   * PromotionCode updateMany
   */
  export type PromotionCodeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromotionCodes.
     */
    data: XOR<PromotionCodeUpdateManyMutationInput, PromotionCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromotionCodes to update
     */
    where?: PromotionCodeWhereInput
  }


  /**
   * PromotionCode upsert
   */
  export type PromotionCodeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCode
     */
    select?: PromotionCodeSelect<ExtArgs> | null
    /**
     * The filter to search for the PromotionCode to update in case it exists.
     */
    where: PromotionCodeWhereUniqueInput
    /**
     * In case the PromotionCode found by the `where` argument doesn't exist, create a new PromotionCode with this data.
     */
    create: XOR<PromotionCodeCreateInput, PromotionCodeUncheckedCreateInput>
    /**
     * In case the PromotionCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionCodeUpdateInput, PromotionCodeUncheckedUpdateInput>
  }


  /**
   * PromotionCode delete
   */
  export type PromotionCodeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCode
     */
    select?: PromotionCodeSelect<ExtArgs> | null
    /**
     * Filter which PromotionCode to delete.
     */
    where: PromotionCodeWhereUniqueInput
  }


  /**
   * PromotionCode deleteMany
   */
  export type PromotionCodeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionCodes to delete
     */
    where?: PromotionCodeWhereInput
  }


  /**
   * PromotionCode without action
   */
  export type PromotionCodeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCode
     */
    select?: PromotionCodeSelect<ExtArgs> | null
  }



  /**
   * Model EmailCampaign
   */


  export type AggregateEmailCampaign = {
    _count: EmailCampaignCountAggregateOutputType | null
    _min: EmailCampaignMinAggregateOutputType | null
    _max: EmailCampaignMaxAggregateOutputType | null
  }

  export type EmailCampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    body: string | null
    scheduledAt: Date | null
    sent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailCampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    body: string | null
    scheduledAt: Date | null
    sent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailCampaignCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    body: number
    scheduledAt: number
    sent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailCampaignMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    scheduledAt?: true
    sent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailCampaignMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    scheduledAt?: true
    sent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailCampaignCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    body?: true
    scheduledAt?: true
    sent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailCampaignAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailCampaign to aggregate.
     */
    where?: EmailCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaigns to fetch.
     */
    orderBy?: Enumerable<EmailCampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailCampaigns
    **/
    _count?: true | EmailCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailCampaignMaxAggregateInputType
  }

  export type GetEmailCampaignAggregateType<T extends EmailCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailCampaign[P]>
      : GetScalarType<T[P], AggregateEmailCampaign[P]>
  }




  export type EmailCampaignGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EmailCampaignWhereInput
    orderBy?: Enumerable<EmailCampaignOrderByWithAggregationInput>
    by: EmailCampaignScalarFieldEnum[]
    having?: EmailCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailCampaignCountAggregateInputType | true
    _min?: EmailCampaignMinAggregateInputType
    _max?: EmailCampaignMaxAggregateInputType
  }


  export type EmailCampaignGroupByOutputType = {
    id: string
    name: string
    subject: string
    body: string
    scheduledAt: Date | null
    sent: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmailCampaignCountAggregateOutputType | null
    _min: EmailCampaignMinAggregateOutputType | null
    _max: EmailCampaignMaxAggregateOutputType | null
  }

  type GetEmailCampaignGroupByPayload<T extends EmailCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EmailCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], EmailCampaignGroupByOutputType[P]>
        }
      >
    >


  export type EmailCampaignSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    scheduledAt?: boolean
    sent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailCampaign"]>

  export type EmailCampaignSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    body?: boolean
    scheduledAt?: boolean
    sent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type EmailCampaignGetPayload<S extends boolean | null | undefined | EmailCampaignArgs> = $Types.GetResult<EmailCampaignPayload, S>

  type EmailCampaignCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<EmailCampaignFindManyArgs, 'select' | 'include'> & {
      select?: EmailCampaignCountAggregateInputType | true
    }

  export interface EmailCampaignDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailCampaign'], meta: { name: 'EmailCampaign' } }
    /**
     * Find zero or one EmailCampaign that matches the filter.
     * @param {EmailCampaignFindUniqueArgs} args - Arguments to find a EmailCampaign
     * @example
     * // Get one EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailCampaignFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EmailCampaignFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EmailCampaign'> extends True ? Prisma__EmailCampaignClient<$Types.GetResult<EmailCampaignPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__EmailCampaignClient<$Types.GetResult<EmailCampaignPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one EmailCampaign that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailCampaignFindUniqueOrThrowArgs} args - Arguments to find a EmailCampaign
     * @example
     * // Get one EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailCampaignFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailCampaignFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailCampaignClient<$Types.GetResult<EmailCampaignPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first EmailCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignFindFirstArgs} args - Arguments to find a EmailCampaign
     * @example
     * // Get one EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailCampaignFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EmailCampaignFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EmailCampaign'> extends True ? Prisma__EmailCampaignClient<$Types.GetResult<EmailCampaignPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__EmailCampaignClient<$Types.GetResult<EmailCampaignPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first EmailCampaign that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignFindFirstOrThrowArgs} args - Arguments to find a EmailCampaign
     * @example
     * // Get one EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailCampaignFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailCampaignFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailCampaignClient<$Types.GetResult<EmailCampaignPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more EmailCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailCampaigns
     * const emailCampaigns = await prisma.emailCampaign.findMany()
     * 
     * // Get first 10 EmailCampaigns
     * const emailCampaigns = await prisma.emailCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailCampaignWithIdOnly = await prisma.emailCampaign.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailCampaignFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailCampaignFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<EmailCampaignPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a EmailCampaign.
     * @param {EmailCampaignCreateArgs} args - Arguments to create a EmailCampaign.
     * @example
     * // Create one EmailCampaign
     * const EmailCampaign = await prisma.emailCampaign.create({
     *   data: {
     *     // ... data to create a EmailCampaign
     *   }
     * })
     * 
    **/
    create<T extends EmailCampaignCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailCampaignCreateArgs<ExtArgs>>
    ): Prisma__EmailCampaignClient<$Types.GetResult<EmailCampaignPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many EmailCampaigns.
     *     @param {EmailCampaignCreateManyArgs} args - Arguments to create many EmailCampaigns.
     *     @example
     *     // Create many EmailCampaigns
     *     const emailCampaign = await prisma.emailCampaign.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailCampaignCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailCampaignCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailCampaign.
     * @param {EmailCampaignDeleteArgs} args - Arguments to delete one EmailCampaign.
     * @example
     * // Delete one EmailCampaign
     * const EmailCampaign = await prisma.emailCampaign.delete({
     *   where: {
     *     // ... filter to delete one EmailCampaign
     *   }
     * })
     * 
    **/
    delete<T extends EmailCampaignDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailCampaignDeleteArgs<ExtArgs>>
    ): Prisma__EmailCampaignClient<$Types.GetResult<EmailCampaignPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one EmailCampaign.
     * @param {EmailCampaignUpdateArgs} args - Arguments to update one EmailCampaign.
     * @example
     * // Update one EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailCampaignUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailCampaignUpdateArgs<ExtArgs>>
    ): Prisma__EmailCampaignClient<$Types.GetResult<EmailCampaignPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more EmailCampaigns.
     * @param {EmailCampaignDeleteManyArgs} args - Arguments to filter EmailCampaigns to delete.
     * @example
     * // Delete a few EmailCampaigns
     * const { count } = await prisma.emailCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailCampaignDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailCampaignDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailCampaigns
     * const emailCampaign = await prisma.emailCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailCampaignUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailCampaignUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailCampaign.
     * @param {EmailCampaignUpsertArgs} args - Arguments to update or create a EmailCampaign.
     * @example
     * // Update or create a EmailCampaign
     * const emailCampaign = await prisma.emailCampaign.upsert({
     *   create: {
     *     // ... data to create a EmailCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailCampaign we want to update
     *   }
     * })
    **/
    upsert<T extends EmailCampaignUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailCampaignUpsertArgs<ExtArgs>>
    ): Prisma__EmailCampaignClient<$Types.GetResult<EmailCampaignPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of EmailCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignCountArgs} args - Arguments to filter EmailCampaigns to count.
     * @example
     * // Count the number of EmailCampaigns
     * const count = await prisma.emailCampaign.count({
     *   where: {
     *     // ... the filter for the EmailCampaigns we want to count
     *   }
     * })
    **/
    count<T extends EmailCampaignCountArgs>(
      args?: Subset<T, EmailCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailCampaignAggregateArgs>(args: Subset<T, EmailCampaignAggregateArgs>): Prisma.PrismaPromise<GetEmailCampaignAggregateType<T>>

    /**
     * Group by EmailCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailCampaignGroupByArgs['orderBy'] }
        : { orderBy?: EmailCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EmailCampaignClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * EmailCampaign base type for findUnique actions
   */
  export type EmailCampaignFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Filter, which EmailCampaign to fetch.
     */
    where: EmailCampaignWhereUniqueInput
  }

  /**
   * EmailCampaign findUnique
   */
  export interface EmailCampaignFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EmailCampaignFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EmailCampaign findUniqueOrThrow
   */
  export type EmailCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Filter, which EmailCampaign to fetch.
     */
    where: EmailCampaignWhereUniqueInput
  }


  /**
   * EmailCampaign base type for findFirst actions
   */
  export type EmailCampaignFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Filter, which EmailCampaign to fetch.
     */
    where?: EmailCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaigns to fetch.
     */
    orderBy?: Enumerable<EmailCampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailCampaigns.
     */
    cursor?: EmailCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailCampaigns.
     */
    distinct?: Enumerable<EmailCampaignScalarFieldEnum>
  }

  /**
   * EmailCampaign findFirst
   */
  export interface EmailCampaignFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EmailCampaignFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EmailCampaign findFirstOrThrow
   */
  export type EmailCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Filter, which EmailCampaign to fetch.
     */
    where?: EmailCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaigns to fetch.
     */
    orderBy?: Enumerable<EmailCampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailCampaigns.
     */
    cursor?: EmailCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailCampaigns.
     */
    distinct?: Enumerable<EmailCampaignScalarFieldEnum>
  }


  /**
   * EmailCampaign findMany
   */
  export type EmailCampaignFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Filter, which EmailCampaigns to fetch.
     */
    where?: EmailCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailCampaigns to fetch.
     */
    orderBy?: Enumerable<EmailCampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailCampaigns.
     */
    cursor?: EmailCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailCampaigns.
     */
    skip?: number
    distinct?: Enumerable<EmailCampaignScalarFieldEnum>
  }


  /**
   * EmailCampaign create
   */
  export type EmailCampaignCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * The data needed to create a EmailCampaign.
     */
    data: XOR<EmailCampaignCreateInput, EmailCampaignUncheckedCreateInput>
  }


  /**
   * EmailCampaign createMany
   */
  export type EmailCampaignCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailCampaigns.
     */
    data: Enumerable<EmailCampaignCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EmailCampaign update
   */
  export type EmailCampaignUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * The data needed to update a EmailCampaign.
     */
    data: XOR<EmailCampaignUpdateInput, EmailCampaignUncheckedUpdateInput>
    /**
     * Choose, which EmailCampaign to update.
     */
    where: EmailCampaignWhereUniqueInput
  }


  /**
   * EmailCampaign updateMany
   */
  export type EmailCampaignUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailCampaigns.
     */
    data: XOR<EmailCampaignUpdateManyMutationInput, EmailCampaignUncheckedUpdateManyInput>
    /**
     * Filter which EmailCampaigns to update
     */
    where?: EmailCampaignWhereInput
  }


  /**
   * EmailCampaign upsert
   */
  export type EmailCampaignUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * The filter to search for the EmailCampaign to update in case it exists.
     */
    where: EmailCampaignWhereUniqueInput
    /**
     * In case the EmailCampaign found by the `where` argument doesn't exist, create a new EmailCampaign with this data.
     */
    create: XOR<EmailCampaignCreateInput, EmailCampaignUncheckedCreateInput>
    /**
     * In case the EmailCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailCampaignUpdateInput, EmailCampaignUncheckedUpdateInput>
  }


  /**
   * EmailCampaign delete
   */
  export type EmailCampaignDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
    /**
     * Filter which EmailCampaign to delete.
     */
    where: EmailCampaignWhereUniqueInput
  }


  /**
   * EmailCampaign deleteMany
   */
  export type EmailCampaignDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailCampaigns to delete
     */
    where?: EmailCampaignWhereInput
  }


  /**
   * EmailCampaign without action
   */
  export type EmailCampaignArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCampaign
     */
    select?: EmailCampaignSelect<ExtArgs> | null
  }



  /**
   * Model Notification
   */


  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    read: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: Enumerable<NotificationOrderByWithAggregationInput>
    by: NotificationScalarFieldEnum[]
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }


  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    read: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type NotificationGetPayload<S extends boolean | null | undefined | NotificationArgs> = $Types.GetResult<NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notification'> extends True ? Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notification'> extends True ? Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Types.GetResult<NotificationPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notification base type for findUnique actions
   */
  export type NotificationFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUnique
   */
  export interface NotificationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NotificationFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification base type for findFirst actions
   */
  export type NotificationFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }

  /**
   * Notification findFirst
   */
  export interface NotificationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NotificationFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: Enumerable<NotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
  }



  /**
   * Model GoogleCalendarToken
   */


  export type AggregateGoogleCalendarToken = {
    _count: GoogleCalendarTokenCountAggregateOutputType | null
    _min: GoogleCalendarTokenMinAggregateOutputType | null
    _max: GoogleCalendarTokenMaxAggregateOutputType | null
  }

  export type GoogleCalendarTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    scope: string | null
    tokenType: string | null
    expiryDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoogleCalendarTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    scope: string | null
    tokenType: string | null
    expiryDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoogleCalendarTokenCountAggregateOutputType = {
    id: number
    userId: number
    accessToken: number
    refreshToken: number
    scope: number
    tokenType: number
    expiryDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GoogleCalendarTokenMinAggregateInputType = {
    id?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    scope?: true
    tokenType?: true
    expiryDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoogleCalendarTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    scope?: true
    tokenType?: true
    expiryDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoogleCalendarTokenCountAggregateInputType = {
    id?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    scope?: true
    tokenType?: true
    expiryDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GoogleCalendarTokenAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoogleCalendarToken to aggregate.
     */
    where?: GoogleCalendarTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleCalendarTokens to fetch.
     */
    orderBy?: Enumerable<GoogleCalendarTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoogleCalendarTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleCalendarTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleCalendarTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoogleCalendarTokens
    **/
    _count?: true | GoogleCalendarTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoogleCalendarTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoogleCalendarTokenMaxAggregateInputType
  }

  export type GetGoogleCalendarTokenAggregateType<T extends GoogleCalendarTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateGoogleCalendarToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoogleCalendarToken[P]>
      : GetScalarType<T[P], AggregateGoogleCalendarToken[P]>
  }




  export type GoogleCalendarTokenGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GoogleCalendarTokenWhereInput
    orderBy?: Enumerable<GoogleCalendarTokenOrderByWithAggregationInput>
    by: GoogleCalendarTokenScalarFieldEnum[]
    having?: GoogleCalendarTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoogleCalendarTokenCountAggregateInputType | true
    _min?: GoogleCalendarTokenMinAggregateInputType
    _max?: GoogleCalendarTokenMaxAggregateInputType
  }


  export type GoogleCalendarTokenGroupByOutputType = {
    id: string
    userId: string
    accessToken: string
    refreshToken: string
    scope: string | null
    tokenType: string | null
    expiryDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: GoogleCalendarTokenCountAggregateOutputType | null
    _min: GoogleCalendarTokenMinAggregateOutputType | null
    _max: GoogleCalendarTokenMaxAggregateOutputType | null
  }

  type GetGoogleCalendarTokenGroupByPayload<T extends GoogleCalendarTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GoogleCalendarTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoogleCalendarTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoogleCalendarTokenGroupByOutputType[P]>
            : GetScalarType<T[P], GoogleCalendarTokenGroupByOutputType[P]>
        }
      >
    >


  export type GoogleCalendarTokenSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    scope?: boolean
    tokenType?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["googleCalendarToken"]>

  export type GoogleCalendarTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    scope?: boolean
    tokenType?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GoogleCalendarTokenInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type GoogleCalendarTokenGetPayload<S extends boolean | null | undefined | GoogleCalendarTokenArgs> = $Types.GetResult<GoogleCalendarTokenPayload, S>

  type GoogleCalendarTokenCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<GoogleCalendarTokenFindManyArgs, 'select' | 'include'> & {
      select?: GoogleCalendarTokenCountAggregateInputType | true
    }

  export interface GoogleCalendarTokenDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GoogleCalendarToken'], meta: { name: 'GoogleCalendarToken' } }
    /**
     * Find zero or one GoogleCalendarToken that matches the filter.
     * @param {GoogleCalendarTokenFindUniqueArgs} args - Arguments to find a GoogleCalendarToken
     * @example
     * // Get one GoogleCalendarToken
     * const googleCalendarToken = await prisma.googleCalendarToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GoogleCalendarTokenFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GoogleCalendarTokenFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GoogleCalendarToken'> extends True ? Prisma__GoogleCalendarTokenClient<$Types.GetResult<GoogleCalendarTokenPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__GoogleCalendarTokenClient<$Types.GetResult<GoogleCalendarTokenPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one GoogleCalendarToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GoogleCalendarTokenFindUniqueOrThrowArgs} args - Arguments to find a GoogleCalendarToken
     * @example
     * // Get one GoogleCalendarToken
     * const googleCalendarToken = await prisma.googleCalendarToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GoogleCalendarTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GoogleCalendarTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GoogleCalendarTokenClient<$Types.GetResult<GoogleCalendarTokenPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first GoogleCalendarToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleCalendarTokenFindFirstArgs} args - Arguments to find a GoogleCalendarToken
     * @example
     * // Get one GoogleCalendarToken
     * const googleCalendarToken = await prisma.googleCalendarToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GoogleCalendarTokenFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GoogleCalendarTokenFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GoogleCalendarToken'> extends True ? Prisma__GoogleCalendarTokenClient<$Types.GetResult<GoogleCalendarTokenPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__GoogleCalendarTokenClient<$Types.GetResult<GoogleCalendarTokenPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first GoogleCalendarToken that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleCalendarTokenFindFirstOrThrowArgs} args - Arguments to find a GoogleCalendarToken
     * @example
     * // Get one GoogleCalendarToken
     * const googleCalendarToken = await prisma.googleCalendarToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GoogleCalendarTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GoogleCalendarTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GoogleCalendarTokenClient<$Types.GetResult<GoogleCalendarTokenPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more GoogleCalendarTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleCalendarTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoogleCalendarTokens
     * const googleCalendarTokens = await prisma.googleCalendarToken.findMany()
     * 
     * // Get first 10 GoogleCalendarTokens
     * const googleCalendarTokens = await prisma.googleCalendarToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const googleCalendarTokenWithIdOnly = await prisma.googleCalendarToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GoogleCalendarTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GoogleCalendarTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<GoogleCalendarTokenPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a GoogleCalendarToken.
     * @param {GoogleCalendarTokenCreateArgs} args - Arguments to create a GoogleCalendarToken.
     * @example
     * // Create one GoogleCalendarToken
     * const GoogleCalendarToken = await prisma.googleCalendarToken.create({
     *   data: {
     *     // ... data to create a GoogleCalendarToken
     *   }
     * })
     * 
    **/
    create<T extends GoogleCalendarTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GoogleCalendarTokenCreateArgs<ExtArgs>>
    ): Prisma__GoogleCalendarTokenClient<$Types.GetResult<GoogleCalendarTokenPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many GoogleCalendarTokens.
     *     @param {GoogleCalendarTokenCreateManyArgs} args - Arguments to create many GoogleCalendarTokens.
     *     @example
     *     // Create many GoogleCalendarTokens
     *     const googleCalendarToken = await prisma.googleCalendarToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GoogleCalendarTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GoogleCalendarTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GoogleCalendarToken.
     * @param {GoogleCalendarTokenDeleteArgs} args - Arguments to delete one GoogleCalendarToken.
     * @example
     * // Delete one GoogleCalendarToken
     * const GoogleCalendarToken = await prisma.googleCalendarToken.delete({
     *   where: {
     *     // ... filter to delete one GoogleCalendarToken
     *   }
     * })
     * 
    **/
    delete<T extends GoogleCalendarTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GoogleCalendarTokenDeleteArgs<ExtArgs>>
    ): Prisma__GoogleCalendarTokenClient<$Types.GetResult<GoogleCalendarTokenPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one GoogleCalendarToken.
     * @param {GoogleCalendarTokenUpdateArgs} args - Arguments to update one GoogleCalendarToken.
     * @example
     * // Update one GoogleCalendarToken
     * const googleCalendarToken = await prisma.googleCalendarToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GoogleCalendarTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GoogleCalendarTokenUpdateArgs<ExtArgs>>
    ): Prisma__GoogleCalendarTokenClient<$Types.GetResult<GoogleCalendarTokenPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more GoogleCalendarTokens.
     * @param {GoogleCalendarTokenDeleteManyArgs} args - Arguments to filter GoogleCalendarTokens to delete.
     * @example
     * // Delete a few GoogleCalendarTokens
     * const { count } = await prisma.googleCalendarToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GoogleCalendarTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GoogleCalendarTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoogleCalendarTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleCalendarTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoogleCalendarTokens
     * const googleCalendarToken = await prisma.googleCalendarToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GoogleCalendarTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GoogleCalendarTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GoogleCalendarToken.
     * @param {GoogleCalendarTokenUpsertArgs} args - Arguments to update or create a GoogleCalendarToken.
     * @example
     * // Update or create a GoogleCalendarToken
     * const googleCalendarToken = await prisma.googleCalendarToken.upsert({
     *   create: {
     *     // ... data to create a GoogleCalendarToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoogleCalendarToken we want to update
     *   }
     * })
    **/
    upsert<T extends GoogleCalendarTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GoogleCalendarTokenUpsertArgs<ExtArgs>>
    ): Prisma__GoogleCalendarTokenClient<$Types.GetResult<GoogleCalendarTokenPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of GoogleCalendarTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleCalendarTokenCountArgs} args - Arguments to filter GoogleCalendarTokens to count.
     * @example
     * // Count the number of GoogleCalendarTokens
     * const count = await prisma.googleCalendarToken.count({
     *   where: {
     *     // ... the filter for the GoogleCalendarTokens we want to count
     *   }
     * })
    **/
    count<T extends GoogleCalendarTokenCountArgs>(
      args?: Subset<T, GoogleCalendarTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoogleCalendarTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoogleCalendarToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleCalendarTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoogleCalendarTokenAggregateArgs>(args: Subset<T, GoogleCalendarTokenAggregateArgs>): Prisma.PrismaPromise<GetGoogleCalendarTokenAggregateType<T>>

    /**
     * Group by GoogleCalendarToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleCalendarTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoogleCalendarTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoogleCalendarTokenGroupByArgs['orderBy'] }
        : { orderBy?: GoogleCalendarTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoogleCalendarTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoogleCalendarTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for GoogleCalendarToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GoogleCalendarTokenClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * GoogleCalendarToken base type for findUnique actions
   */
  export type GoogleCalendarTokenFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarToken
     */
    select?: GoogleCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GoogleCalendarTokenInclude<ExtArgs> | null
    /**
     * Filter, which GoogleCalendarToken to fetch.
     */
    where: GoogleCalendarTokenWhereUniqueInput
  }

  /**
   * GoogleCalendarToken findUnique
   */
  export interface GoogleCalendarTokenFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends GoogleCalendarTokenFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GoogleCalendarToken findUniqueOrThrow
   */
  export type GoogleCalendarTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarToken
     */
    select?: GoogleCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GoogleCalendarTokenInclude<ExtArgs> | null
    /**
     * Filter, which GoogleCalendarToken to fetch.
     */
    where: GoogleCalendarTokenWhereUniqueInput
  }


  /**
   * GoogleCalendarToken base type for findFirst actions
   */
  export type GoogleCalendarTokenFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarToken
     */
    select?: GoogleCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GoogleCalendarTokenInclude<ExtArgs> | null
    /**
     * Filter, which GoogleCalendarToken to fetch.
     */
    where?: GoogleCalendarTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleCalendarTokens to fetch.
     */
    orderBy?: Enumerable<GoogleCalendarTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoogleCalendarTokens.
     */
    cursor?: GoogleCalendarTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleCalendarTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleCalendarTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoogleCalendarTokens.
     */
    distinct?: Enumerable<GoogleCalendarTokenScalarFieldEnum>
  }

  /**
   * GoogleCalendarToken findFirst
   */
  export interface GoogleCalendarTokenFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends GoogleCalendarTokenFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GoogleCalendarToken findFirstOrThrow
   */
  export type GoogleCalendarTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarToken
     */
    select?: GoogleCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GoogleCalendarTokenInclude<ExtArgs> | null
    /**
     * Filter, which GoogleCalendarToken to fetch.
     */
    where?: GoogleCalendarTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleCalendarTokens to fetch.
     */
    orderBy?: Enumerable<GoogleCalendarTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoogleCalendarTokens.
     */
    cursor?: GoogleCalendarTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleCalendarTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleCalendarTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoogleCalendarTokens.
     */
    distinct?: Enumerable<GoogleCalendarTokenScalarFieldEnum>
  }


  /**
   * GoogleCalendarToken findMany
   */
  export type GoogleCalendarTokenFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarToken
     */
    select?: GoogleCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GoogleCalendarTokenInclude<ExtArgs> | null
    /**
     * Filter, which GoogleCalendarTokens to fetch.
     */
    where?: GoogleCalendarTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleCalendarTokens to fetch.
     */
    orderBy?: Enumerable<GoogleCalendarTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoogleCalendarTokens.
     */
    cursor?: GoogleCalendarTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoogleCalendarTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleCalendarTokens.
     */
    skip?: number
    distinct?: Enumerable<GoogleCalendarTokenScalarFieldEnum>
  }


  /**
   * GoogleCalendarToken create
   */
  export type GoogleCalendarTokenCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarToken
     */
    select?: GoogleCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GoogleCalendarTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a GoogleCalendarToken.
     */
    data: XOR<GoogleCalendarTokenCreateInput, GoogleCalendarTokenUncheckedCreateInput>
  }


  /**
   * GoogleCalendarToken createMany
   */
  export type GoogleCalendarTokenCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GoogleCalendarTokens.
     */
    data: Enumerable<GoogleCalendarTokenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GoogleCalendarToken update
   */
  export type GoogleCalendarTokenUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarToken
     */
    select?: GoogleCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GoogleCalendarTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a GoogleCalendarToken.
     */
    data: XOR<GoogleCalendarTokenUpdateInput, GoogleCalendarTokenUncheckedUpdateInput>
    /**
     * Choose, which GoogleCalendarToken to update.
     */
    where: GoogleCalendarTokenWhereUniqueInput
  }


  /**
   * GoogleCalendarToken updateMany
   */
  export type GoogleCalendarTokenUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GoogleCalendarTokens.
     */
    data: XOR<GoogleCalendarTokenUpdateManyMutationInput, GoogleCalendarTokenUncheckedUpdateManyInput>
    /**
     * Filter which GoogleCalendarTokens to update
     */
    where?: GoogleCalendarTokenWhereInput
  }


  /**
   * GoogleCalendarToken upsert
   */
  export type GoogleCalendarTokenUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarToken
     */
    select?: GoogleCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GoogleCalendarTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the GoogleCalendarToken to update in case it exists.
     */
    where: GoogleCalendarTokenWhereUniqueInput
    /**
     * In case the GoogleCalendarToken found by the `where` argument doesn't exist, create a new GoogleCalendarToken with this data.
     */
    create: XOR<GoogleCalendarTokenCreateInput, GoogleCalendarTokenUncheckedCreateInput>
    /**
     * In case the GoogleCalendarToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoogleCalendarTokenUpdateInput, GoogleCalendarTokenUncheckedUpdateInput>
  }


  /**
   * GoogleCalendarToken delete
   */
  export type GoogleCalendarTokenDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarToken
     */
    select?: GoogleCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GoogleCalendarTokenInclude<ExtArgs> | null
    /**
     * Filter which GoogleCalendarToken to delete.
     */
    where: GoogleCalendarTokenWhereUniqueInput
  }


  /**
   * GoogleCalendarToken deleteMany
   */
  export type GoogleCalendarTokenDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoogleCalendarTokens to delete
     */
    where?: GoogleCalendarTokenWhereInput
  }


  /**
   * GoogleCalendarToken without action
   */
  export type GoogleCalendarTokenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleCalendarToken
     */
    select?: GoogleCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GoogleCalendarTokenInclude<ExtArgs> | null
  }



  /**
   * Model OutlookCalendarToken
   */


  export type AggregateOutlookCalendarToken = {
    _count: OutlookCalendarTokenCountAggregateOutputType | null
    _min: OutlookCalendarTokenMinAggregateOutputType | null
    _max: OutlookCalendarTokenMaxAggregateOutputType | null
  }

  export type OutlookCalendarTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    scope: string | null
    tokenType: string | null
    expiryDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutlookCalendarTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    scope: string | null
    tokenType: string | null
    expiryDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutlookCalendarTokenCountAggregateOutputType = {
    id: number
    userId: number
    accessToken: number
    refreshToken: number
    scope: number
    tokenType: number
    expiryDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OutlookCalendarTokenMinAggregateInputType = {
    id?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    scope?: true
    tokenType?: true
    expiryDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutlookCalendarTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    scope?: true
    tokenType?: true
    expiryDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutlookCalendarTokenCountAggregateInputType = {
    id?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    scope?: true
    tokenType?: true
    expiryDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OutlookCalendarTokenAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutlookCalendarToken to aggregate.
     */
    where?: OutlookCalendarTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutlookCalendarTokens to fetch.
     */
    orderBy?: Enumerable<OutlookCalendarTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutlookCalendarTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutlookCalendarTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutlookCalendarTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutlookCalendarTokens
    **/
    _count?: true | OutlookCalendarTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutlookCalendarTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutlookCalendarTokenMaxAggregateInputType
  }

  export type GetOutlookCalendarTokenAggregateType<T extends OutlookCalendarTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateOutlookCalendarToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutlookCalendarToken[P]>
      : GetScalarType<T[P], AggregateOutlookCalendarToken[P]>
  }




  export type OutlookCalendarTokenGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OutlookCalendarTokenWhereInput
    orderBy?: Enumerable<OutlookCalendarTokenOrderByWithAggregationInput>
    by: OutlookCalendarTokenScalarFieldEnum[]
    having?: OutlookCalendarTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutlookCalendarTokenCountAggregateInputType | true
    _min?: OutlookCalendarTokenMinAggregateInputType
    _max?: OutlookCalendarTokenMaxAggregateInputType
  }


  export type OutlookCalendarTokenGroupByOutputType = {
    id: string
    userId: string
    accessToken: string
    refreshToken: string
    scope: string | null
    tokenType: string | null
    expiryDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OutlookCalendarTokenCountAggregateOutputType | null
    _min: OutlookCalendarTokenMinAggregateOutputType | null
    _max: OutlookCalendarTokenMaxAggregateOutputType | null
  }

  type GetOutlookCalendarTokenGroupByPayload<T extends OutlookCalendarTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OutlookCalendarTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutlookCalendarTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutlookCalendarTokenGroupByOutputType[P]>
            : GetScalarType<T[P], OutlookCalendarTokenGroupByOutputType[P]>
        }
      >
    >


  export type OutlookCalendarTokenSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    scope?: boolean
    tokenType?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["outlookCalendarToken"]>

  export type OutlookCalendarTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    scope?: boolean
    tokenType?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OutlookCalendarTokenInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type OutlookCalendarTokenGetPayload<S extends boolean | null | undefined | OutlookCalendarTokenArgs> = $Types.GetResult<OutlookCalendarTokenPayload, S>

  type OutlookCalendarTokenCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OutlookCalendarTokenFindManyArgs, 'select' | 'include'> & {
      select?: OutlookCalendarTokenCountAggregateInputType | true
    }

  export interface OutlookCalendarTokenDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutlookCalendarToken'], meta: { name: 'OutlookCalendarToken' } }
    /**
     * Find zero or one OutlookCalendarToken that matches the filter.
     * @param {OutlookCalendarTokenFindUniqueArgs} args - Arguments to find a OutlookCalendarToken
     * @example
     * // Get one OutlookCalendarToken
     * const outlookCalendarToken = await prisma.outlookCalendarToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OutlookCalendarTokenFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OutlookCalendarTokenFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OutlookCalendarToken'> extends True ? Prisma__OutlookCalendarTokenClient<$Types.GetResult<OutlookCalendarTokenPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__OutlookCalendarTokenClient<$Types.GetResult<OutlookCalendarTokenPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one OutlookCalendarToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OutlookCalendarTokenFindUniqueOrThrowArgs} args - Arguments to find a OutlookCalendarToken
     * @example
     * // Get one OutlookCalendarToken
     * const outlookCalendarToken = await prisma.outlookCalendarToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OutlookCalendarTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OutlookCalendarTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OutlookCalendarTokenClient<$Types.GetResult<OutlookCalendarTokenPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first OutlookCalendarToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutlookCalendarTokenFindFirstArgs} args - Arguments to find a OutlookCalendarToken
     * @example
     * // Get one OutlookCalendarToken
     * const outlookCalendarToken = await prisma.outlookCalendarToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OutlookCalendarTokenFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OutlookCalendarTokenFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OutlookCalendarToken'> extends True ? Prisma__OutlookCalendarTokenClient<$Types.GetResult<OutlookCalendarTokenPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__OutlookCalendarTokenClient<$Types.GetResult<OutlookCalendarTokenPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first OutlookCalendarToken that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutlookCalendarTokenFindFirstOrThrowArgs} args - Arguments to find a OutlookCalendarToken
     * @example
     * // Get one OutlookCalendarToken
     * const outlookCalendarToken = await prisma.outlookCalendarToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OutlookCalendarTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OutlookCalendarTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OutlookCalendarTokenClient<$Types.GetResult<OutlookCalendarTokenPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more OutlookCalendarTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutlookCalendarTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutlookCalendarTokens
     * const outlookCalendarTokens = await prisma.outlookCalendarToken.findMany()
     * 
     * // Get first 10 OutlookCalendarTokens
     * const outlookCalendarTokens = await prisma.outlookCalendarToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outlookCalendarTokenWithIdOnly = await prisma.outlookCalendarToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OutlookCalendarTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OutlookCalendarTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OutlookCalendarTokenPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a OutlookCalendarToken.
     * @param {OutlookCalendarTokenCreateArgs} args - Arguments to create a OutlookCalendarToken.
     * @example
     * // Create one OutlookCalendarToken
     * const OutlookCalendarToken = await prisma.outlookCalendarToken.create({
     *   data: {
     *     // ... data to create a OutlookCalendarToken
     *   }
     * })
     * 
    **/
    create<T extends OutlookCalendarTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OutlookCalendarTokenCreateArgs<ExtArgs>>
    ): Prisma__OutlookCalendarTokenClient<$Types.GetResult<OutlookCalendarTokenPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many OutlookCalendarTokens.
     *     @param {OutlookCalendarTokenCreateManyArgs} args - Arguments to create many OutlookCalendarTokens.
     *     @example
     *     // Create many OutlookCalendarTokens
     *     const outlookCalendarToken = await prisma.outlookCalendarToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OutlookCalendarTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OutlookCalendarTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OutlookCalendarToken.
     * @param {OutlookCalendarTokenDeleteArgs} args - Arguments to delete one OutlookCalendarToken.
     * @example
     * // Delete one OutlookCalendarToken
     * const OutlookCalendarToken = await prisma.outlookCalendarToken.delete({
     *   where: {
     *     // ... filter to delete one OutlookCalendarToken
     *   }
     * })
     * 
    **/
    delete<T extends OutlookCalendarTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OutlookCalendarTokenDeleteArgs<ExtArgs>>
    ): Prisma__OutlookCalendarTokenClient<$Types.GetResult<OutlookCalendarTokenPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one OutlookCalendarToken.
     * @param {OutlookCalendarTokenUpdateArgs} args - Arguments to update one OutlookCalendarToken.
     * @example
     * // Update one OutlookCalendarToken
     * const outlookCalendarToken = await prisma.outlookCalendarToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OutlookCalendarTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OutlookCalendarTokenUpdateArgs<ExtArgs>>
    ): Prisma__OutlookCalendarTokenClient<$Types.GetResult<OutlookCalendarTokenPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more OutlookCalendarTokens.
     * @param {OutlookCalendarTokenDeleteManyArgs} args - Arguments to filter OutlookCalendarTokens to delete.
     * @example
     * // Delete a few OutlookCalendarTokens
     * const { count } = await prisma.outlookCalendarToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OutlookCalendarTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OutlookCalendarTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutlookCalendarTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutlookCalendarTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutlookCalendarTokens
     * const outlookCalendarToken = await prisma.outlookCalendarToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OutlookCalendarTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OutlookCalendarTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OutlookCalendarToken.
     * @param {OutlookCalendarTokenUpsertArgs} args - Arguments to update or create a OutlookCalendarToken.
     * @example
     * // Update or create a OutlookCalendarToken
     * const outlookCalendarToken = await prisma.outlookCalendarToken.upsert({
     *   create: {
     *     // ... data to create a OutlookCalendarToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutlookCalendarToken we want to update
     *   }
     * })
    **/
    upsert<T extends OutlookCalendarTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OutlookCalendarTokenUpsertArgs<ExtArgs>>
    ): Prisma__OutlookCalendarTokenClient<$Types.GetResult<OutlookCalendarTokenPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of OutlookCalendarTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutlookCalendarTokenCountArgs} args - Arguments to filter OutlookCalendarTokens to count.
     * @example
     * // Count the number of OutlookCalendarTokens
     * const count = await prisma.outlookCalendarToken.count({
     *   where: {
     *     // ... the filter for the OutlookCalendarTokens we want to count
     *   }
     * })
    **/
    count<T extends OutlookCalendarTokenCountArgs>(
      args?: Subset<T, OutlookCalendarTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutlookCalendarTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutlookCalendarToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutlookCalendarTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutlookCalendarTokenAggregateArgs>(args: Subset<T, OutlookCalendarTokenAggregateArgs>): Prisma.PrismaPromise<GetOutlookCalendarTokenAggregateType<T>>

    /**
     * Group by OutlookCalendarToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutlookCalendarTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutlookCalendarTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutlookCalendarTokenGroupByArgs['orderBy'] }
        : { orderBy?: OutlookCalendarTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutlookCalendarTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutlookCalendarTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OutlookCalendarToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OutlookCalendarTokenClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OutlookCalendarToken base type for findUnique actions
   */
  export type OutlookCalendarTokenFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutlookCalendarToken
     */
    select?: OutlookCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutlookCalendarTokenInclude<ExtArgs> | null
    /**
     * Filter, which OutlookCalendarToken to fetch.
     */
    where: OutlookCalendarTokenWhereUniqueInput
  }

  /**
   * OutlookCalendarToken findUnique
   */
  export interface OutlookCalendarTokenFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OutlookCalendarTokenFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OutlookCalendarToken findUniqueOrThrow
   */
  export type OutlookCalendarTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutlookCalendarToken
     */
    select?: OutlookCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutlookCalendarTokenInclude<ExtArgs> | null
    /**
     * Filter, which OutlookCalendarToken to fetch.
     */
    where: OutlookCalendarTokenWhereUniqueInput
  }


  /**
   * OutlookCalendarToken base type for findFirst actions
   */
  export type OutlookCalendarTokenFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutlookCalendarToken
     */
    select?: OutlookCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutlookCalendarTokenInclude<ExtArgs> | null
    /**
     * Filter, which OutlookCalendarToken to fetch.
     */
    where?: OutlookCalendarTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutlookCalendarTokens to fetch.
     */
    orderBy?: Enumerable<OutlookCalendarTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutlookCalendarTokens.
     */
    cursor?: OutlookCalendarTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutlookCalendarTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutlookCalendarTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutlookCalendarTokens.
     */
    distinct?: Enumerable<OutlookCalendarTokenScalarFieldEnum>
  }

  /**
   * OutlookCalendarToken findFirst
   */
  export interface OutlookCalendarTokenFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OutlookCalendarTokenFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OutlookCalendarToken findFirstOrThrow
   */
  export type OutlookCalendarTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutlookCalendarToken
     */
    select?: OutlookCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutlookCalendarTokenInclude<ExtArgs> | null
    /**
     * Filter, which OutlookCalendarToken to fetch.
     */
    where?: OutlookCalendarTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutlookCalendarTokens to fetch.
     */
    orderBy?: Enumerable<OutlookCalendarTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutlookCalendarTokens.
     */
    cursor?: OutlookCalendarTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutlookCalendarTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutlookCalendarTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutlookCalendarTokens.
     */
    distinct?: Enumerable<OutlookCalendarTokenScalarFieldEnum>
  }


  /**
   * OutlookCalendarToken findMany
   */
  export type OutlookCalendarTokenFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutlookCalendarToken
     */
    select?: OutlookCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutlookCalendarTokenInclude<ExtArgs> | null
    /**
     * Filter, which OutlookCalendarTokens to fetch.
     */
    where?: OutlookCalendarTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutlookCalendarTokens to fetch.
     */
    orderBy?: Enumerable<OutlookCalendarTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutlookCalendarTokens.
     */
    cursor?: OutlookCalendarTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutlookCalendarTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutlookCalendarTokens.
     */
    skip?: number
    distinct?: Enumerable<OutlookCalendarTokenScalarFieldEnum>
  }


  /**
   * OutlookCalendarToken create
   */
  export type OutlookCalendarTokenCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutlookCalendarToken
     */
    select?: OutlookCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutlookCalendarTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a OutlookCalendarToken.
     */
    data: XOR<OutlookCalendarTokenCreateInput, OutlookCalendarTokenUncheckedCreateInput>
  }


  /**
   * OutlookCalendarToken createMany
   */
  export type OutlookCalendarTokenCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutlookCalendarTokens.
     */
    data: Enumerable<OutlookCalendarTokenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OutlookCalendarToken update
   */
  export type OutlookCalendarTokenUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutlookCalendarToken
     */
    select?: OutlookCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutlookCalendarTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a OutlookCalendarToken.
     */
    data: XOR<OutlookCalendarTokenUpdateInput, OutlookCalendarTokenUncheckedUpdateInput>
    /**
     * Choose, which OutlookCalendarToken to update.
     */
    where: OutlookCalendarTokenWhereUniqueInput
  }


  /**
   * OutlookCalendarToken updateMany
   */
  export type OutlookCalendarTokenUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutlookCalendarTokens.
     */
    data: XOR<OutlookCalendarTokenUpdateManyMutationInput, OutlookCalendarTokenUncheckedUpdateManyInput>
    /**
     * Filter which OutlookCalendarTokens to update
     */
    where?: OutlookCalendarTokenWhereInput
  }


  /**
   * OutlookCalendarToken upsert
   */
  export type OutlookCalendarTokenUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutlookCalendarToken
     */
    select?: OutlookCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutlookCalendarTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the OutlookCalendarToken to update in case it exists.
     */
    where: OutlookCalendarTokenWhereUniqueInput
    /**
     * In case the OutlookCalendarToken found by the `where` argument doesn't exist, create a new OutlookCalendarToken with this data.
     */
    create: XOR<OutlookCalendarTokenCreateInput, OutlookCalendarTokenUncheckedCreateInput>
    /**
     * In case the OutlookCalendarToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutlookCalendarTokenUpdateInput, OutlookCalendarTokenUncheckedUpdateInput>
  }


  /**
   * OutlookCalendarToken delete
   */
  export type OutlookCalendarTokenDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutlookCalendarToken
     */
    select?: OutlookCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutlookCalendarTokenInclude<ExtArgs> | null
    /**
     * Filter which OutlookCalendarToken to delete.
     */
    where: OutlookCalendarTokenWhereUniqueInput
  }


  /**
   * OutlookCalendarToken deleteMany
   */
  export type OutlookCalendarTokenDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutlookCalendarTokens to delete
     */
    where?: OutlookCalendarTokenWhereInput
  }


  /**
   * OutlookCalendarToken without action
   */
  export type OutlookCalendarTokenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutlookCalendarToken
     */
    select?: OutlookCalendarTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OutlookCalendarTokenInclude<ExtArgs> | null
  }



  /**
   * Model FormDefinition
   */


  export type AggregateFormDefinition = {
    _count: FormDefinitionCountAggregateOutputType | null
    _min: FormDefinitionMinAggregateOutputType | null
    _max: FormDefinitionMaxAggregateOutputType | null
  }

  export type FormDefinitionMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormDefinitionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormDefinitionCountAggregateOutputType = {
    id: number
    name: number
    fields: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormDefinitionMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormDefinitionMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormDefinitionCountAggregateInputType = {
    id?: true
    name?: true
    fields?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormDefinitionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormDefinition to aggregate.
     */
    where?: FormDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormDefinitions to fetch.
     */
    orderBy?: Enumerable<FormDefinitionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormDefinitions
    **/
    _count?: true | FormDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormDefinitionMaxAggregateInputType
  }

  export type GetFormDefinitionAggregateType<T extends FormDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateFormDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormDefinition[P]>
      : GetScalarType<T[P], AggregateFormDefinition[P]>
  }




  export type FormDefinitionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FormDefinitionWhereInput
    orderBy?: Enumerable<FormDefinitionOrderByWithAggregationInput>
    by: FormDefinitionScalarFieldEnum[]
    having?: FormDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormDefinitionCountAggregateInputType | true
    _min?: FormDefinitionMinAggregateInputType
    _max?: FormDefinitionMaxAggregateInputType
  }


  export type FormDefinitionGroupByOutputType = {
    id: string
    name: string
    fields: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: FormDefinitionCountAggregateOutputType | null
    _min: FormDefinitionMinAggregateOutputType | null
    _max: FormDefinitionMaxAggregateOutputType | null
  }

  type GetFormDefinitionGroupByPayload<T extends FormDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FormDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], FormDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type FormDefinitionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submissions?: boolean | FormDefinition$submissionsArgs<ExtArgs>
    _count?: boolean | FormDefinitionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["formDefinition"]>

  export type FormDefinitionSelectScalar = {
    id?: boolean
    name?: boolean
    fields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FormDefinitionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    submissions?: boolean | FormDefinition$submissionsArgs<ExtArgs>
    _count?: boolean | FormDefinitionCountOutputTypeArgs<ExtArgs>
  }


  type FormDefinitionGetPayload<S extends boolean | null | undefined | FormDefinitionArgs> = $Types.GetResult<FormDefinitionPayload, S>

  type FormDefinitionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<FormDefinitionFindManyArgs, 'select' | 'include'> & {
      select?: FormDefinitionCountAggregateInputType | true
    }

  export interface FormDefinitionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormDefinition'], meta: { name: 'FormDefinition' } }
    /**
     * Find zero or one FormDefinition that matches the filter.
     * @param {FormDefinitionFindUniqueArgs} args - Arguments to find a FormDefinition
     * @example
     * // Get one FormDefinition
     * const formDefinition = await prisma.formDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormDefinitionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FormDefinitionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FormDefinition'> extends True ? Prisma__FormDefinitionClient<$Types.GetResult<FormDefinitionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__FormDefinitionClient<$Types.GetResult<FormDefinitionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one FormDefinition that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FormDefinitionFindUniqueOrThrowArgs} args - Arguments to find a FormDefinition
     * @example
     * // Get one FormDefinition
     * const formDefinition = await prisma.formDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormDefinitionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormDefinitionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormDefinitionClient<$Types.GetResult<FormDefinitionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first FormDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormDefinitionFindFirstArgs} args - Arguments to find a FormDefinition
     * @example
     * // Get one FormDefinition
     * const formDefinition = await prisma.formDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormDefinitionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FormDefinitionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FormDefinition'> extends True ? Prisma__FormDefinitionClient<$Types.GetResult<FormDefinitionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__FormDefinitionClient<$Types.GetResult<FormDefinitionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first FormDefinition that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormDefinitionFindFirstOrThrowArgs} args - Arguments to find a FormDefinition
     * @example
     * // Get one FormDefinition
     * const formDefinition = await prisma.formDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormDefinitionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormDefinitionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormDefinitionClient<$Types.GetResult<FormDefinitionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more FormDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormDefinitionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormDefinitions
     * const formDefinitions = await prisma.formDefinition.findMany()
     * 
     * // Get first 10 FormDefinitions
     * const formDefinitions = await prisma.formDefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formDefinitionWithIdOnly = await prisma.formDefinition.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FormDefinitionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormDefinitionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<FormDefinitionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a FormDefinition.
     * @param {FormDefinitionCreateArgs} args - Arguments to create a FormDefinition.
     * @example
     * // Create one FormDefinition
     * const FormDefinition = await prisma.formDefinition.create({
     *   data: {
     *     // ... data to create a FormDefinition
     *   }
     * })
     * 
    **/
    create<T extends FormDefinitionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FormDefinitionCreateArgs<ExtArgs>>
    ): Prisma__FormDefinitionClient<$Types.GetResult<FormDefinitionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many FormDefinitions.
     *     @param {FormDefinitionCreateManyArgs} args - Arguments to create many FormDefinitions.
     *     @example
     *     // Create many FormDefinitions
     *     const formDefinition = await prisma.formDefinition.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FormDefinitionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormDefinitionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FormDefinition.
     * @param {FormDefinitionDeleteArgs} args - Arguments to delete one FormDefinition.
     * @example
     * // Delete one FormDefinition
     * const FormDefinition = await prisma.formDefinition.delete({
     *   where: {
     *     // ... filter to delete one FormDefinition
     *   }
     * })
     * 
    **/
    delete<T extends FormDefinitionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FormDefinitionDeleteArgs<ExtArgs>>
    ): Prisma__FormDefinitionClient<$Types.GetResult<FormDefinitionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one FormDefinition.
     * @param {FormDefinitionUpdateArgs} args - Arguments to update one FormDefinition.
     * @example
     * // Update one FormDefinition
     * const formDefinition = await prisma.formDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormDefinitionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FormDefinitionUpdateArgs<ExtArgs>>
    ): Prisma__FormDefinitionClient<$Types.GetResult<FormDefinitionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more FormDefinitions.
     * @param {FormDefinitionDeleteManyArgs} args - Arguments to filter FormDefinitions to delete.
     * @example
     * // Delete a few FormDefinitions
     * const { count } = await prisma.formDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormDefinitionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormDefinitionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormDefinitions
     * const formDefinition = await prisma.formDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormDefinitionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FormDefinitionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormDefinition.
     * @param {FormDefinitionUpsertArgs} args - Arguments to update or create a FormDefinition.
     * @example
     * // Update or create a FormDefinition
     * const formDefinition = await prisma.formDefinition.upsert({
     *   create: {
     *     // ... data to create a FormDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormDefinition we want to update
     *   }
     * })
    **/
    upsert<T extends FormDefinitionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FormDefinitionUpsertArgs<ExtArgs>>
    ): Prisma__FormDefinitionClient<$Types.GetResult<FormDefinitionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of FormDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormDefinitionCountArgs} args - Arguments to filter FormDefinitions to count.
     * @example
     * // Count the number of FormDefinitions
     * const count = await prisma.formDefinition.count({
     *   where: {
     *     // ... the filter for the FormDefinitions we want to count
     *   }
     * })
    **/
    count<T extends FormDefinitionCountArgs>(
      args?: Subset<T, FormDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormDefinitionAggregateArgs>(args: Subset<T, FormDefinitionAggregateArgs>): Prisma.PrismaPromise<GetFormDefinitionAggregateType<T>>

    /**
     * Group by FormDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: FormDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FormDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FormDefinitionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    submissions<T extends FormDefinition$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, FormDefinition$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<FormSubmissionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FormDefinition base type for findUnique actions
   */
  export type FormDefinitionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormDefinition
     */
    select?: FormDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which FormDefinition to fetch.
     */
    where: FormDefinitionWhereUniqueInput
  }

  /**
   * FormDefinition findUnique
   */
  export interface FormDefinitionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends FormDefinitionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FormDefinition findUniqueOrThrow
   */
  export type FormDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormDefinition
     */
    select?: FormDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which FormDefinition to fetch.
     */
    where: FormDefinitionWhereUniqueInput
  }


  /**
   * FormDefinition base type for findFirst actions
   */
  export type FormDefinitionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormDefinition
     */
    select?: FormDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which FormDefinition to fetch.
     */
    where?: FormDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormDefinitions to fetch.
     */
    orderBy?: Enumerable<FormDefinitionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormDefinitions.
     */
    cursor?: FormDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormDefinitions.
     */
    distinct?: Enumerable<FormDefinitionScalarFieldEnum>
  }

  /**
   * FormDefinition findFirst
   */
  export interface FormDefinitionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends FormDefinitionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FormDefinition findFirstOrThrow
   */
  export type FormDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormDefinition
     */
    select?: FormDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which FormDefinition to fetch.
     */
    where?: FormDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormDefinitions to fetch.
     */
    orderBy?: Enumerable<FormDefinitionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormDefinitions.
     */
    cursor?: FormDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormDefinitions.
     */
    distinct?: Enumerable<FormDefinitionScalarFieldEnum>
  }


  /**
   * FormDefinition findMany
   */
  export type FormDefinitionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormDefinition
     */
    select?: FormDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which FormDefinitions to fetch.
     */
    where?: FormDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormDefinitions to fetch.
     */
    orderBy?: Enumerable<FormDefinitionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormDefinitions.
     */
    cursor?: FormDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormDefinitions.
     */
    skip?: number
    distinct?: Enumerable<FormDefinitionScalarFieldEnum>
  }


  /**
   * FormDefinition create
   */
  export type FormDefinitionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormDefinition
     */
    select?: FormDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a FormDefinition.
     */
    data: XOR<FormDefinitionCreateInput, FormDefinitionUncheckedCreateInput>
  }


  /**
   * FormDefinition createMany
   */
  export type FormDefinitionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormDefinitions.
     */
    data: Enumerable<FormDefinitionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FormDefinition update
   */
  export type FormDefinitionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormDefinition
     */
    select?: FormDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a FormDefinition.
     */
    data: XOR<FormDefinitionUpdateInput, FormDefinitionUncheckedUpdateInput>
    /**
     * Choose, which FormDefinition to update.
     */
    where: FormDefinitionWhereUniqueInput
  }


  /**
   * FormDefinition updateMany
   */
  export type FormDefinitionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormDefinitions.
     */
    data: XOR<FormDefinitionUpdateManyMutationInput, FormDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which FormDefinitions to update
     */
    where?: FormDefinitionWhereInput
  }


  /**
   * FormDefinition upsert
   */
  export type FormDefinitionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormDefinition
     */
    select?: FormDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the FormDefinition to update in case it exists.
     */
    where: FormDefinitionWhereUniqueInput
    /**
     * In case the FormDefinition found by the `where` argument doesn't exist, create a new FormDefinition with this data.
     */
    create: XOR<FormDefinitionCreateInput, FormDefinitionUncheckedCreateInput>
    /**
     * In case the FormDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormDefinitionUpdateInput, FormDefinitionUncheckedUpdateInput>
  }


  /**
   * FormDefinition delete
   */
  export type FormDefinitionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormDefinition
     */
    select?: FormDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormDefinitionInclude<ExtArgs> | null
    /**
     * Filter which FormDefinition to delete.
     */
    where: FormDefinitionWhereUniqueInput
  }


  /**
   * FormDefinition deleteMany
   */
  export type FormDefinitionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormDefinitions to delete
     */
    where?: FormDefinitionWhereInput
  }


  /**
   * FormDefinition.submissions
   */
  export type FormDefinition$submissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    where?: FormSubmissionWhereInput
    orderBy?: Enumerable<FormSubmissionOrderByWithRelationInput>
    cursor?: FormSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FormSubmissionScalarFieldEnum>
  }


  /**
   * FormDefinition without action
   */
  export type FormDefinitionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormDefinition
     */
    select?: FormDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormDefinitionInclude<ExtArgs> | null
  }



  /**
   * Model FormSubmission
   */


  export type AggregateFormSubmission = {
    _count: FormSubmissionCountAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  export type FormSubmissionMinAggregateOutputType = {
    id: string | null
    definitionId: string | null
    submittedAt: Date | null
  }

  export type FormSubmissionMaxAggregateOutputType = {
    id: string | null
    definitionId: string | null
    submittedAt: Date | null
  }

  export type FormSubmissionCountAggregateOutputType = {
    id: number
    definitionId: number
    data: number
    submittedAt: number
    _all: number
  }


  export type FormSubmissionMinAggregateInputType = {
    id?: true
    definitionId?: true
    submittedAt?: true
  }

  export type FormSubmissionMaxAggregateInputType = {
    id?: true
    definitionId?: true
    submittedAt?: true
  }

  export type FormSubmissionCountAggregateInputType = {
    id?: true
    definitionId?: true
    data?: true
    submittedAt?: true
    _all?: true
  }

  export type FormSubmissionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmission to aggregate.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: Enumerable<FormSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormSubmissions
    **/
    _count?: true | FormSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormSubmissionMaxAggregateInputType
  }

  export type GetFormSubmissionAggregateType<T extends FormSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateFormSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormSubmission[P]>
      : GetScalarType<T[P], AggregateFormSubmission[P]>
  }




  export type FormSubmissionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
    orderBy?: Enumerable<FormSubmissionOrderByWithAggregationInput>
    by: FormSubmissionScalarFieldEnum[]
    having?: FormSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormSubmissionCountAggregateInputType | true
    _min?: FormSubmissionMinAggregateInputType
    _max?: FormSubmissionMaxAggregateInputType
  }


  export type FormSubmissionGroupByOutputType = {
    id: string
    definitionId: string
    data: JsonValue
    submittedAt: Date
    _count: FormSubmissionCountAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  type GetFormSubmissionGroupByPayload<T extends FormSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FormSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type FormSubmissionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    definitionId?: boolean
    data?: boolean
    submittedAt?: boolean
    definition?: boolean | FormDefinitionArgs<ExtArgs>
    documents?: boolean | FormSubmission$documentsArgs<ExtArgs>
    _count?: boolean | FormSubmissionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["formSubmission"]>

  export type FormSubmissionSelectScalar = {
    id?: boolean
    definitionId?: boolean
    data?: boolean
    submittedAt?: boolean
  }

  export type FormSubmissionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    definition?: boolean | FormDefinitionArgs<ExtArgs>
    documents?: boolean | FormSubmission$documentsArgs<ExtArgs>
    _count?: boolean | FormSubmissionCountOutputTypeArgs<ExtArgs>
  }


  type FormSubmissionGetPayload<S extends boolean | null | undefined | FormSubmissionArgs> = $Types.GetResult<FormSubmissionPayload, S>

  type FormSubmissionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<FormSubmissionFindManyArgs, 'select' | 'include'> & {
      select?: FormSubmissionCountAggregateInputType | true
    }

  export interface FormSubmissionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormSubmission'], meta: { name: 'FormSubmission' } }
    /**
     * Find zero or one FormSubmission that matches the filter.
     * @param {FormSubmissionFindUniqueArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormSubmissionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FormSubmissionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FormSubmission'> extends True ? Prisma__FormSubmissionClient<$Types.GetResult<FormSubmissionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__FormSubmissionClient<$Types.GetResult<FormSubmissionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one FormSubmission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FormSubmissionFindUniqueOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormSubmissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Types.GetResult<FormSubmissionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first FormSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormSubmissionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FormSubmissionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FormSubmission'> extends True ? Prisma__FormSubmissionClient<$Types.GetResult<FormSubmissionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__FormSubmissionClient<$Types.GetResult<FormSubmissionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first FormSubmission that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormSubmissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Types.GetResult<FormSubmissionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more FormSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany()
     * 
     * // Get first 10 FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formSubmissionWithIdOnly = await prisma.formSubmission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FormSubmissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<FormSubmissionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a FormSubmission.
     * @param {FormSubmissionCreateArgs} args - Arguments to create a FormSubmission.
     * @example
     * // Create one FormSubmission
     * const FormSubmission = await prisma.formSubmission.create({
     *   data: {
     *     // ... data to create a FormSubmission
     *   }
     * })
     * 
    **/
    create<T extends FormSubmissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionCreateArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Types.GetResult<FormSubmissionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many FormSubmissions.
     *     @param {FormSubmissionCreateManyArgs} args - Arguments to create many FormSubmissions.
     *     @example
     *     // Create many FormSubmissions
     *     const formSubmission = await prisma.formSubmission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FormSubmissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FormSubmission.
     * @param {FormSubmissionDeleteArgs} args - Arguments to delete one FormSubmission.
     * @example
     * // Delete one FormSubmission
     * const FormSubmission = await prisma.formSubmission.delete({
     *   where: {
     *     // ... filter to delete one FormSubmission
     *   }
     * })
     * 
    **/
    delete<T extends FormSubmissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionDeleteArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Types.GetResult<FormSubmissionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one FormSubmission.
     * @param {FormSubmissionUpdateArgs} args - Arguments to update one FormSubmission.
     * @example
     * // Update one FormSubmission
     * const formSubmission = await prisma.formSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormSubmissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionUpdateArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Types.GetResult<FormSubmissionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more FormSubmissions.
     * @param {FormSubmissionDeleteManyArgs} args - Arguments to filter FormSubmissions to delete.
     * @example
     * // Delete a few FormSubmissions
     * const { count } = await prisma.formSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormSubmissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FormSubmissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormSubmissions
     * const formSubmission = await prisma.formSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormSubmissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FormSubmission.
     * @param {FormSubmissionUpsertArgs} args - Arguments to update or create a FormSubmission.
     * @example
     * // Update or create a FormSubmission
     * const formSubmission = await prisma.formSubmission.upsert({
     *   create: {
     *     // ... data to create a FormSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormSubmission we want to update
     *   }
     * })
    **/
    upsert<T extends FormSubmissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FormSubmissionUpsertArgs<ExtArgs>>
    ): Prisma__FormSubmissionClient<$Types.GetResult<FormSubmissionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionCountArgs} args - Arguments to filter FormSubmissions to count.
     * @example
     * // Count the number of FormSubmissions
     * const count = await prisma.formSubmission.count({
     *   where: {
     *     // ... the filter for the FormSubmissions we want to count
     *   }
     * })
    **/
    count<T extends FormSubmissionCountArgs>(
      args?: Subset<T, FormSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormSubmissionAggregateArgs>(args: Subset<T, FormSubmissionAggregateArgs>): Prisma.PrismaPromise<GetFormSubmissionAggregateType<T>>

    /**
     * Group by FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: FormSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FormSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FormSubmissionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    definition<T extends FormDefinitionArgs<ExtArgs> = {}>(args?: Subset<T, FormDefinitionArgs<ExtArgs>>): Prisma__FormDefinitionClient<$Types.GetResult<FormDefinitionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    documents<T extends FormSubmission$documentsArgs<ExtArgs> = {}>(args?: Subset<T, FormSubmission$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FormSubmission base type for findUnique actions
   */
  export type FormSubmissionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission findUnique
   */
  export interface FormSubmissionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends FormSubmissionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FormSubmission findUniqueOrThrow
   */
  export type FormSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }


  /**
   * FormSubmission base type for findFirst actions
   */
  export type FormSubmissionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: Enumerable<FormSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: Enumerable<FormSubmissionScalarFieldEnum>
  }

  /**
   * FormSubmission findFirst
   */
  export interface FormSubmissionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends FormSubmissionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FormSubmission findFirstOrThrow
   */
  export type FormSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: Enumerable<FormSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: Enumerable<FormSubmissionScalarFieldEnum>
  }


  /**
   * FormSubmission findMany
   */
  export type FormSubmissionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmissions to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: Enumerable<FormSubmissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    distinct?: Enumerable<FormSubmissionScalarFieldEnum>
  }


  /**
   * FormSubmission create
   */
  export type FormSubmissionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a FormSubmission.
     */
    data: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
  }


  /**
   * FormSubmission createMany
   */
  export type FormSubmissionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormSubmissions.
     */
    data: Enumerable<FormSubmissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FormSubmission update
   */
  export type FormSubmissionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a FormSubmission.
     */
    data: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
    /**
     * Choose, which FormSubmission to update.
     */
    where: FormSubmissionWhereUniqueInput
  }


  /**
   * FormSubmission updateMany
   */
  export type FormSubmissionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormSubmissions.
     */
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which FormSubmissions to update
     */
    where?: FormSubmissionWhereInput
  }


  /**
   * FormSubmission upsert
   */
  export type FormSubmissionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the FormSubmission to update in case it exists.
     */
    where: FormSubmissionWhereUniqueInput
    /**
     * In case the FormSubmission found by the `where` argument doesn't exist, create a new FormSubmission with this data.
     */
    create: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
    /**
     * In case the FormSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
  }


  /**
   * FormSubmission delete
   */
  export type FormSubmissionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter which FormSubmission to delete.
     */
    where: FormSubmissionWhereUniqueInput
  }


  /**
   * FormSubmission deleteMany
   */
  export type FormSubmissionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmissions to delete
     */
    where?: FormSubmissionWhereInput
  }


  /**
   * FormSubmission.documents
   */
  export type FormSubmission$documentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * FormSubmission without action
   */
  export type FormSubmissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FormSubmissionInclude<ExtArgs> | null
  }



  /**
   * Model Document
   */


  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    submissionId: string | null
    createdAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    url: string | null
    type: string | null
    submissionId: string | null
    createdAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    url: number
    type: number
    submissionId: number
    createdAt: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    url?: true
    type?: true
    submissionId?: true
    createdAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    url?: true
    type?: true
    submissionId?: true
    createdAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    url?: true
    type?: true
    submissionId?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithAggregationInput>
    by: DocumentScalarFieldEnum[]
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }


  export type DocumentGroupByOutputType = {
    id: string
    url: string
    type: string
    submissionId: string | null
    createdAt: Date
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    submissionId?: boolean
    createdAt?: boolean
    submission?: boolean | FormSubmissionArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    url?: boolean
    type?: boolean
    submissionId?: boolean
    createdAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    submission?: boolean | FormSubmissionArgs<ExtArgs>
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentArgs> = $Types.GetResult<DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    submission<T extends FormSubmissionArgs<ExtArgs> = {}>(args?: Subset<T, FormSubmissionArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Types.GetResult<FormSubmissionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Document base type for findUnique actions
   */
  export type DocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUnique
   */
  export interface DocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document base type for findFirst actions
   */
  export type DocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }

  /**
   * Document findFirst
   */
  export interface DocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: Enumerable<DocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document without action
   */
  export type DocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
  }



  /**
   * Model InventoryItem
   */


  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    quantity?: true
  }

  export type InventoryItemSumAggregateInputType = {
    quantity?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: Enumerable<InventoryItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: Enumerable<InventoryItemOrderByWithAggregationInput>
    by: InventoryItemScalarFieldEnum[]
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }


  export type InventoryItemGroupByOutputType = {
    id: string
    name: string
    description: string | null
    quantity: number
    createdAt: Date
    updatedAt: Date
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemArgs> = $Types.GetResult<InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InventoryItemFindManyArgs, 'select' | 'include'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InventoryItemFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'InventoryItem'> extends True ? Prisma__InventoryItemClient<$Types.GetResult<InventoryItemPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__InventoryItemClient<$Types.GetResult<InventoryItemPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one InventoryItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryItemClient<$Types.GetResult<InventoryItemPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InventoryItemFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'InventoryItem'> extends True ? Prisma__InventoryItemClient<$Types.GetResult<InventoryItemPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__InventoryItemClient<$Types.GetResult<InventoryItemPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryItemClient<$Types.GetResult<InventoryItemPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InventoryItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<InventoryItemPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
    **/
    create<T extends InventoryItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>
    ): Prisma__InventoryItemClient<$Types.GetResult<InventoryItemPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many InventoryItems.
     *     @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     *     @example
     *     // Create many InventoryItems
     *     const inventoryItem = await prisma.inventoryItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InventoryItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
    **/
    delete<T extends InventoryItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>
    ): Prisma__InventoryItemClient<$Types.GetResult<InventoryItemPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InventoryItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>
    ): Prisma__InventoryItemClient<$Types.GetResult<InventoryItemPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InventoryItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InventoryItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
    **/
    upsert<T extends InventoryItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>
    ): Prisma__InventoryItemClient<$Types.GetResult<InventoryItemPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * InventoryItem base type for findUnique actions
   */
  export type InventoryItemFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUnique
   */
  export interface InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InventoryItemFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }


  /**
   * InventoryItem base type for findFirst actions
   */
  export type InventoryItemFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: Enumerable<InventoryItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: Enumerable<InventoryItemScalarFieldEnum>
  }

  /**
   * InventoryItem findFirst
   */
  export interface InventoryItemFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InventoryItemFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: Enumerable<InventoryItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: Enumerable<InventoryItemScalarFieldEnum>
  }


  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: Enumerable<InventoryItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: Enumerable<InventoryItemScalarFieldEnum>
  }


  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }


  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: Enumerable<InventoryItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }


  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
  }


  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }


  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }


  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
  }


  /**
   * InventoryItem without action
   */
  export type InventoryItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
  }



  /**
   * Model EquipmentItem
   */


  export type AggregateEquipmentItem = {
    _count: EquipmentItemCountAggregateOutputType | null
    _min: EquipmentItemMinAggregateOutputType | null
    _max: EquipmentItemMaxAggregateOutputType | null
  }

  export type EquipmentItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    serialNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    serialNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    serialNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipmentItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    serialNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    serialNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    serialNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipmentItemAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentItem to aggregate.
     */
    where?: EquipmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentItems to fetch.
     */
    orderBy?: Enumerable<EquipmentItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentItems
    **/
    _count?: true | EquipmentItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentItemMaxAggregateInputType
  }

  export type GetEquipmentItemAggregateType<T extends EquipmentItemAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentItem[P]>
      : GetScalarType<T[P], AggregateEquipmentItem[P]>
  }




  export type EquipmentItemGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EquipmentItemWhereInput
    orderBy?: Enumerable<EquipmentItemOrderByWithAggregationInput>
    by: EquipmentItemScalarFieldEnum[]
    having?: EquipmentItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentItemCountAggregateInputType | true
    _min?: EquipmentItemMinAggregateInputType
    _max?: EquipmentItemMaxAggregateInputType
  }


  export type EquipmentItemGroupByOutputType = {
    id: string
    name: string
    description: string | null
    serialNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: EquipmentItemCountAggregateOutputType | null
    _min: EquipmentItemMinAggregateOutputType | null
    _max: EquipmentItemMaxAggregateOutputType | null
  }

  type GetEquipmentItemGroupByPayload<T extends EquipmentItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EquipmentItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentItemGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentItemGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentItemSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    serialNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignments?: boolean | EquipmentItem$assignmentsArgs<ExtArgs>
    _count?: boolean | EquipmentItemCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentItem"]>

  export type EquipmentItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    serialNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipmentItemInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    assignments?: boolean | EquipmentItem$assignmentsArgs<ExtArgs>
    _count?: boolean | EquipmentItemCountOutputTypeArgs<ExtArgs>
  }


  type EquipmentItemGetPayload<S extends boolean | null | undefined | EquipmentItemArgs> = $Types.GetResult<EquipmentItemPayload, S>

  type EquipmentItemCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<EquipmentItemFindManyArgs, 'select' | 'include'> & {
      select?: EquipmentItemCountAggregateInputType | true
    }

  export interface EquipmentItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentItem'], meta: { name: 'EquipmentItem' } }
    /**
     * Find zero or one EquipmentItem that matches the filter.
     * @param {EquipmentItemFindUniqueArgs} args - Arguments to find a EquipmentItem
     * @example
     * // Get one EquipmentItem
     * const equipmentItem = await prisma.equipmentItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EquipmentItemFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EquipmentItemFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EquipmentItem'> extends True ? Prisma__EquipmentItemClient<$Types.GetResult<EquipmentItemPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__EquipmentItemClient<$Types.GetResult<EquipmentItemPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one EquipmentItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EquipmentItemFindUniqueOrThrowArgs} args - Arguments to find a EquipmentItem
     * @example
     * // Get one EquipmentItem
     * const equipmentItem = await prisma.equipmentItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EquipmentItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EquipmentItemClient<$Types.GetResult<EquipmentItemPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first EquipmentItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentItemFindFirstArgs} args - Arguments to find a EquipmentItem
     * @example
     * // Get one EquipmentItem
     * const equipmentItem = await prisma.equipmentItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EquipmentItemFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EquipmentItemFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EquipmentItem'> extends True ? Prisma__EquipmentItemClient<$Types.GetResult<EquipmentItemPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__EquipmentItemClient<$Types.GetResult<EquipmentItemPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first EquipmentItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentItemFindFirstOrThrowArgs} args - Arguments to find a EquipmentItem
     * @example
     * // Get one EquipmentItem
     * const equipmentItem = await prisma.equipmentItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EquipmentItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EquipmentItemClient<$Types.GetResult<EquipmentItemPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more EquipmentItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentItems
     * const equipmentItems = await prisma.equipmentItem.findMany()
     * 
     * // Get first 10 EquipmentItems
     * const equipmentItems = await prisma.equipmentItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentItemWithIdOnly = await prisma.equipmentItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EquipmentItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<EquipmentItemPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a EquipmentItem.
     * @param {EquipmentItemCreateArgs} args - Arguments to create a EquipmentItem.
     * @example
     * // Create one EquipmentItem
     * const EquipmentItem = await prisma.equipmentItem.create({
     *   data: {
     *     // ... data to create a EquipmentItem
     *   }
     * })
     * 
    **/
    create<T extends EquipmentItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentItemCreateArgs<ExtArgs>>
    ): Prisma__EquipmentItemClient<$Types.GetResult<EquipmentItemPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many EquipmentItems.
     *     @param {EquipmentItemCreateManyArgs} args - Arguments to create many EquipmentItems.
     *     @example
     *     // Create many EquipmentItems
     *     const equipmentItem = await prisma.equipmentItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EquipmentItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EquipmentItem.
     * @param {EquipmentItemDeleteArgs} args - Arguments to delete one EquipmentItem.
     * @example
     * // Delete one EquipmentItem
     * const EquipmentItem = await prisma.equipmentItem.delete({
     *   where: {
     *     // ... filter to delete one EquipmentItem
     *   }
     * })
     * 
    **/
    delete<T extends EquipmentItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentItemDeleteArgs<ExtArgs>>
    ): Prisma__EquipmentItemClient<$Types.GetResult<EquipmentItemPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one EquipmentItem.
     * @param {EquipmentItemUpdateArgs} args - Arguments to update one EquipmentItem.
     * @example
     * // Update one EquipmentItem
     * const equipmentItem = await prisma.equipmentItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EquipmentItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentItemUpdateArgs<ExtArgs>>
    ): Prisma__EquipmentItemClient<$Types.GetResult<EquipmentItemPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more EquipmentItems.
     * @param {EquipmentItemDeleteManyArgs} args - Arguments to filter EquipmentItems to delete.
     * @example
     * // Delete a few EquipmentItems
     * const { count } = await prisma.equipmentItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EquipmentItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentItems
     * const equipmentItem = await prisma.equipmentItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EquipmentItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EquipmentItem.
     * @param {EquipmentItemUpsertArgs} args - Arguments to update or create a EquipmentItem.
     * @example
     * // Update or create a EquipmentItem
     * const equipmentItem = await prisma.equipmentItem.upsert({
     *   create: {
     *     // ... data to create a EquipmentItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentItem we want to update
     *   }
     * })
    **/
    upsert<T extends EquipmentItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentItemUpsertArgs<ExtArgs>>
    ): Prisma__EquipmentItemClient<$Types.GetResult<EquipmentItemPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of EquipmentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentItemCountArgs} args - Arguments to filter EquipmentItems to count.
     * @example
     * // Count the number of EquipmentItems
     * const count = await prisma.equipmentItem.count({
     *   where: {
     *     // ... the filter for the EquipmentItems we want to count
     *   }
     * })
    **/
    count<T extends EquipmentItemCountArgs>(
      args?: Subset<T, EquipmentItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentItemAggregateArgs>(args: Subset<T, EquipmentItemAggregateArgs>): Prisma.PrismaPromise<GetEquipmentItemAggregateType<T>>

    /**
     * Group by EquipmentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentItemGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EquipmentItemClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    assignments<T extends EquipmentItem$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentItem$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EquipmentAssignmentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * EquipmentItem base type for findUnique actions
   */
  export type EquipmentItemFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentItem
     */
    select?: EquipmentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentItemInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentItem to fetch.
     */
    where: EquipmentItemWhereUniqueInput
  }

  /**
   * EquipmentItem findUnique
   */
  export interface EquipmentItemFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EquipmentItemFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EquipmentItem findUniqueOrThrow
   */
  export type EquipmentItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentItem
     */
    select?: EquipmentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentItemInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentItem to fetch.
     */
    where: EquipmentItemWhereUniqueInput
  }


  /**
   * EquipmentItem base type for findFirst actions
   */
  export type EquipmentItemFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentItem
     */
    select?: EquipmentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentItemInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentItem to fetch.
     */
    where?: EquipmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentItems to fetch.
     */
    orderBy?: Enumerable<EquipmentItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentItems.
     */
    cursor?: EquipmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentItems.
     */
    distinct?: Enumerable<EquipmentItemScalarFieldEnum>
  }

  /**
   * EquipmentItem findFirst
   */
  export interface EquipmentItemFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EquipmentItemFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EquipmentItem findFirstOrThrow
   */
  export type EquipmentItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentItem
     */
    select?: EquipmentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentItemInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentItem to fetch.
     */
    where?: EquipmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentItems to fetch.
     */
    orderBy?: Enumerable<EquipmentItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentItems.
     */
    cursor?: EquipmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentItems.
     */
    distinct?: Enumerable<EquipmentItemScalarFieldEnum>
  }


  /**
   * EquipmentItem findMany
   */
  export type EquipmentItemFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentItem
     */
    select?: EquipmentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentItemInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentItems to fetch.
     */
    where?: EquipmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentItems to fetch.
     */
    orderBy?: Enumerable<EquipmentItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentItems.
     */
    cursor?: EquipmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentItems.
     */
    skip?: number
    distinct?: Enumerable<EquipmentItemScalarFieldEnum>
  }


  /**
   * EquipmentItem create
   */
  export type EquipmentItemCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentItem
     */
    select?: EquipmentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentItemInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentItem.
     */
    data: XOR<EquipmentItemCreateInput, EquipmentItemUncheckedCreateInput>
  }


  /**
   * EquipmentItem createMany
   */
  export type EquipmentItemCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentItems.
     */
    data: Enumerable<EquipmentItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EquipmentItem update
   */
  export type EquipmentItemUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentItem
     */
    select?: EquipmentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentItemInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentItem.
     */
    data: XOR<EquipmentItemUpdateInput, EquipmentItemUncheckedUpdateInput>
    /**
     * Choose, which EquipmentItem to update.
     */
    where: EquipmentItemWhereUniqueInput
  }


  /**
   * EquipmentItem updateMany
   */
  export type EquipmentItemUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentItems.
     */
    data: XOR<EquipmentItemUpdateManyMutationInput, EquipmentItemUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentItems to update
     */
    where?: EquipmentItemWhereInput
  }


  /**
   * EquipmentItem upsert
   */
  export type EquipmentItemUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentItem
     */
    select?: EquipmentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentItemInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentItem to update in case it exists.
     */
    where: EquipmentItemWhereUniqueInput
    /**
     * In case the EquipmentItem found by the `where` argument doesn't exist, create a new EquipmentItem with this data.
     */
    create: XOR<EquipmentItemCreateInput, EquipmentItemUncheckedCreateInput>
    /**
     * In case the EquipmentItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentItemUpdateInput, EquipmentItemUncheckedUpdateInput>
  }


  /**
   * EquipmentItem delete
   */
  export type EquipmentItemDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentItem
     */
    select?: EquipmentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentItemInclude<ExtArgs> | null
    /**
     * Filter which EquipmentItem to delete.
     */
    where: EquipmentItemWhereUniqueInput
  }


  /**
   * EquipmentItem deleteMany
   */
  export type EquipmentItemDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentItems to delete
     */
    where?: EquipmentItemWhereInput
  }


  /**
   * EquipmentItem.assignments
   */
  export type EquipmentItem$assignmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAssignment
     */
    select?: EquipmentAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentAssignmentInclude<ExtArgs> | null
    where?: EquipmentAssignmentWhereInput
    orderBy?: Enumerable<EquipmentAssignmentOrderByWithRelationInput>
    cursor?: EquipmentAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EquipmentAssignmentScalarFieldEnum>
  }


  /**
   * EquipmentItem without action
   */
  export type EquipmentItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentItem
     */
    select?: EquipmentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentItemInclude<ExtArgs> | null
  }



  /**
   * Model EquipmentAssignment
   */


  export type AggregateEquipmentAssignment = {
    _count: EquipmentAssignmentCountAggregateOutputType | null
    _min: EquipmentAssignmentMinAggregateOutputType | null
    _max: EquipmentAssignmentMaxAggregateOutputType | null
  }

  export type EquipmentAssignmentMinAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    assignedTo: string | null
    assignedAt: Date | null
    returnedAt: Date | null
  }

  export type EquipmentAssignmentMaxAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    assignedTo: string | null
    assignedAt: Date | null
    returnedAt: Date | null
  }

  export type EquipmentAssignmentCountAggregateOutputType = {
    id: number
    equipmentId: number
    assignedTo: number
    assignedAt: number
    returnedAt: number
    _all: number
  }


  export type EquipmentAssignmentMinAggregateInputType = {
    id?: true
    equipmentId?: true
    assignedTo?: true
    assignedAt?: true
    returnedAt?: true
  }

  export type EquipmentAssignmentMaxAggregateInputType = {
    id?: true
    equipmentId?: true
    assignedTo?: true
    assignedAt?: true
    returnedAt?: true
  }

  export type EquipmentAssignmentCountAggregateInputType = {
    id?: true
    equipmentId?: true
    assignedTo?: true
    assignedAt?: true
    returnedAt?: true
    _all?: true
  }

  export type EquipmentAssignmentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentAssignment to aggregate.
     */
    where?: EquipmentAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentAssignments to fetch.
     */
    orderBy?: Enumerable<EquipmentAssignmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentAssignments
    **/
    _count?: true | EquipmentAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentAssignmentMaxAggregateInputType
  }

  export type GetEquipmentAssignmentAggregateType<T extends EquipmentAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentAssignment[P]>
      : GetScalarType<T[P], AggregateEquipmentAssignment[P]>
  }




  export type EquipmentAssignmentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EquipmentAssignmentWhereInput
    orderBy?: Enumerable<EquipmentAssignmentOrderByWithAggregationInput>
    by: EquipmentAssignmentScalarFieldEnum[]
    having?: EquipmentAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentAssignmentCountAggregateInputType | true
    _min?: EquipmentAssignmentMinAggregateInputType
    _max?: EquipmentAssignmentMaxAggregateInputType
  }


  export type EquipmentAssignmentGroupByOutputType = {
    id: string
    equipmentId: string
    assignedTo: string
    assignedAt: Date
    returnedAt: Date | null
    _count: EquipmentAssignmentCountAggregateOutputType | null
    _min: EquipmentAssignmentMinAggregateOutputType | null
    _max: EquipmentAssignmentMaxAggregateOutputType | null
  }

  type GetEquipmentAssignmentGroupByPayload<T extends EquipmentAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EquipmentAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentAssignmentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    assignedTo?: boolean
    assignedAt?: boolean
    returnedAt?: boolean
    equipment?: boolean | EquipmentItemArgs<ExtArgs>
    assignedToUser?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentAssignment"]>

  export type EquipmentAssignmentSelectScalar = {
    id?: boolean
    equipmentId?: boolean
    assignedTo?: boolean
    assignedAt?: boolean
    returnedAt?: boolean
  }

  export type EquipmentAssignmentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    equipment?: boolean | EquipmentItemArgs<ExtArgs>
    assignedToUser?: boolean | UserArgs<ExtArgs>
  }


  type EquipmentAssignmentGetPayload<S extends boolean | null | undefined | EquipmentAssignmentArgs> = $Types.GetResult<EquipmentAssignmentPayload, S>

  type EquipmentAssignmentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<EquipmentAssignmentFindManyArgs, 'select' | 'include'> & {
      select?: EquipmentAssignmentCountAggregateInputType | true
    }

  export interface EquipmentAssignmentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentAssignment'], meta: { name: 'EquipmentAssignment' } }
    /**
     * Find zero or one EquipmentAssignment that matches the filter.
     * @param {EquipmentAssignmentFindUniqueArgs} args - Arguments to find a EquipmentAssignment
     * @example
     * // Get one EquipmentAssignment
     * const equipmentAssignment = await prisma.equipmentAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EquipmentAssignmentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EquipmentAssignmentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EquipmentAssignment'> extends True ? Prisma__EquipmentAssignmentClient<$Types.GetResult<EquipmentAssignmentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__EquipmentAssignmentClient<$Types.GetResult<EquipmentAssignmentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one EquipmentAssignment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EquipmentAssignmentFindUniqueOrThrowArgs} args - Arguments to find a EquipmentAssignment
     * @example
     * // Get one EquipmentAssignment
     * const equipmentAssignment = await prisma.equipmentAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EquipmentAssignmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentAssignmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EquipmentAssignmentClient<$Types.GetResult<EquipmentAssignmentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first EquipmentAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAssignmentFindFirstArgs} args - Arguments to find a EquipmentAssignment
     * @example
     * // Get one EquipmentAssignment
     * const equipmentAssignment = await prisma.equipmentAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EquipmentAssignmentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EquipmentAssignmentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EquipmentAssignment'> extends True ? Prisma__EquipmentAssignmentClient<$Types.GetResult<EquipmentAssignmentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__EquipmentAssignmentClient<$Types.GetResult<EquipmentAssignmentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first EquipmentAssignment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAssignmentFindFirstOrThrowArgs} args - Arguments to find a EquipmentAssignment
     * @example
     * // Get one EquipmentAssignment
     * const equipmentAssignment = await prisma.equipmentAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EquipmentAssignmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentAssignmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EquipmentAssignmentClient<$Types.GetResult<EquipmentAssignmentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more EquipmentAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAssignmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentAssignments
     * const equipmentAssignments = await prisma.equipmentAssignment.findMany()
     * 
     * // Get first 10 EquipmentAssignments
     * const equipmentAssignments = await prisma.equipmentAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentAssignmentWithIdOnly = await prisma.equipmentAssignment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EquipmentAssignmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentAssignmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<EquipmentAssignmentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a EquipmentAssignment.
     * @param {EquipmentAssignmentCreateArgs} args - Arguments to create a EquipmentAssignment.
     * @example
     * // Create one EquipmentAssignment
     * const EquipmentAssignment = await prisma.equipmentAssignment.create({
     *   data: {
     *     // ... data to create a EquipmentAssignment
     *   }
     * })
     * 
    **/
    create<T extends EquipmentAssignmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentAssignmentCreateArgs<ExtArgs>>
    ): Prisma__EquipmentAssignmentClient<$Types.GetResult<EquipmentAssignmentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many EquipmentAssignments.
     *     @param {EquipmentAssignmentCreateManyArgs} args - Arguments to create many EquipmentAssignments.
     *     @example
     *     // Create many EquipmentAssignments
     *     const equipmentAssignment = await prisma.equipmentAssignment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EquipmentAssignmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentAssignmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EquipmentAssignment.
     * @param {EquipmentAssignmentDeleteArgs} args - Arguments to delete one EquipmentAssignment.
     * @example
     * // Delete one EquipmentAssignment
     * const EquipmentAssignment = await prisma.equipmentAssignment.delete({
     *   where: {
     *     // ... filter to delete one EquipmentAssignment
     *   }
     * })
     * 
    **/
    delete<T extends EquipmentAssignmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentAssignmentDeleteArgs<ExtArgs>>
    ): Prisma__EquipmentAssignmentClient<$Types.GetResult<EquipmentAssignmentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one EquipmentAssignment.
     * @param {EquipmentAssignmentUpdateArgs} args - Arguments to update one EquipmentAssignment.
     * @example
     * // Update one EquipmentAssignment
     * const equipmentAssignment = await prisma.equipmentAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EquipmentAssignmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentAssignmentUpdateArgs<ExtArgs>>
    ): Prisma__EquipmentAssignmentClient<$Types.GetResult<EquipmentAssignmentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more EquipmentAssignments.
     * @param {EquipmentAssignmentDeleteManyArgs} args - Arguments to filter EquipmentAssignments to delete.
     * @example
     * // Delete a few EquipmentAssignments
     * const { count } = await prisma.equipmentAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EquipmentAssignmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EquipmentAssignmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentAssignments
     * const equipmentAssignment = await prisma.equipmentAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EquipmentAssignmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentAssignmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EquipmentAssignment.
     * @param {EquipmentAssignmentUpsertArgs} args - Arguments to update or create a EquipmentAssignment.
     * @example
     * // Update or create a EquipmentAssignment
     * const equipmentAssignment = await prisma.equipmentAssignment.upsert({
     *   create: {
     *     // ... data to create a EquipmentAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentAssignment we want to update
     *   }
     * })
    **/
    upsert<T extends EquipmentAssignmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EquipmentAssignmentUpsertArgs<ExtArgs>>
    ): Prisma__EquipmentAssignmentClient<$Types.GetResult<EquipmentAssignmentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of EquipmentAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAssignmentCountArgs} args - Arguments to filter EquipmentAssignments to count.
     * @example
     * // Count the number of EquipmentAssignments
     * const count = await prisma.equipmentAssignment.count({
     *   where: {
     *     // ... the filter for the EquipmentAssignments we want to count
     *   }
     * })
    **/
    count<T extends EquipmentAssignmentCountArgs>(
      args?: Subset<T, EquipmentAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAssignmentAggregateArgs>(args: Subset<T, EquipmentAssignmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAssignmentAggregateType<T>>

    /**
     * Group by EquipmentAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EquipmentAssignmentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    equipment<T extends EquipmentItemArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentItemArgs<ExtArgs>>): Prisma__EquipmentItemClient<$Types.GetResult<EquipmentItemPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    assignedToUser<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * EquipmentAssignment base type for findUnique actions
   */
  export type EquipmentAssignmentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAssignment
     */
    select?: EquipmentAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentAssignment to fetch.
     */
    where: EquipmentAssignmentWhereUniqueInput
  }

  /**
   * EquipmentAssignment findUnique
   */
  export interface EquipmentAssignmentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EquipmentAssignmentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EquipmentAssignment findUniqueOrThrow
   */
  export type EquipmentAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAssignment
     */
    select?: EquipmentAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentAssignment to fetch.
     */
    where: EquipmentAssignmentWhereUniqueInput
  }


  /**
   * EquipmentAssignment base type for findFirst actions
   */
  export type EquipmentAssignmentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAssignment
     */
    select?: EquipmentAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentAssignment to fetch.
     */
    where?: EquipmentAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentAssignments to fetch.
     */
    orderBy?: Enumerable<EquipmentAssignmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentAssignments.
     */
    cursor?: EquipmentAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentAssignments.
     */
    distinct?: Enumerable<EquipmentAssignmentScalarFieldEnum>
  }

  /**
   * EquipmentAssignment findFirst
   */
  export interface EquipmentAssignmentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EquipmentAssignmentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EquipmentAssignment findFirstOrThrow
   */
  export type EquipmentAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAssignment
     */
    select?: EquipmentAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentAssignment to fetch.
     */
    where?: EquipmentAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentAssignments to fetch.
     */
    orderBy?: Enumerable<EquipmentAssignmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentAssignments.
     */
    cursor?: EquipmentAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentAssignments.
     */
    distinct?: Enumerable<EquipmentAssignmentScalarFieldEnum>
  }


  /**
   * EquipmentAssignment findMany
   */
  export type EquipmentAssignmentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAssignment
     */
    select?: EquipmentAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentAssignments to fetch.
     */
    where?: EquipmentAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentAssignments to fetch.
     */
    orderBy?: Enumerable<EquipmentAssignmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentAssignments.
     */
    cursor?: EquipmentAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentAssignments.
     */
    skip?: number
    distinct?: Enumerable<EquipmentAssignmentScalarFieldEnum>
  }


  /**
   * EquipmentAssignment create
   */
  export type EquipmentAssignmentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAssignment
     */
    select?: EquipmentAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentAssignment.
     */
    data: XOR<EquipmentAssignmentCreateInput, EquipmentAssignmentUncheckedCreateInput>
  }


  /**
   * EquipmentAssignment createMany
   */
  export type EquipmentAssignmentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentAssignments.
     */
    data: Enumerable<EquipmentAssignmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EquipmentAssignment update
   */
  export type EquipmentAssignmentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAssignment
     */
    select?: EquipmentAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentAssignment.
     */
    data: XOR<EquipmentAssignmentUpdateInput, EquipmentAssignmentUncheckedUpdateInput>
    /**
     * Choose, which EquipmentAssignment to update.
     */
    where: EquipmentAssignmentWhereUniqueInput
  }


  /**
   * EquipmentAssignment updateMany
   */
  export type EquipmentAssignmentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentAssignments.
     */
    data: XOR<EquipmentAssignmentUpdateManyMutationInput, EquipmentAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentAssignments to update
     */
    where?: EquipmentAssignmentWhereInput
  }


  /**
   * EquipmentAssignment upsert
   */
  export type EquipmentAssignmentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAssignment
     */
    select?: EquipmentAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentAssignment to update in case it exists.
     */
    where: EquipmentAssignmentWhereUniqueInput
    /**
     * In case the EquipmentAssignment found by the `where` argument doesn't exist, create a new EquipmentAssignment with this data.
     */
    create: XOR<EquipmentAssignmentCreateInput, EquipmentAssignmentUncheckedCreateInput>
    /**
     * In case the EquipmentAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentAssignmentUpdateInput, EquipmentAssignmentUncheckedUpdateInput>
  }


  /**
   * EquipmentAssignment delete
   */
  export type EquipmentAssignmentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAssignment
     */
    select?: EquipmentAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentAssignmentInclude<ExtArgs> | null
    /**
     * Filter which EquipmentAssignment to delete.
     */
    where: EquipmentAssignmentWhereUniqueInput
  }


  /**
   * EquipmentAssignment deleteMany
   */
  export type EquipmentAssignmentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentAssignments to delete
     */
    where?: EquipmentAssignmentWhereInput
  }


  /**
   * EquipmentAssignment without action
   */
  export type EquipmentAssignmentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAssignment
     */
    select?: EquipmentAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EquipmentAssignmentInclude<ExtArgs> | null
  }



  /**
   * Model Post
   */


  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    authorId: number
    content: number
    createdAt: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    createdAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    createdAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithAggregationInput>
    by: PostScalarFieldEnum[]
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }


  export type PostGroupByOutputType = {
    id: string
    authorId: string
    content: string
    createdAt: Date
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    author?: boolean | UserArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type PostInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    author?: boolean | UserArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeArgs<ExtArgs>
  }


  type PostGetPayload<S extends boolean | null | undefined | PostArgs> = $Types.GetResult<PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PostFindManyArgs, 'select' | 'include'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Post'> extends True ? Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Post that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Post'> extends True ? Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Post that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PostPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
    **/
    create<T extends PostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PostCreateArgs<ExtArgs>>
    ): Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Posts.
     *     @param {PostCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const post = await prisma.post.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
    **/
    delete<T extends PostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PostDeleteArgs<ExtArgs>>
    ): Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpdateArgs<ExtArgs>>
    ): Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
    **/
    upsert<T extends PostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PostUpsertArgs<ExtArgs>>
    ): Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    author<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Post base type for findUnique actions
   */
  export type PostFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUnique
   */
  export interface PostFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PostFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post base type for findFirst actions
   */
  export type PostFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: Enumerable<PostScalarFieldEnum>
  }

  /**
   * Post findFirst
   */
  export interface PostFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PostFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }


  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: Enumerable<PostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }


  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }


  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }


  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Post without action
   */
  export type PostArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude<ExtArgs> | null
  }



  /**
   * Model Comment
   */


  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    postId: number
    authorId: number
    content: number
    createdAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    createdAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    createdAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithAggregationInput>
    by: CommentScalarFieldEnum[]
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }


  export type CommentGroupByOutputType = {
    id: string
    postId: string
    authorId: string
    content: string
    createdAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    post?: boolean | PostArgs<ExtArgs>
    author?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    post?: boolean | PostArgs<ExtArgs>
    author?: boolean | UserArgs<ExtArgs>
  }


  type CommentGetPayload<S extends boolean | null | undefined | CommentArgs> = $Types.GetResult<CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Comment'> extends True ? Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Comment'> extends True ? Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    post<T extends PostArgs<ExtArgs> = {}>(args?: Subset<T, PostArgs<ExtArgs>>): Prisma__PostClient<$Types.GetResult<PostPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    author<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Comment base type for findUnique actions
   */
  export type CommentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUnique
   */
  export interface CommentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CommentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment base type for findFirst actions
   */
  export type CommentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: Enumerable<CommentScalarFieldEnum>
  }

  /**
   * Comment findFirst
   */
  export interface CommentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CommentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: Enumerable<CommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment without action
   */
  export type CommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
  }



  /**
   * Model CommunityEvent
   */


  export type AggregateCommunityEvent = {
    _count: CommunityEventCountAggregateOutputType | null
    _min: CommunityEventMinAggregateOutputType | null
    _max: CommunityEventMaxAggregateOutputType | null
  }

  export type CommunityEventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startAt: Date | null
    endAt: Date | null
    location: string | null
    createdAt: Date | null
  }

  export type CommunityEventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startAt: Date | null
    endAt: Date | null
    location: string | null
    createdAt: Date | null
  }

  export type CommunityEventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startAt: number
    endAt: number
    location: number
    createdAt: number
    _all: number
  }


  export type CommunityEventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startAt?: true
    endAt?: true
    location?: true
    createdAt?: true
  }

  export type CommunityEventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startAt?: true
    endAt?: true
    location?: true
    createdAt?: true
  }

  export type CommunityEventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startAt?: true
    endAt?: true
    location?: true
    createdAt?: true
    _all?: true
  }

  export type CommunityEventAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityEvent to aggregate.
     */
    where?: CommunityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityEvents to fetch.
     */
    orderBy?: Enumerable<CommunityEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityEvents
    **/
    _count?: true | CommunityEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityEventMaxAggregateInputType
  }

  export type GetCommunityEventAggregateType<T extends CommunityEventAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityEvent[P]>
      : GetScalarType<T[P], AggregateCommunityEvent[P]>
  }




  export type CommunityEventGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommunityEventWhereInput
    orderBy?: Enumerable<CommunityEventOrderByWithAggregationInput>
    by: CommunityEventScalarFieldEnum[]
    having?: CommunityEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityEventCountAggregateInputType | true
    _min?: CommunityEventMinAggregateInputType
    _max?: CommunityEventMaxAggregateInputType
  }


  export type CommunityEventGroupByOutputType = {
    id: string
    title: string
    description: string | null
    startAt: Date
    endAt: Date | null
    location: string | null
    createdAt: Date
    _count: CommunityEventCountAggregateOutputType | null
    _min: CommunityEventMinAggregateOutputType | null
    _max: CommunityEventMaxAggregateOutputType | null
  }

  type GetCommunityEventGroupByPayload<T extends CommunityEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommunityEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityEventGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityEventGroupByOutputType[P]>
        }
      >
    >


  export type CommunityEventSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startAt?: boolean
    endAt?: boolean
    location?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["communityEvent"]>

  export type CommunityEventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startAt?: boolean
    endAt?: boolean
    location?: boolean
    createdAt?: boolean
  }


  type CommunityEventGetPayload<S extends boolean | null | undefined | CommunityEventArgs> = $Types.GetResult<CommunityEventPayload, S>

  type CommunityEventCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CommunityEventFindManyArgs, 'select' | 'include'> & {
      select?: CommunityEventCountAggregateInputType | true
    }

  export interface CommunityEventDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityEvent'], meta: { name: 'CommunityEvent' } }
    /**
     * Find zero or one CommunityEvent that matches the filter.
     * @param {CommunityEventFindUniqueArgs} args - Arguments to find a CommunityEvent
     * @example
     * // Get one CommunityEvent
     * const communityEvent = await prisma.communityEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommunityEventFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommunityEventFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommunityEvent'> extends True ? Prisma__CommunityEventClient<$Types.GetResult<CommunityEventPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CommunityEventClient<$Types.GetResult<CommunityEventPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one CommunityEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommunityEventFindUniqueOrThrowArgs} args - Arguments to find a CommunityEvent
     * @example
     * // Get one CommunityEvent
     * const communityEvent = await prisma.communityEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommunityEventFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityEventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityEventClient<$Types.GetResult<CommunityEventPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first CommunityEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventFindFirstArgs} args - Arguments to find a CommunityEvent
     * @example
     * // Get one CommunityEvent
     * const communityEvent = await prisma.communityEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommunityEventFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommunityEventFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommunityEvent'> extends True ? Prisma__CommunityEventClient<$Types.GetResult<CommunityEventPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CommunityEventClient<$Types.GetResult<CommunityEventPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first CommunityEvent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventFindFirstOrThrowArgs} args - Arguments to find a CommunityEvent
     * @example
     * // Get one CommunityEvent
     * const communityEvent = await prisma.communityEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommunityEventFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityEventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityEventClient<$Types.GetResult<CommunityEventPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more CommunityEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityEvents
     * const communityEvents = await prisma.communityEvent.findMany()
     * 
     * // Get first 10 CommunityEvents
     * const communityEvents = await prisma.communityEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityEventWithIdOnly = await prisma.communityEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommunityEventFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityEventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CommunityEventPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a CommunityEvent.
     * @param {CommunityEventCreateArgs} args - Arguments to create a CommunityEvent.
     * @example
     * // Create one CommunityEvent
     * const CommunityEvent = await prisma.communityEvent.create({
     *   data: {
     *     // ... data to create a CommunityEvent
     *   }
     * })
     * 
    **/
    create<T extends CommunityEventCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityEventCreateArgs<ExtArgs>>
    ): Prisma__CommunityEventClient<$Types.GetResult<CommunityEventPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many CommunityEvents.
     *     @param {CommunityEventCreateManyArgs} args - Arguments to create many CommunityEvents.
     *     @example
     *     // Create many CommunityEvents
     *     const communityEvent = await prisma.communityEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommunityEventCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityEventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommunityEvent.
     * @param {CommunityEventDeleteArgs} args - Arguments to delete one CommunityEvent.
     * @example
     * // Delete one CommunityEvent
     * const CommunityEvent = await prisma.communityEvent.delete({
     *   where: {
     *     // ... filter to delete one CommunityEvent
     *   }
     * })
     * 
    **/
    delete<T extends CommunityEventDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityEventDeleteArgs<ExtArgs>>
    ): Prisma__CommunityEventClient<$Types.GetResult<CommunityEventPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one CommunityEvent.
     * @param {CommunityEventUpdateArgs} args - Arguments to update one CommunityEvent.
     * @example
     * // Update one CommunityEvent
     * const communityEvent = await prisma.communityEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommunityEventUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityEventUpdateArgs<ExtArgs>>
    ): Prisma__CommunityEventClient<$Types.GetResult<CommunityEventPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more CommunityEvents.
     * @param {CommunityEventDeleteManyArgs} args - Arguments to filter CommunityEvents to delete.
     * @example
     * // Delete a few CommunityEvents
     * const { count } = await prisma.communityEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommunityEventDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommunityEventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityEvents
     * const communityEvent = await prisma.communityEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommunityEventUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityEventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityEvent.
     * @param {CommunityEventUpsertArgs} args - Arguments to update or create a CommunityEvent.
     * @example
     * // Update or create a CommunityEvent
     * const communityEvent = await prisma.communityEvent.upsert({
     *   create: {
     *     // ... data to create a CommunityEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityEvent we want to update
     *   }
     * })
    **/
    upsert<T extends CommunityEventUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommunityEventUpsertArgs<ExtArgs>>
    ): Prisma__CommunityEventClient<$Types.GetResult<CommunityEventPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of CommunityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventCountArgs} args - Arguments to filter CommunityEvents to count.
     * @example
     * // Count the number of CommunityEvents
     * const count = await prisma.communityEvent.count({
     *   where: {
     *     // ... the filter for the CommunityEvents we want to count
     *   }
     * })
    **/
    count<T extends CommunityEventCountArgs>(
      args?: Subset<T, CommunityEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityEventAggregateArgs>(args: Subset<T, CommunityEventAggregateArgs>): Prisma.PrismaPromise<GetCommunityEventAggregateType<T>>

    /**
     * Group by CommunityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityEventGroupByArgs['orderBy'] }
        : { orderBy?: CommunityEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommunityEventClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CommunityEvent base type for findUnique actions
   */
  export type CommunityEventFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Filter, which CommunityEvent to fetch.
     */
    where: CommunityEventWhereUniqueInput
  }

  /**
   * CommunityEvent findUnique
   */
  export interface CommunityEventFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CommunityEventFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CommunityEvent findUniqueOrThrow
   */
  export type CommunityEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Filter, which CommunityEvent to fetch.
     */
    where: CommunityEventWhereUniqueInput
  }


  /**
   * CommunityEvent base type for findFirst actions
   */
  export type CommunityEventFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Filter, which CommunityEvent to fetch.
     */
    where?: CommunityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityEvents to fetch.
     */
    orderBy?: Enumerable<CommunityEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityEvents.
     */
    cursor?: CommunityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityEvents.
     */
    distinct?: Enumerable<CommunityEventScalarFieldEnum>
  }

  /**
   * CommunityEvent findFirst
   */
  export interface CommunityEventFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CommunityEventFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CommunityEvent findFirstOrThrow
   */
  export type CommunityEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Filter, which CommunityEvent to fetch.
     */
    where?: CommunityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityEvents to fetch.
     */
    orderBy?: Enumerable<CommunityEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityEvents.
     */
    cursor?: CommunityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityEvents.
     */
    distinct?: Enumerable<CommunityEventScalarFieldEnum>
  }


  /**
   * CommunityEvent findMany
   */
  export type CommunityEventFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Filter, which CommunityEvents to fetch.
     */
    where?: CommunityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityEvents to fetch.
     */
    orderBy?: Enumerable<CommunityEventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityEvents.
     */
    cursor?: CommunityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityEvents.
     */
    skip?: number
    distinct?: Enumerable<CommunityEventScalarFieldEnum>
  }


  /**
   * CommunityEvent create
   */
  export type CommunityEventCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * The data needed to create a CommunityEvent.
     */
    data: XOR<CommunityEventCreateInput, CommunityEventUncheckedCreateInput>
  }


  /**
   * CommunityEvent createMany
   */
  export type CommunityEventCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityEvents.
     */
    data: Enumerable<CommunityEventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommunityEvent update
   */
  export type CommunityEventUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * The data needed to update a CommunityEvent.
     */
    data: XOR<CommunityEventUpdateInput, CommunityEventUncheckedUpdateInput>
    /**
     * Choose, which CommunityEvent to update.
     */
    where: CommunityEventWhereUniqueInput
  }


  /**
   * CommunityEvent updateMany
   */
  export type CommunityEventUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityEvents.
     */
    data: XOR<CommunityEventUpdateManyMutationInput, CommunityEventUncheckedUpdateManyInput>
    /**
     * Filter which CommunityEvents to update
     */
    where?: CommunityEventWhereInput
  }


  /**
   * CommunityEvent upsert
   */
  export type CommunityEventUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * The filter to search for the CommunityEvent to update in case it exists.
     */
    where: CommunityEventWhereUniqueInput
    /**
     * In case the CommunityEvent found by the `where` argument doesn't exist, create a new CommunityEvent with this data.
     */
    create: XOR<CommunityEventCreateInput, CommunityEventUncheckedCreateInput>
    /**
     * In case the CommunityEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityEventUpdateInput, CommunityEventUncheckedUpdateInput>
  }


  /**
   * CommunityEvent delete
   */
  export type CommunityEventDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Filter which CommunityEvent to delete.
     */
    where: CommunityEventWhereUniqueInput
  }


  /**
   * CommunityEvent deleteMany
   */
  export type CommunityEventDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityEvents to delete
     */
    where?: CommunityEventWhereInput
  }


  /**
   * CommunityEvent without action
   */
  export type CommunityEventArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
  }



  /**
   * Model SocialPost
   */


  export type AggregateSocialPost = {
    _count: SocialPostCountAggregateOutputType | null
    _min: SocialPostMinAggregateOutputType | null
    _max: SocialPostMaxAggregateOutputType | null
  }

  export type SocialPostMinAggregateOutputType = {
    id: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialPostMaxAggregateOutputType = {
    id: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialPostCountAggregateOutputType = {
    id: number
    authorId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialPostMinAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialPostMaxAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialPostCountAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialPostAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialPost to aggregate.
     */
    where?: SocialPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialPosts to fetch.
     */
    orderBy?: Enumerable<SocialPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialPosts
    **/
    _count?: true | SocialPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialPostMaxAggregateInputType
  }

  export type GetSocialPostAggregateType<T extends SocialPostAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialPost[P]>
      : GetScalarType<T[P], AggregateSocialPost[P]>
  }




  export type SocialPostGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SocialPostWhereInput
    orderBy?: Enumerable<SocialPostOrderByWithAggregationInput>
    by: SocialPostScalarFieldEnum[]
    having?: SocialPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialPostCountAggregateInputType | true
    _min?: SocialPostMinAggregateInputType
    _max?: SocialPostMaxAggregateInputType
  }


  export type SocialPostGroupByOutputType = {
    id: string
    authorId: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: SocialPostCountAggregateOutputType | null
    _min: SocialPostMinAggregateOutputType | null
    _max: SocialPostMaxAggregateOutputType | null
  }

  type GetSocialPostGroupByPayload<T extends SocialPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SocialPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialPostGroupByOutputType[P]>
            : GetScalarType<T[P], SocialPostGroupByOutputType[P]>
        }
      >
    >


  export type SocialPostSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserArgs<ExtArgs>
    comments?: boolean | SocialPost$commentsArgs<ExtArgs>
    _count?: boolean | SocialPostCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["socialPost"]>

  export type SocialPostSelectScalar = {
    id?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocialPostInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    author?: boolean | UserArgs<ExtArgs>
    comments?: boolean | SocialPost$commentsArgs<ExtArgs>
    _count?: boolean | SocialPostCountOutputTypeArgs<ExtArgs>
  }


  type SocialPostGetPayload<S extends boolean | null | undefined | SocialPostArgs> = $Types.GetResult<SocialPostPayload, S>

  type SocialPostCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SocialPostFindManyArgs, 'select' | 'include'> & {
      select?: SocialPostCountAggregateInputType | true
    }

  export interface SocialPostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialPost'], meta: { name: 'SocialPost' } }
    /**
     * Find zero or one SocialPost that matches the filter.
     * @param {SocialPostFindUniqueArgs} args - Arguments to find a SocialPost
     * @example
     * // Get one SocialPost
     * const socialPost = await prisma.socialPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SocialPostFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SocialPostFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SocialPost'> extends True ? Prisma__SocialPostClient<$Types.GetResult<SocialPostPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__SocialPostClient<$Types.GetResult<SocialPostPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one SocialPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SocialPostFindUniqueOrThrowArgs} args - Arguments to find a SocialPost
     * @example
     * // Get one SocialPost
     * const socialPost = await prisma.socialPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SocialPostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialPostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SocialPostClient<$Types.GetResult<SocialPostPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first SocialPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPostFindFirstArgs} args - Arguments to find a SocialPost
     * @example
     * // Get one SocialPost
     * const socialPost = await prisma.socialPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SocialPostFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SocialPostFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SocialPost'> extends True ? Prisma__SocialPostClient<$Types.GetResult<SocialPostPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__SocialPostClient<$Types.GetResult<SocialPostPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first SocialPost that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPostFindFirstOrThrowArgs} args - Arguments to find a SocialPost
     * @example
     * // Get one SocialPost
     * const socialPost = await prisma.socialPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SocialPostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialPostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SocialPostClient<$Types.GetResult<SocialPostPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more SocialPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialPosts
     * const socialPosts = await prisma.socialPost.findMany()
     * 
     * // Get first 10 SocialPosts
     * const socialPosts = await prisma.socialPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialPostWithIdOnly = await prisma.socialPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SocialPostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialPostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SocialPostPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a SocialPost.
     * @param {SocialPostCreateArgs} args - Arguments to create a SocialPost.
     * @example
     * // Create one SocialPost
     * const SocialPost = await prisma.socialPost.create({
     *   data: {
     *     // ... data to create a SocialPost
     *   }
     * })
     * 
    **/
    create<T extends SocialPostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SocialPostCreateArgs<ExtArgs>>
    ): Prisma__SocialPostClient<$Types.GetResult<SocialPostPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many SocialPosts.
     *     @param {SocialPostCreateManyArgs} args - Arguments to create many SocialPosts.
     *     @example
     *     // Create many SocialPosts
     *     const socialPost = await prisma.socialPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SocialPostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialPostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SocialPost.
     * @param {SocialPostDeleteArgs} args - Arguments to delete one SocialPost.
     * @example
     * // Delete one SocialPost
     * const SocialPost = await prisma.socialPost.delete({
     *   where: {
     *     // ... filter to delete one SocialPost
     *   }
     * })
     * 
    **/
    delete<T extends SocialPostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SocialPostDeleteArgs<ExtArgs>>
    ): Prisma__SocialPostClient<$Types.GetResult<SocialPostPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one SocialPost.
     * @param {SocialPostUpdateArgs} args - Arguments to update one SocialPost.
     * @example
     * // Update one SocialPost
     * const socialPost = await prisma.socialPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SocialPostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SocialPostUpdateArgs<ExtArgs>>
    ): Prisma__SocialPostClient<$Types.GetResult<SocialPostPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more SocialPosts.
     * @param {SocialPostDeleteManyArgs} args - Arguments to filter SocialPosts to delete.
     * @example
     * // Delete a few SocialPosts
     * const { count } = await prisma.socialPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SocialPostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialPostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialPosts
     * const socialPost = await prisma.socialPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SocialPostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SocialPostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SocialPost.
     * @param {SocialPostUpsertArgs} args - Arguments to update or create a SocialPost.
     * @example
     * // Update or create a SocialPost
     * const socialPost = await prisma.socialPost.upsert({
     *   create: {
     *     // ... data to create a SocialPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialPost we want to update
     *   }
     * })
    **/
    upsert<T extends SocialPostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SocialPostUpsertArgs<ExtArgs>>
    ): Prisma__SocialPostClient<$Types.GetResult<SocialPostPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of SocialPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPostCountArgs} args - Arguments to filter SocialPosts to count.
     * @example
     * // Count the number of SocialPosts
     * const count = await prisma.socialPost.count({
     *   where: {
     *     // ... the filter for the SocialPosts we want to count
     *   }
     * })
    **/
    count<T extends SocialPostCountArgs>(
      args?: Subset<T, SocialPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialPostAggregateArgs>(args: Subset<T, SocialPostAggregateArgs>): Prisma.PrismaPromise<GetSocialPostAggregateType<T>>

    /**
     * Group by SocialPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialPostGroupByArgs['orderBy'] }
        : { orderBy?: SocialPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SocialPostClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    author<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    comments<T extends SocialPost$commentsArgs<ExtArgs> = {}>(args?: Subset<T, SocialPost$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PostCommentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SocialPost base type for findUnique actions
   */
  export type SocialPostFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * Filter, which SocialPost to fetch.
     */
    where: SocialPostWhereUniqueInput
  }

  /**
   * SocialPost findUnique
   */
  export interface SocialPostFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SocialPostFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SocialPost findUniqueOrThrow
   */
  export type SocialPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * Filter, which SocialPost to fetch.
     */
    where: SocialPostWhereUniqueInput
  }


  /**
   * SocialPost base type for findFirst actions
   */
  export type SocialPostFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * Filter, which SocialPost to fetch.
     */
    where?: SocialPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialPosts to fetch.
     */
    orderBy?: Enumerable<SocialPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialPosts.
     */
    cursor?: SocialPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialPosts.
     */
    distinct?: Enumerable<SocialPostScalarFieldEnum>
  }

  /**
   * SocialPost findFirst
   */
  export interface SocialPostFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SocialPostFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SocialPost findFirstOrThrow
   */
  export type SocialPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * Filter, which SocialPost to fetch.
     */
    where?: SocialPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialPosts to fetch.
     */
    orderBy?: Enumerable<SocialPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialPosts.
     */
    cursor?: SocialPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialPosts.
     */
    distinct?: Enumerable<SocialPostScalarFieldEnum>
  }


  /**
   * SocialPost findMany
   */
  export type SocialPostFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * Filter, which SocialPosts to fetch.
     */
    where?: SocialPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialPosts to fetch.
     */
    orderBy?: Enumerable<SocialPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialPosts.
     */
    cursor?: SocialPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialPosts.
     */
    skip?: number
    distinct?: Enumerable<SocialPostScalarFieldEnum>
  }


  /**
   * SocialPost create
   */
  export type SocialPostCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialPost.
     */
    data: XOR<SocialPostCreateInput, SocialPostUncheckedCreateInput>
  }


  /**
   * SocialPost createMany
   */
  export type SocialPostCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialPosts.
     */
    data: Enumerable<SocialPostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SocialPost update
   */
  export type SocialPostUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialPost.
     */
    data: XOR<SocialPostUpdateInput, SocialPostUncheckedUpdateInput>
    /**
     * Choose, which SocialPost to update.
     */
    where: SocialPostWhereUniqueInput
  }


  /**
   * SocialPost updateMany
   */
  export type SocialPostUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialPosts.
     */
    data: XOR<SocialPostUpdateManyMutationInput, SocialPostUncheckedUpdateManyInput>
    /**
     * Filter which SocialPosts to update
     */
    where?: SocialPostWhereInput
  }


  /**
   * SocialPost upsert
   */
  export type SocialPostUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialPost to update in case it exists.
     */
    where: SocialPostWhereUniqueInput
    /**
     * In case the SocialPost found by the `where` argument doesn't exist, create a new SocialPost with this data.
     */
    create: XOR<SocialPostCreateInput, SocialPostUncheckedCreateInput>
    /**
     * In case the SocialPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialPostUpdateInput, SocialPostUncheckedUpdateInput>
  }


  /**
   * SocialPost delete
   */
  export type SocialPostDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * Filter which SocialPost to delete.
     */
    where: SocialPostWhereUniqueInput
  }


  /**
   * SocialPost deleteMany
   */
  export type SocialPostDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialPosts to delete
     */
    where?: SocialPostWhereInput
  }


  /**
   * SocialPost.comments
   */
  export type SocialPost$commentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostCommentInclude<ExtArgs> | null
    where?: PostCommentWhereInput
    orderBy?: Enumerable<PostCommentOrderByWithRelationInput>
    cursor?: PostCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostCommentScalarFieldEnum>
  }


  /**
   * SocialPost without action
   */
  export type SocialPostArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialPostInclude<ExtArgs> | null
  }



  /**
   * Model PostComment
   */


  export type AggregatePostComment = {
    _count: PostCommentCountAggregateOutputType | null
    _min: PostCommentMinAggregateOutputType | null
    _max: PostCommentMaxAggregateOutputType | null
  }

  export type PostCommentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type PostCommentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type PostCommentCountAggregateOutputType = {
    id: number
    postId: number
    authorId: number
    content: number
    createdAt: number
    _all: number
  }


  export type PostCommentMinAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    createdAt?: true
  }

  export type PostCommentMaxAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    createdAt?: true
  }

  export type PostCommentCountAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type PostCommentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostComment to aggregate.
     */
    where?: PostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostComments to fetch.
     */
    orderBy?: Enumerable<PostCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostComments
    **/
    _count?: true | PostCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostCommentMaxAggregateInputType
  }

  export type GetPostCommentAggregateType<T extends PostCommentAggregateArgs> = {
        [P in keyof T & keyof AggregatePostComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostComment[P]>
      : GetScalarType<T[P], AggregatePostComment[P]>
  }




  export type PostCommentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PostCommentWhereInput
    orderBy?: Enumerable<PostCommentOrderByWithAggregationInput>
    by: PostCommentScalarFieldEnum[]
    having?: PostCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCommentCountAggregateInputType | true
    _min?: PostCommentMinAggregateInputType
    _max?: PostCommentMaxAggregateInputType
  }


  export type PostCommentGroupByOutputType = {
    id: string
    postId: string
    authorId: string
    content: string
    createdAt: Date
    _count: PostCommentCountAggregateOutputType | null
    _min: PostCommentMinAggregateOutputType | null
    _max: PostCommentMaxAggregateOutputType | null
  }

  type GetPostCommentGroupByPayload<T extends PostCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PostCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostCommentGroupByOutputType[P]>
            : GetScalarType<T[P], PostCommentGroupByOutputType[P]>
        }
      >
    >


  export type PostCommentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    post?: boolean | SocialPostArgs<ExtArgs>
    author?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["postComment"]>

  export type PostCommentSelectScalar = {
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type PostCommentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    post?: boolean | SocialPostArgs<ExtArgs>
    author?: boolean | UserArgs<ExtArgs>
  }


  type PostCommentGetPayload<S extends boolean | null | undefined | PostCommentArgs> = $Types.GetResult<PostCommentPayload, S>

  type PostCommentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PostCommentFindManyArgs, 'select' | 'include'> & {
      select?: PostCommentCountAggregateInputType | true
    }

  export interface PostCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostComment'], meta: { name: 'PostComment' } }
    /**
     * Find zero or one PostComment that matches the filter.
     * @param {PostCommentFindUniqueArgs} args - Arguments to find a PostComment
     * @example
     * // Get one PostComment
     * const postComment = await prisma.postComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostCommentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostCommentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PostComment'> extends True ? Prisma__PostCommentClient<$Types.GetResult<PostCommentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PostCommentClient<$Types.GetResult<PostCommentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one PostComment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostCommentFindUniqueOrThrowArgs} args - Arguments to find a PostComment
     * @example
     * // Get one PostComment
     * const postComment = await prisma.postComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostCommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PostCommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PostCommentClient<$Types.GetResult<PostCommentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first PostComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentFindFirstArgs} args - Arguments to find a PostComment
     * @example
     * // Get one PostComment
     * const postComment = await prisma.postComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostCommentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostCommentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PostComment'> extends True ? Prisma__PostCommentClient<$Types.GetResult<PostCommentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PostCommentClient<$Types.GetResult<PostCommentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first PostComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentFindFirstOrThrowArgs} args - Arguments to find a PostComment
     * @example
     * // Get one PostComment
     * const postComment = await prisma.postComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostCommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PostCommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PostCommentClient<$Types.GetResult<PostCommentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more PostComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostComments
     * const postComments = await prisma.postComment.findMany()
     * 
     * // Get first 10 PostComments
     * const postComments = await prisma.postComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postCommentWithIdOnly = await prisma.postComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostCommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostCommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PostCommentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a PostComment.
     * @param {PostCommentCreateArgs} args - Arguments to create a PostComment.
     * @example
     * // Create one PostComment
     * const PostComment = await prisma.postComment.create({
     *   data: {
     *     // ... data to create a PostComment
     *   }
     * })
     * 
    **/
    create<T extends PostCommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PostCommentCreateArgs<ExtArgs>>
    ): Prisma__PostCommentClient<$Types.GetResult<PostCommentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many PostComments.
     *     @param {PostCommentCreateManyArgs} args - Arguments to create many PostComments.
     *     @example
     *     // Create many PostComments
     *     const postComment = await prisma.postComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostCommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostCommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PostComment.
     * @param {PostCommentDeleteArgs} args - Arguments to delete one PostComment.
     * @example
     * // Delete one PostComment
     * const PostComment = await prisma.postComment.delete({
     *   where: {
     *     // ... filter to delete one PostComment
     *   }
     * })
     * 
    **/
    delete<T extends PostCommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PostCommentDeleteArgs<ExtArgs>>
    ): Prisma__PostCommentClient<$Types.GetResult<PostCommentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one PostComment.
     * @param {PostCommentUpdateArgs} args - Arguments to update one PostComment.
     * @example
     * // Update one PostComment
     * const postComment = await prisma.postComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostCommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PostCommentUpdateArgs<ExtArgs>>
    ): Prisma__PostCommentClient<$Types.GetResult<PostCommentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more PostComments.
     * @param {PostCommentDeleteManyArgs} args - Arguments to filter PostComments to delete.
     * @example
     * // Delete a few PostComments
     * const { count } = await prisma.postComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostCommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PostCommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostComments
     * const postComment = await prisma.postComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostCommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PostCommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostComment.
     * @param {PostCommentUpsertArgs} args - Arguments to update or create a PostComment.
     * @example
     * // Update or create a PostComment
     * const postComment = await prisma.postComment.upsert({
     *   create: {
     *     // ... data to create a PostComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostComment we want to update
     *   }
     * })
    **/
    upsert<T extends PostCommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PostCommentUpsertArgs<ExtArgs>>
    ): Prisma__PostCommentClient<$Types.GetResult<PostCommentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of PostComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentCountArgs} args - Arguments to filter PostComments to count.
     * @example
     * // Count the number of PostComments
     * const count = await prisma.postComment.count({
     *   where: {
     *     // ... the filter for the PostComments we want to count
     *   }
     * })
    **/
    count<T extends PostCommentCountArgs>(
      args?: Subset<T, PostCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostCommentAggregateArgs>(args: Subset<T, PostCommentAggregateArgs>): Prisma.PrismaPromise<GetPostCommentAggregateType<T>>

    /**
     * Group by PostComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostCommentGroupByArgs['orderBy'] }
        : { orderBy?: PostCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PostComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostCommentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    post<T extends SocialPostArgs<ExtArgs> = {}>(args?: Subset<T, SocialPostArgs<ExtArgs>>): Prisma__SocialPostClient<$Types.GetResult<SocialPostPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    author<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PostComment base type for findUnique actions
   */
  export type PostCommentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * Filter, which PostComment to fetch.
     */
    where: PostCommentWhereUniqueInput
  }

  /**
   * PostComment findUnique
   */
  export interface PostCommentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PostCommentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostComment findUniqueOrThrow
   */
  export type PostCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * Filter, which PostComment to fetch.
     */
    where: PostCommentWhereUniqueInput
  }


  /**
   * PostComment base type for findFirst actions
   */
  export type PostCommentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * Filter, which PostComment to fetch.
     */
    where?: PostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostComments to fetch.
     */
    orderBy?: Enumerable<PostCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostComments.
     */
    cursor?: PostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostComments.
     */
    distinct?: Enumerable<PostCommentScalarFieldEnum>
  }

  /**
   * PostComment findFirst
   */
  export interface PostCommentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PostCommentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostComment findFirstOrThrow
   */
  export type PostCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * Filter, which PostComment to fetch.
     */
    where?: PostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostComments to fetch.
     */
    orderBy?: Enumerable<PostCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostComments.
     */
    cursor?: PostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostComments.
     */
    distinct?: Enumerable<PostCommentScalarFieldEnum>
  }


  /**
   * PostComment findMany
   */
  export type PostCommentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * Filter, which PostComments to fetch.
     */
    where?: PostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostComments to fetch.
     */
    orderBy?: Enumerable<PostCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostComments.
     */
    cursor?: PostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostComments.
     */
    skip?: number
    distinct?: Enumerable<PostCommentScalarFieldEnum>
  }


  /**
   * PostComment create
   */
  export type PostCommentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a PostComment.
     */
    data: XOR<PostCommentCreateInput, PostCommentUncheckedCreateInput>
  }


  /**
   * PostComment createMany
   */
  export type PostCommentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostComments.
     */
    data: Enumerable<PostCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PostComment update
   */
  export type PostCommentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a PostComment.
     */
    data: XOR<PostCommentUpdateInput, PostCommentUncheckedUpdateInput>
    /**
     * Choose, which PostComment to update.
     */
    where: PostCommentWhereUniqueInput
  }


  /**
   * PostComment updateMany
   */
  export type PostCommentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostComments.
     */
    data: XOR<PostCommentUpdateManyMutationInput, PostCommentUncheckedUpdateManyInput>
    /**
     * Filter which PostComments to update
     */
    where?: PostCommentWhereInput
  }


  /**
   * PostComment upsert
   */
  export type PostCommentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the PostComment to update in case it exists.
     */
    where: PostCommentWhereUniqueInput
    /**
     * In case the PostComment found by the `where` argument doesn't exist, create a new PostComment with this data.
     */
    create: XOR<PostCommentCreateInput, PostCommentUncheckedCreateInput>
    /**
     * In case the PostComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostCommentUpdateInput, PostCommentUncheckedUpdateInput>
  }


  /**
   * PostComment delete
   */
  export type PostCommentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostCommentInclude<ExtArgs> | null
    /**
     * Filter which PostComment to delete.
     */
    where: PostCommentWhereUniqueInput
  }


  /**
   * PostComment deleteMany
   */
  export type PostCommentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostComments to delete
     */
    where?: PostCommentWhereInput
  }


  /**
   * PostComment without action
   */
  export type PostCommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostComment
     */
    select?: PostCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostCommentInclude<ExtArgs> | null
  }



  /**
   * Model Event
   */


  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: Enumerable<EventOrderByWithAggregationInput>
    by: EventScalarFieldEnum[]
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }


  export type EventGroupByOutputType = {
    id: string
    title: string
    description: string | null
    date: Date
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    registrations?: boolean | Event$registrationsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    registrations?: boolean | Event$registrationsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeArgs<ExtArgs>
  }


  type EventGetPayload<S extends boolean | null | undefined | EventArgs> = $Types.GetResult<EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<EventFindManyArgs, 'select' | 'include'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EventFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Event'> extends True ? Prisma__EventClient<$Types.GetResult<EventPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__EventClient<$Types.GetResult<EventPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EventClient<$Types.GetResult<EventPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EventFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Event'> extends True ? Prisma__EventClient<$Types.GetResult<EventPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__EventClient<$Types.GetResult<EventPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EventClient<$Types.GetResult<EventPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EventFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<EventPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
    **/
    create<T extends EventCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EventCreateArgs<ExtArgs>>
    ): Prisma__EventClient<$Types.GetResult<EventPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Events.
     *     @param {EventCreateManyArgs} args - Arguments to create many Events.
     *     @example
     *     // Create many Events
     *     const event = await prisma.event.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EventCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
    **/
    delete<T extends EventDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EventDeleteArgs<ExtArgs>>
    ): Prisma__EventClient<$Types.GetResult<EventPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EventUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EventUpdateArgs<ExtArgs>>
    ): Prisma__EventClient<$Types.GetResult<EventPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EventDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EventUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
    **/
    upsert<T extends EventUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EventUpsertArgs<ExtArgs>>
    ): Prisma__EventClient<$Types.GetResult<EventPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    registrations<T extends Event$registrationsArgs<ExtArgs> = {}>(args?: Subset<T, Event$registrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EventRegistrationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Event base type for findUnique actions
   */
  export type EventFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUnique
   */
  export interface EventFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EventFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }


  /**
   * Event base type for findFirst actions
   */
  export type EventFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: Enumerable<EventScalarFieldEnum>
  }

  /**
   * Event findFirst
   */
  export interface EventFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EventFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: Enumerable<EventScalarFieldEnum>
  }


  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: Enumerable<EventScalarFieldEnum>
  }


  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }


  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: Enumerable<EventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }


  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }


  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }


  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }


  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }


  /**
   * Event.registrations
   */
  export type Event$registrationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    where?: EventRegistrationWhereInput
    orderBy?: Enumerable<EventRegistrationOrderByWithRelationInput>
    cursor?: EventRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EventRegistrationScalarFieldEnum>
  }


  /**
   * Event without action
   */
  export type EventArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude<ExtArgs> | null
  }



  /**
   * Model EventRegistration
   */


  export type AggregateEventRegistration = {
    _count: EventRegistrationCountAggregateOutputType | null
    _min: EventRegistrationMinAggregateOutputType | null
    _max: EventRegistrationMaxAggregateOutputType | null
  }

  export type EventRegistrationMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    registeredAt: Date | null
  }

  export type EventRegistrationMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    registeredAt: Date | null
  }

  export type EventRegistrationCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    registeredAt: number
    _all: number
  }


  export type EventRegistrationMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    registeredAt?: true
  }

  export type EventRegistrationMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    registeredAt?: true
  }

  export type EventRegistrationCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    registeredAt?: true
    _all?: true
  }

  export type EventRegistrationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventRegistration to aggregate.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: Enumerable<EventRegistrationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventRegistrations
    **/
    _count?: true | EventRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventRegistrationMaxAggregateInputType
  }

  export type GetEventRegistrationAggregateType<T extends EventRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateEventRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventRegistration[P]>
      : GetScalarType<T[P], AggregateEventRegistration[P]>
  }




  export type EventRegistrationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EventRegistrationWhereInput
    orderBy?: Enumerable<EventRegistrationOrderByWithAggregationInput>
    by: EventRegistrationScalarFieldEnum[]
    having?: EventRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventRegistrationCountAggregateInputType | true
    _min?: EventRegistrationMinAggregateInputType
    _max?: EventRegistrationMaxAggregateInputType
  }


  export type EventRegistrationGroupByOutputType = {
    id: string
    eventId: string
    userId: string
    registeredAt: Date
    _count: EventRegistrationCountAggregateOutputType | null
    _min: EventRegistrationMinAggregateOutputType | null
    _max: EventRegistrationMaxAggregateOutputType | null
  }

  type GetEventRegistrationGroupByPayload<T extends EventRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EventRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], EventRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type EventRegistrationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    registeredAt?: boolean
    event?: boolean | EventArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["eventRegistration"]>

  export type EventRegistrationSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    registeredAt?: boolean
  }

  export type EventRegistrationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    event?: boolean | EventArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }


  type EventRegistrationGetPayload<S extends boolean | null | undefined | EventRegistrationArgs> = $Types.GetResult<EventRegistrationPayload, S>

  type EventRegistrationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<EventRegistrationFindManyArgs, 'select' | 'include'> & {
      select?: EventRegistrationCountAggregateInputType | true
    }

  export interface EventRegistrationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventRegistration'], meta: { name: 'EventRegistration' } }
    /**
     * Find zero or one EventRegistration that matches the filter.
     * @param {EventRegistrationFindUniqueArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EventRegistrationFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EventRegistrationFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EventRegistration'> extends True ? Prisma__EventRegistrationClient<$Types.GetResult<EventRegistrationPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__EventRegistrationClient<$Types.GetResult<EventRegistrationPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one EventRegistration that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EventRegistrationFindUniqueOrThrowArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EventRegistrationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EventRegistrationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EventRegistrationClient<$Types.GetResult<EventRegistrationPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first EventRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationFindFirstArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EventRegistrationFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EventRegistrationFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EventRegistration'> extends True ? Prisma__EventRegistrationClient<$Types.GetResult<EventRegistrationPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__EventRegistrationClient<$Types.GetResult<EventRegistrationPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first EventRegistration that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationFindFirstOrThrowArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EventRegistrationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EventRegistrationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EventRegistrationClient<$Types.GetResult<EventRegistrationPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more EventRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventRegistrations
     * const eventRegistrations = await prisma.eventRegistration.findMany()
     * 
     * // Get first 10 EventRegistrations
     * const eventRegistrations = await prisma.eventRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventRegistrationWithIdOnly = await prisma.eventRegistration.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EventRegistrationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventRegistrationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<EventRegistrationPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a EventRegistration.
     * @param {EventRegistrationCreateArgs} args - Arguments to create a EventRegistration.
     * @example
     * // Create one EventRegistration
     * const EventRegistration = await prisma.eventRegistration.create({
     *   data: {
     *     // ... data to create a EventRegistration
     *   }
     * })
     * 
    **/
    create<T extends EventRegistrationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EventRegistrationCreateArgs<ExtArgs>>
    ): Prisma__EventRegistrationClient<$Types.GetResult<EventRegistrationPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many EventRegistrations.
     *     @param {EventRegistrationCreateManyArgs} args - Arguments to create many EventRegistrations.
     *     @example
     *     // Create many EventRegistrations
     *     const eventRegistration = await prisma.eventRegistration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EventRegistrationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventRegistrationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EventRegistration.
     * @param {EventRegistrationDeleteArgs} args - Arguments to delete one EventRegistration.
     * @example
     * // Delete one EventRegistration
     * const EventRegistration = await prisma.eventRegistration.delete({
     *   where: {
     *     // ... filter to delete one EventRegistration
     *   }
     * })
     * 
    **/
    delete<T extends EventRegistrationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EventRegistrationDeleteArgs<ExtArgs>>
    ): Prisma__EventRegistrationClient<$Types.GetResult<EventRegistrationPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one EventRegistration.
     * @param {EventRegistrationUpdateArgs} args - Arguments to update one EventRegistration.
     * @example
     * // Update one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EventRegistrationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EventRegistrationUpdateArgs<ExtArgs>>
    ): Prisma__EventRegistrationClient<$Types.GetResult<EventRegistrationPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more EventRegistrations.
     * @param {EventRegistrationDeleteManyArgs} args - Arguments to filter EventRegistrations to delete.
     * @example
     * // Delete a few EventRegistrations
     * const { count } = await prisma.eventRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EventRegistrationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventRegistrationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventRegistrations
     * const eventRegistration = await prisma.eventRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EventRegistrationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EventRegistrationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventRegistration.
     * @param {EventRegistrationUpsertArgs} args - Arguments to update or create a EventRegistration.
     * @example
     * // Update or create a EventRegistration
     * const eventRegistration = await prisma.eventRegistration.upsert({
     *   create: {
     *     // ... data to create a EventRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventRegistration we want to update
     *   }
     * })
    **/
    upsert<T extends EventRegistrationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EventRegistrationUpsertArgs<ExtArgs>>
    ): Prisma__EventRegistrationClient<$Types.GetResult<EventRegistrationPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of EventRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationCountArgs} args - Arguments to filter EventRegistrations to count.
     * @example
     * // Count the number of EventRegistrations
     * const count = await prisma.eventRegistration.count({
     *   where: {
     *     // ... the filter for the EventRegistrations we want to count
     *   }
     * })
    **/
    count<T extends EventRegistrationCountArgs>(
      args?: Subset<T, EventRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventRegistrationAggregateArgs>(args: Subset<T, EventRegistrationAggregateArgs>): Prisma.PrismaPromise<GetEventRegistrationAggregateType<T>>

    /**
     * Group by EventRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: EventRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for EventRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EventRegistrationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    event<T extends EventArgs<ExtArgs> = {}>(args?: Subset<T, EventArgs<ExtArgs>>): Prisma__EventClient<$Types.GetResult<EventPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * EventRegistration base type for findUnique actions
   */
  export type EventRegistrationFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration findUnique
   */
  export interface EventRegistrationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EventRegistrationFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EventRegistration findUniqueOrThrow
   */
  export type EventRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where: EventRegistrationWhereUniqueInput
  }


  /**
   * EventRegistration base type for findFirst actions
   */
  export type EventRegistrationFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: Enumerable<EventRegistrationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventRegistrations.
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventRegistrations.
     */
    distinct?: Enumerable<EventRegistrationScalarFieldEnum>
  }

  /**
   * EventRegistration findFirst
   */
  export interface EventRegistrationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EventRegistrationFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EventRegistration findFirstOrThrow
   */
  export type EventRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: Enumerable<EventRegistrationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventRegistrations.
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventRegistrations.
     */
    distinct?: Enumerable<EventRegistrationScalarFieldEnum>
  }


  /**
   * EventRegistration findMany
   */
  export type EventRegistrationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistrations to fetch.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: Enumerable<EventRegistrationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventRegistrations.
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    distinct?: Enumerable<EventRegistrationScalarFieldEnum>
  }


  /**
   * EventRegistration create
   */
  export type EventRegistrationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a EventRegistration.
     */
    data: XOR<EventRegistrationCreateInput, EventRegistrationUncheckedCreateInput>
  }


  /**
   * EventRegistration createMany
   */
  export type EventRegistrationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventRegistrations.
     */
    data: Enumerable<EventRegistrationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EventRegistration update
   */
  export type EventRegistrationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a EventRegistration.
     */
    data: XOR<EventRegistrationUpdateInput, EventRegistrationUncheckedUpdateInput>
    /**
     * Choose, which EventRegistration to update.
     */
    where: EventRegistrationWhereUniqueInput
  }


  /**
   * EventRegistration updateMany
   */
  export type EventRegistrationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventRegistrations.
     */
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which EventRegistrations to update
     */
    where?: EventRegistrationWhereInput
  }


  /**
   * EventRegistration upsert
   */
  export type EventRegistrationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the EventRegistration to update in case it exists.
     */
    where: EventRegistrationWhereUniqueInput
    /**
     * In case the EventRegistration found by the `where` argument doesn't exist, create a new EventRegistration with this data.
     */
    create: XOR<EventRegistrationCreateInput, EventRegistrationUncheckedCreateInput>
    /**
     * In case the EventRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventRegistrationUpdateInput, EventRegistrationUncheckedUpdateInput>
  }


  /**
   * EventRegistration delete
   */
  export type EventRegistrationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter which EventRegistration to delete.
     */
    where: EventRegistrationWhereUniqueInput
  }


  /**
   * EventRegistration deleteMany
   */
  export type EventRegistrationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventRegistrations to delete
     */
    where?: EventRegistrationWhereInput
  }


  /**
   * EventRegistration without action
   */
  export type EventRegistrationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventRegistrationInclude<ExtArgs> | null
  }



  /**
   * Model ForumThread
   */


  export type AggregateForumThread = {
    _count: ForumThreadCountAggregateOutputType | null
    _min: ForumThreadMinAggregateOutputType | null
    _max: ForumThreadMaxAggregateOutputType | null
  }

  export type ForumThreadMinAggregateOutputType = {
    id: string | null
    title: string | null
    authorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumThreadMaxAggregateOutputType = {
    id: string | null
    title: string | null
    authorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumThreadCountAggregateOutputType = {
    id: number
    title: number
    authorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumThreadMinAggregateInputType = {
    id?: true
    title?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumThreadMaxAggregateInputType = {
    id?: true
    title?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumThreadCountAggregateInputType = {
    id?: true
    title?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumThreadAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumThread to aggregate.
     */
    where?: ForumThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumThreads to fetch.
     */
    orderBy?: Enumerable<ForumThreadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumThreads
    **/
    _count?: true | ForumThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumThreadMaxAggregateInputType
  }

  export type GetForumThreadAggregateType<T extends ForumThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateForumThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumThread[P]>
      : GetScalarType<T[P], AggregateForumThread[P]>
  }




  export type ForumThreadGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ForumThreadWhereInput
    orderBy?: Enumerable<ForumThreadOrderByWithAggregationInput>
    by: ForumThreadScalarFieldEnum[]
    having?: ForumThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumThreadCountAggregateInputType | true
    _min?: ForumThreadMinAggregateInputType
    _max?: ForumThreadMaxAggregateInputType
  }


  export type ForumThreadGroupByOutputType = {
    id: string
    title: string
    authorId: string
    createdAt: Date
    updatedAt: Date
    _count: ForumThreadCountAggregateOutputType | null
    _min: ForumThreadMinAggregateOutputType | null
    _max: ForumThreadMaxAggregateOutputType | null
  }

  type GetForumThreadGroupByPayload<T extends ForumThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ForumThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumThreadGroupByOutputType[P]>
            : GetScalarType<T[P], ForumThreadGroupByOutputType[P]>
        }
      >
    >


  export type ForumThreadSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserArgs<ExtArgs>
    posts?: boolean | ForumThread$postsArgs<ExtArgs>
    _count?: boolean | ForumThreadCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["forumThread"]>

  export type ForumThreadSelectScalar = {
    id?: boolean
    title?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumThreadInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    author?: boolean | UserArgs<ExtArgs>
    posts?: boolean | ForumThread$postsArgs<ExtArgs>
    _count?: boolean | ForumThreadCountOutputTypeArgs<ExtArgs>
  }


  type ForumThreadGetPayload<S extends boolean | null | undefined | ForumThreadArgs> = $Types.GetResult<ForumThreadPayload, S>

  type ForumThreadCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ForumThreadFindManyArgs, 'select' | 'include'> & {
      select?: ForumThreadCountAggregateInputType | true
    }

  export interface ForumThreadDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumThread'], meta: { name: 'ForumThread' } }
    /**
     * Find zero or one ForumThread that matches the filter.
     * @param {ForumThreadFindUniqueArgs} args - Arguments to find a ForumThread
     * @example
     * // Get one ForumThread
     * const forumThread = await prisma.forumThread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ForumThreadFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ForumThreadFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ForumThread'> extends True ? Prisma__ForumThreadClient<$Types.GetResult<ForumThreadPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ForumThreadClient<$Types.GetResult<ForumThreadPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ForumThread that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ForumThreadFindUniqueOrThrowArgs} args - Arguments to find a ForumThread
     * @example
     * // Get one ForumThread
     * const forumThread = await prisma.forumThread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ForumThreadFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ForumThreadFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ForumThreadClient<$Types.GetResult<ForumThreadPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ForumThread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumThreadFindFirstArgs} args - Arguments to find a ForumThread
     * @example
     * // Get one ForumThread
     * const forumThread = await prisma.forumThread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ForumThreadFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ForumThreadFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ForumThread'> extends True ? Prisma__ForumThreadClient<$Types.GetResult<ForumThreadPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ForumThreadClient<$Types.GetResult<ForumThreadPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ForumThread that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumThreadFindFirstOrThrowArgs} args - Arguments to find a ForumThread
     * @example
     * // Get one ForumThread
     * const forumThread = await prisma.forumThread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ForumThreadFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ForumThreadFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ForumThreadClient<$Types.GetResult<ForumThreadPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ForumThreads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumThreadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumThreads
     * const forumThreads = await prisma.forumThread.findMany()
     * 
     * // Get first 10 ForumThreads
     * const forumThreads = await prisma.forumThread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumThreadWithIdOnly = await prisma.forumThread.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ForumThreadFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ForumThreadFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ForumThreadPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ForumThread.
     * @param {ForumThreadCreateArgs} args - Arguments to create a ForumThread.
     * @example
     * // Create one ForumThread
     * const ForumThread = await prisma.forumThread.create({
     *   data: {
     *     // ... data to create a ForumThread
     *   }
     * })
     * 
    **/
    create<T extends ForumThreadCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ForumThreadCreateArgs<ExtArgs>>
    ): Prisma__ForumThreadClient<$Types.GetResult<ForumThreadPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ForumThreads.
     *     @param {ForumThreadCreateManyArgs} args - Arguments to create many ForumThreads.
     *     @example
     *     // Create many ForumThreads
     *     const forumThread = await prisma.forumThread.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ForumThreadCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ForumThreadCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ForumThread.
     * @param {ForumThreadDeleteArgs} args - Arguments to delete one ForumThread.
     * @example
     * // Delete one ForumThread
     * const ForumThread = await prisma.forumThread.delete({
     *   where: {
     *     // ... filter to delete one ForumThread
     *   }
     * })
     * 
    **/
    delete<T extends ForumThreadDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ForumThreadDeleteArgs<ExtArgs>>
    ): Prisma__ForumThreadClient<$Types.GetResult<ForumThreadPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ForumThread.
     * @param {ForumThreadUpdateArgs} args - Arguments to update one ForumThread.
     * @example
     * // Update one ForumThread
     * const forumThread = await prisma.forumThread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ForumThreadUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ForumThreadUpdateArgs<ExtArgs>>
    ): Prisma__ForumThreadClient<$Types.GetResult<ForumThreadPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ForumThreads.
     * @param {ForumThreadDeleteManyArgs} args - Arguments to filter ForumThreads to delete.
     * @example
     * // Delete a few ForumThreads
     * const { count } = await prisma.forumThread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ForumThreadDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ForumThreadDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumThreads
     * const forumThread = await prisma.forumThread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ForumThreadUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ForumThreadUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForumThread.
     * @param {ForumThreadUpsertArgs} args - Arguments to update or create a ForumThread.
     * @example
     * // Update or create a ForumThread
     * const forumThread = await prisma.forumThread.upsert({
     *   create: {
     *     // ... data to create a ForumThread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumThread we want to update
     *   }
     * })
    **/
    upsert<T extends ForumThreadUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ForumThreadUpsertArgs<ExtArgs>>
    ): Prisma__ForumThreadClient<$Types.GetResult<ForumThreadPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ForumThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumThreadCountArgs} args - Arguments to filter ForumThreads to count.
     * @example
     * // Count the number of ForumThreads
     * const count = await prisma.forumThread.count({
     *   where: {
     *     // ... the filter for the ForumThreads we want to count
     *   }
     * })
    **/
    count<T extends ForumThreadCountArgs>(
      args?: Subset<T, ForumThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumThreadAggregateArgs>(args: Subset<T, ForumThreadAggregateArgs>): Prisma.PrismaPromise<GetForumThreadAggregateType<T>>

    /**
     * Group by ForumThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumThreadGroupByArgs['orderBy'] }
        : { orderBy?: ForumThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumThread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ForumThreadClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    author<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    posts<T extends ForumThread$postsArgs<ExtArgs> = {}>(args?: Subset<T, ForumThread$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ForumPostPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ForumThread base type for findUnique actions
   */
  export type ForumThreadFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumThread
     */
    select?: ForumThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumThreadInclude<ExtArgs> | null
    /**
     * Filter, which ForumThread to fetch.
     */
    where: ForumThreadWhereUniqueInput
  }

  /**
   * ForumThread findUnique
   */
  export interface ForumThreadFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ForumThreadFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ForumThread findUniqueOrThrow
   */
  export type ForumThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumThread
     */
    select?: ForumThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumThreadInclude<ExtArgs> | null
    /**
     * Filter, which ForumThread to fetch.
     */
    where: ForumThreadWhereUniqueInput
  }


  /**
   * ForumThread base type for findFirst actions
   */
  export type ForumThreadFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumThread
     */
    select?: ForumThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumThreadInclude<ExtArgs> | null
    /**
     * Filter, which ForumThread to fetch.
     */
    where?: ForumThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumThreads to fetch.
     */
    orderBy?: Enumerable<ForumThreadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumThreads.
     */
    cursor?: ForumThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumThreads.
     */
    distinct?: Enumerable<ForumThreadScalarFieldEnum>
  }

  /**
   * ForumThread findFirst
   */
  export interface ForumThreadFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ForumThreadFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ForumThread findFirstOrThrow
   */
  export type ForumThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumThread
     */
    select?: ForumThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumThreadInclude<ExtArgs> | null
    /**
     * Filter, which ForumThread to fetch.
     */
    where?: ForumThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumThreads to fetch.
     */
    orderBy?: Enumerable<ForumThreadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumThreads.
     */
    cursor?: ForumThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumThreads.
     */
    distinct?: Enumerable<ForumThreadScalarFieldEnum>
  }


  /**
   * ForumThread findMany
   */
  export type ForumThreadFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumThread
     */
    select?: ForumThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumThreadInclude<ExtArgs> | null
    /**
     * Filter, which ForumThreads to fetch.
     */
    where?: ForumThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumThreads to fetch.
     */
    orderBy?: Enumerable<ForumThreadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumThreads.
     */
    cursor?: ForumThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumThreads.
     */
    skip?: number
    distinct?: Enumerable<ForumThreadScalarFieldEnum>
  }


  /**
   * ForumThread create
   */
  export type ForumThreadCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumThread
     */
    select?: ForumThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumThreadInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumThread.
     */
    data: XOR<ForumThreadCreateInput, ForumThreadUncheckedCreateInput>
  }


  /**
   * ForumThread createMany
   */
  export type ForumThreadCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumThreads.
     */
    data: Enumerable<ForumThreadCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ForumThread update
   */
  export type ForumThreadUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumThread
     */
    select?: ForumThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumThreadInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumThread.
     */
    data: XOR<ForumThreadUpdateInput, ForumThreadUncheckedUpdateInput>
    /**
     * Choose, which ForumThread to update.
     */
    where: ForumThreadWhereUniqueInput
  }


  /**
   * ForumThread updateMany
   */
  export type ForumThreadUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumThreads.
     */
    data: XOR<ForumThreadUpdateManyMutationInput, ForumThreadUncheckedUpdateManyInput>
    /**
     * Filter which ForumThreads to update
     */
    where?: ForumThreadWhereInput
  }


  /**
   * ForumThread upsert
   */
  export type ForumThreadUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumThread
     */
    select?: ForumThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumThreadInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumThread to update in case it exists.
     */
    where: ForumThreadWhereUniqueInput
    /**
     * In case the ForumThread found by the `where` argument doesn't exist, create a new ForumThread with this data.
     */
    create: XOR<ForumThreadCreateInput, ForumThreadUncheckedCreateInput>
    /**
     * In case the ForumThread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumThreadUpdateInput, ForumThreadUncheckedUpdateInput>
  }


  /**
   * ForumThread delete
   */
  export type ForumThreadDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumThread
     */
    select?: ForumThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumThreadInclude<ExtArgs> | null
    /**
     * Filter which ForumThread to delete.
     */
    where: ForumThreadWhereUniqueInput
  }


  /**
   * ForumThread deleteMany
   */
  export type ForumThreadDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumThreads to delete
     */
    where?: ForumThreadWhereInput
  }


  /**
   * ForumThread.posts
   */
  export type ForumThread$postsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumPostInclude<ExtArgs> | null
    where?: ForumPostWhereInput
    orderBy?: Enumerable<ForumPostOrderByWithRelationInput>
    cursor?: ForumPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ForumPostScalarFieldEnum>
  }


  /**
   * ForumThread without action
   */
  export type ForumThreadArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumThread
     */
    select?: ForumThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumThreadInclude<ExtArgs> | null
  }



  /**
   * Model ForumPost
   */


  export type AggregateForumPost = {
    _count: ForumPostCountAggregateOutputType | null
    _min: ForumPostMinAggregateOutputType | null
    _max: ForumPostMaxAggregateOutputType | null
  }

  export type ForumPostMinAggregateOutputType = {
    id: string | null
    threadId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type ForumPostMaxAggregateOutputType = {
    id: string | null
    threadId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type ForumPostCountAggregateOutputType = {
    id: number
    threadId: number
    authorId: number
    content: number
    createdAt: number
    _all: number
  }


  export type ForumPostMinAggregateInputType = {
    id?: true
    threadId?: true
    authorId?: true
    content?: true
    createdAt?: true
  }

  export type ForumPostMaxAggregateInputType = {
    id?: true
    threadId?: true
    authorId?: true
    content?: true
    createdAt?: true
  }

  export type ForumPostCountAggregateInputType = {
    id?: true
    threadId?: true
    authorId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type ForumPostAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPost to aggregate.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: Enumerable<ForumPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumPosts
    **/
    _count?: true | ForumPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumPostMaxAggregateInputType
  }

  export type GetForumPostAggregateType<T extends ForumPostAggregateArgs> = {
        [P in keyof T & keyof AggregateForumPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumPost[P]>
      : GetScalarType<T[P], AggregateForumPost[P]>
  }




  export type ForumPostGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
    orderBy?: Enumerable<ForumPostOrderByWithAggregationInput>
    by: ForumPostScalarFieldEnum[]
    having?: ForumPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumPostCountAggregateInputType | true
    _min?: ForumPostMinAggregateInputType
    _max?: ForumPostMaxAggregateInputType
  }


  export type ForumPostGroupByOutputType = {
    id: string
    threadId: string
    authorId: string
    content: string
    createdAt: Date
    _count: ForumPostCountAggregateOutputType | null
    _min: ForumPostMinAggregateOutputType | null
    _max: ForumPostMaxAggregateOutputType | null
  }

  type GetForumPostGroupByPayload<T extends ForumPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ForumPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumPostGroupByOutputType[P]>
            : GetScalarType<T[P], ForumPostGroupByOutputType[P]>
        }
      >
    >


  export type ForumPostSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    thread?: boolean | ForumThreadArgs<ExtArgs>
    author?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["forumPost"]>

  export type ForumPostSelectScalar = {
    id?: boolean
    threadId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type ForumPostInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    thread?: boolean | ForumThreadArgs<ExtArgs>
    author?: boolean | UserArgs<ExtArgs>
  }


  type ForumPostGetPayload<S extends boolean | null | undefined | ForumPostArgs> = $Types.GetResult<ForumPostPayload, S>

  type ForumPostCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ForumPostFindManyArgs, 'select' | 'include'> & {
      select?: ForumPostCountAggregateInputType | true
    }

  export interface ForumPostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumPost'], meta: { name: 'ForumPost' } }
    /**
     * Find zero or one ForumPost that matches the filter.
     * @param {ForumPostFindUniqueArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ForumPostFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ForumPostFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ForumPost'> extends True ? Prisma__ForumPostClient<$Types.GetResult<ForumPostPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ForumPostClient<$Types.GetResult<ForumPostPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ForumPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ForumPostFindUniqueOrThrowArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ForumPostFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ForumPostFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ForumPostClient<$Types.GetResult<ForumPostPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ForumPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindFirstArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ForumPostFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ForumPostFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ForumPost'> extends True ? Prisma__ForumPostClient<$Types.GetResult<ForumPostPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ForumPostClient<$Types.GetResult<ForumPostPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ForumPost that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindFirstOrThrowArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ForumPostFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ForumPostFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ForumPostClient<$Types.GetResult<ForumPostPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ForumPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumPosts
     * const forumPosts = await prisma.forumPost.findMany()
     * 
     * // Get first 10 ForumPosts
     * const forumPosts = await prisma.forumPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumPostWithIdOnly = await prisma.forumPost.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ForumPostFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ForumPostFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ForumPostPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ForumPost.
     * @param {ForumPostCreateArgs} args - Arguments to create a ForumPost.
     * @example
     * // Create one ForumPost
     * const ForumPost = await prisma.forumPost.create({
     *   data: {
     *     // ... data to create a ForumPost
     *   }
     * })
     * 
    **/
    create<T extends ForumPostCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ForumPostCreateArgs<ExtArgs>>
    ): Prisma__ForumPostClient<$Types.GetResult<ForumPostPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ForumPosts.
     *     @param {ForumPostCreateManyArgs} args - Arguments to create many ForumPosts.
     *     @example
     *     // Create many ForumPosts
     *     const forumPost = await prisma.forumPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ForumPostCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ForumPostCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ForumPost.
     * @param {ForumPostDeleteArgs} args - Arguments to delete one ForumPost.
     * @example
     * // Delete one ForumPost
     * const ForumPost = await prisma.forumPost.delete({
     *   where: {
     *     // ... filter to delete one ForumPost
     *   }
     * })
     * 
    **/
    delete<T extends ForumPostDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ForumPostDeleteArgs<ExtArgs>>
    ): Prisma__ForumPostClient<$Types.GetResult<ForumPostPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ForumPost.
     * @param {ForumPostUpdateArgs} args - Arguments to update one ForumPost.
     * @example
     * // Update one ForumPost
     * const forumPost = await prisma.forumPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ForumPostUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ForumPostUpdateArgs<ExtArgs>>
    ): Prisma__ForumPostClient<$Types.GetResult<ForumPostPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ForumPosts.
     * @param {ForumPostDeleteManyArgs} args - Arguments to filter ForumPosts to delete.
     * @example
     * // Delete a few ForumPosts
     * const { count } = await prisma.forumPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ForumPostDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ForumPostDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumPosts
     * const forumPost = await prisma.forumPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ForumPostUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ForumPostUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForumPost.
     * @param {ForumPostUpsertArgs} args - Arguments to update or create a ForumPost.
     * @example
     * // Update or create a ForumPost
     * const forumPost = await prisma.forumPost.upsert({
     *   create: {
     *     // ... data to create a ForumPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumPost we want to update
     *   }
     * })
    **/
    upsert<T extends ForumPostUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ForumPostUpsertArgs<ExtArgs>>
    ): Prisma__ForumPostClient<$Types.GetResult<ForumPostPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostCountArgs} args - Arguments to filter ForumPosts to count.
     * @example
     * // Count the number of ForumPosts
     * const count = await prisma.forumPost.count({
     *   where: {
     *     // ... the filter for the ForumPosts we want to count
     *   }
     * })
    **/
    count<T extends ForumPostCountArgs>(
      args?: Subset<T, ForumPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumPostAggregateArgs>(args: Subset<T, ForumPostAggregateArgs>): Prisma.PrismaPromise<GetForumPostAggregateType<T>>

    /**
     * Group by ForumPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumPostGroupByArgs['orderBy'] }
        : { orderBy?: ForumPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ForumPostClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    thread<T extends ForumThreadArgs<ExtArgs> = {}>(args?: Subset<T, ForumThreadArgs<ExtArgs>>): Prisma__ForumThreadClient<$Types.GetResult<ForumThreadPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    author<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ForumPost base type for findUnique actions
   */
  export type ForumPostFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost findUnique
   */
  export interface ForumPostFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ForumPostFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ForumPost findUniqueOrThrow
   */
  export type ForumPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where: ForumPostWhereUniqueInput
  }


  /**
   * ForumPost base type for findFirst actions
   */
  export type ForumPostFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: Enumerable<ForumPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPosts.
     */
    distinct?: Enumerable<ForumPostScalarFieldEnum>
  }

  /**
   * ForumPost findFirst
   */
  export interface ForumPostFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ForumPostFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ForumPost findFirstOrThrow
   */
  export type ForumPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: Enumerable<ForumPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPosts.
     */
    distinct?: Enumerable<ForumPostScalarFieldEnum>
  }


  /**
   * ForumPost findMany
   */
  export type ForumPostFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPosts to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: Enumerable<ForumPostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    distinct?: Enumerable<ForumPostScalarFieldEnum>
  }


  /**
   * ForumPost create
   */
  export type ForumPostCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumPost.
     */
    data: XOR<ForumPostCreateInput, ForumPostUncheckedCreateInput>
  }


  /**
   * ForumPost createMany
   */
  export type ForumPostCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumPosts.
     */
    data: Enumerable<ForumPostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ForumPost update
   */
  export type ForumPostUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumPost.
     */
    data: XOR<ForumPostUpdateInput, ForumPostUncheckedUpdateInput>
    /**
     * Choose, which ForumPost to update.
     */
    where: ForumPostWhereUniqueInput
  }


  /**
   * ForumPost updateMany
   */
  export type ForumPostUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumPosts.
     */
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyInput>
    /**
     * Filter which ForumPosts to update
     */
    where?: ForumPostWhereInput
  }


  /**
   * ForumPost upsert
   */
  export type ForumPostUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumPost to update in case it exists.
     */
    where: ForumPostWhereUniqueInput
    /**
     * In case the ForumPost found by the `where` argument doesn't exist, create a new ForumPost with this data.
     */
    create: XOR<ForumPostCreateInput, ForumPostUncheckedCreateInput>
    /**
     * In case the ForumPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumPostUpdateInput, ForumPostUncheckedUpdateInput>
  }


  /**
   * ForumPost delete
   */
  export type ForumPostDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter which ForumPost to delete.
     */
    where: ForumPostWhereUniqueInput
  }


  /**
   * ForumPost deleteMany
   */
  export type ForumPostDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPosts to delete
     */
    where?: ForumPostWhereInput
  }


  /**
   * ForumPost without action
   */
  export type ForumPostArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForumPostInclude<ExtArgs> | null
  }



  /**
   * Model BenefitClaim
   */


  export type AggregateBenefitClaim = {
    _count: BenefitClaimCountAggregateOutputType | null
    _avg: BenefitClaimAvgAggregateOutputType | null
    _sum: BenefitClaimSumAggregateOutputType | null
    _min: BenefitClaimMinAggregateOutputType | null
    _max: BenefitClaimMaxAggregateOutputType | null
  }

  export type BenefitClaimAvgAggregateOutputType = {
    amount: number | null
  }

  export type BenefitClaimSumAggregateOutputType = {
    amount: number | null
  }

  export type BenefitClaimMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    status: string | null
    amount: number | null
    requestedAt: Date | null
    processedAt: Date | null
  }

  export type BenefitClaimMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    status: string | null
    amount: number | null
    requestedAt: Date | null
    processedAt: Date | null
  }

  export type BenefitClaimCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    status: number
    amount: number
    requestedAt: number
    processedAt: number
    _all: number
  }


  export type BenefitClaimAvgAggregateInputType = {
    amount?: true
  }

  export type BenefitClaimSumAggregateInputType = {
    amount?: true
  }

  export type BenefitClaimMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    amount?: true
    requestedAt?: true
    processedAt?: true
  }

  export type BenefitClaimMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    amount?: true
    requestedAt?: true
    processedAt?: true
  }

  export type BenefitClaimCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    amount?: true
    requestedAt?: true
    processedAt?: true
    _all?: true
  }

  export type BenefitClaimAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BenefitClaim to aggregate.
     */
    where?: BenefitClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenefitClaims to fetch.
     */
    orderBy?: Enumerable<BenefitClaimOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BenefitClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenefitClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenefitClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BenefitClaims
    **/
    _count?: true | BenefitClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BenefitClaimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BenefitClaimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BenefitClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BenefitClaimMaxAggregateInputType
  }

  export type GetBenefitClaimAggregateType<T extends BenefitClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateBenefitClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBenefitClaim[P]>
      : GetScalarType<T[P], AggregateBenefitClaim[P]>
  }




  export type BenefitClaimGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BenefitClaimWhereInput
    orderBy?: Enumerable<BenefitClaimOrderByWithAggregationInput>
    by: BenefitClaimScalarFieldEnum[]
    having?: BenefitClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BenefitClaimCountAggregateInputType | true
    _avg?: BenefitClaimAvgAggregateInputType
    _sum?: BenefitClaimSumAggregateInputType
    _min?: BenefitClaimMinAggregateInputType
    _max?: BenefitClaimMaxAggregateInputType
  }


  export type BenefitClaimGroupByOutputType = {
    id: string
    userId: string
    type: string
    status: string
    amount: number | null
    requestedAt: Date
    processedAt: Date | null
    _count: BenefitClaimCountAggregateOutputType | null
    _avg: BenefitClaimAvgAggregateOutputType | null
    _sum: BenefitClaimSumAggregateOutputType | null
    _min: BenefitClaimMinAggregateOutputType | null
    _max: BenefitClaimMaxAggregateOutputType | null
  }

  type GetBenefitClaimGroupByPayload<T extends BenefitClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BenefitClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BenefitClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BenefitClaimGroupByOutputType[P]>
            : GetScalarType<T[P], BenefitClaimGroupByOutputType[P]>
        }
      >
    >


  export type BenefitClaimSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    requestedAt?: boolean
    processedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["benefitClaim"]>

  export type BenefitClaimSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    amount?: boolean
    requestedAt?: boolean
    processedAt?: boolean
  }

  export type BenefitClaimInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type BenefitClaimGetPayload<S extends boolean | null | undefined | BenefitClaimArgs> = $Types.GetResult<BenefitClaimPayload, S>

  type BenefitClaimCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BenefitClaimFindManyArgs, 'select' | 'include'> & {
      select?: BenefitClaimCountAggregateInputType | true
    }

  export interface BenefitClaimDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BenefitClaim'], meta: { name: 'BenefitClaim' } }
    /**
     * Find zero or one BenefitClaim that matches the filter.
     * @param {BenefitClaimFindUniqueArgs} args - Arguments to find a BenefitClaim
     * @example
     * // Get one BenefitClaim
     * const benefitClaim = await prisma.benefitClaim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BenefitClaimFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BenefitClaimFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BenefitClaim'> extends True ? Prisma__BenefitClaimClient<$Types.GetResult<BenefitClaimPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BenefitClaimClient<$Types.GetResult<BenefitClaimPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one BenefitClaim that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BenefitClaimFindUniqueOrThrowArgs} args - Arguments to find a BenefitClaim
     * @example
     * // Get one BenefitClaim
     * const benefitClaim = await prisma.benefitClaim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BenefitClaimFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BenefitClaimFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BenefitClaimClient<$Types.GetResult<BenefitClaimPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first BenefitClaim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitClaimFindFirstArgs} args - Arguments to find a BenefitClaim
     * @example
     * // Get one BenefitClaim
     * const benefitClaim = await prisma.benefitClaim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BenefitClaimFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BenefitClaimFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BenefitClaim'> extends True ? Prisma__BenefitClaimClient<$Types.GetResult<BenefitClaimPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BenefitClaimClient<$Types.GetResult<BenefitClaimPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first BenefitClaim that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitClaimFindFirstOrThrowArgs} args - Arguments to find a BenefitClaim
     * @example
     * // Get one BenefitClaim
     * const benefitClaim = await prisma.benefitClaim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BenefitClaimFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BenefitClaimFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BenefitClaimClient<$Types.GetResult<BenefitClaimPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more BenefitClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitClaimFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BenefitClaims
     * const benefitClaims = await prisma.benefitClaim.findMany()
     * 
     * // Get first 10 BenefitClaims
     * const benefitClaims = await prisma.benefitClaim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const benefitClaimWithIdOnly = await prisma.benefitClaim.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BenefitClaimFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BenefitClaimFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BenefitClaimPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a BenefitClaim.
     * @param {BenefitClaimCreateArgs} args - Arguments to create a BenefitClaim.
     * @example
     * // Create one BenefitClaim
     * const BenefitClaim = await prisma.benefitClaim.create({
     *   data: {
     *     // ... data to create a BenefitClaim
     *   }
     * })
     * 
    **/
    create<T extends BenefitClaimCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BenefitClaimCreateArgs<ExtArgs>>
    ): Prisma__BenefitClaimClient<$Types.GetResult<BenefitClaimPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many BenefitClaims.
     *     @param {BenefitClaimCreateManyArgs} args - Arguments to create many BenefitClaims.
     *     @example
     *     // Create many BenefitClaims
     *     const benefitClaim = await prisma.benefitClaim.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BenefitClaimCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BenefitClaimCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BenefitClaim.
     * @param {BenefitClaimDeleteArgs} args - Arguments to delete one BenefitClaim.
     * @example
     * // Delete one BenefitClaim
     * const BenefitClaim = await prisma.benefitClaim.delete({
     *   where: {
     *     // ... filter to delete one BenefitClaim
     *   }
     * })
     * 
    **/
    delete<T extends BenefitClaimDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BenefitClaimDeleteArgs<ExtArgs>>
    ): Prisma__BenefitClaimClient<$Types.GetResult<BenefitClaimPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one BenefitClaim.
     * @param {BenefitClaimUpdateArgs} args - Arguments to update one BenefitClaim.
     * @example
     * // Update one BenefitClaim
     * const benefitClaim = await prisma.benefitClaim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BenefitClaimUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BenefitClaimUpdateArgs<ExtArgs>>
    ): Prisma__BenefitClaimClient<$Types.GetResult<BenefitClaimPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more BenefitClaims.
     * @param {BenefitClaimDeleteManyArgs} args - Arguments to filter BenefitClaims to delete.
     * @example
     * // Delete a few BenefitClaims
     * const { count } = await prisma.benefitClaim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BenefitClaimDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BenefitClaimDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BenefitClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BenefitClaims
     * const benefitClaim = await prisma.benefitClaim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BenefitClaimUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BenefitClaimUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BenefitClaim.
     * @param {BenefitClaimUpsertArgs} args - Arguments to update or create a BenefitClaim.
     * @example
     * // Update or create a BenefitClaim
     * const benefitClaim = await prisma.benefitClaim.upsert({
     *   create: {
     *     // ... data to create a BenefitClaim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BenefitClaim we want to update
     *   }
     * })
    **/
    upsert<T extends BenefitClaimUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BenefitClaimUpsertArgs<ExtArgs>>
    ): Prisma__BenefitClaimClient<$Types.GetResult<BenefitClaimPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of BenefitClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitClaimCountArgs} args - Arguments to filter BenefitClaims to count.
     * @example
     * // Count the number of BenefitClaims
     * const count = await prisma.benefitClaim.count({
     *   where: {
     *     // ... the filter for the BenefitClaims we want to count
     *   }
     * })
    **/
    count<T extends BenefitClaimCountArgs>(
      args?: Subset<T, BenefitClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BenefitClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BenefitClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BenefitClaimAggregateArgs>(args: Subset<T, BenefitClaimAggregateArgs>): Prisma.PrismaPromise<GetBenefitClaimAggregateType<T>>

    /**
     * Group by BenefitClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BenefitClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BenefitClaimGroupByArgs['orderBy'] }
        : { orderBy?: BenefitClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BenefitClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBenefitClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BenefitClaim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BenefitClaimClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BenefitClaim base type for findUnique actions
   */
  export type BenefitClaimFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitClaim
     */
    select?: BenefitClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BenefitClaimInclude<ExtArgs> | null
    /**
     * Filter, which BenefitClaim to fetch.
     */
    where: BenefitClaimWhereUniqueInput
  }

  /**
   * BenefitClaim findUnique
   */
  export interface BenefitClaimFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BenefitClaimFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BenefitClaim findUniqueOrThrow
   */
  export type BenefitClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitClaim
     */
    select?: BenefitClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BenefitClaimInclude<ExtArgs> | null
    /**
     * Filter, which BenefitClaim to fetch.
     */
    where: BenefitClaimWhereUniqueInput
  }


  /**
   * BenefitClaim base type for findFirst actions
   */
  export type BenefitClaimFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitClaim
     */
    select?: BenefitClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BenefitClaimInclude<ExtArgs> | null
    /**
     * Filter, which BenefitClaim to fetch.
     */
    where?: BenefitClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenefitClaims to fetch.
     */
    orderBy?: Enumerable<BenefitClaimOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BenefitClaims.
     */
    cursor?: BenefitClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenefitClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenefitClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BenefitClaims.
     */
    distinct?: Enumerable<BenefitClaimScalarFieldEnum>
  }

  /**
   * BenefitClaim findFirst
   */
  export interface BenefitClaimFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BenefitClaimFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BenefitClaim findFirstOrThrow
   */
  export type BenefitClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitClaim
     */
    select?: BenefitClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BenefitClaimInclude<ExtArgs> | null
    /**
     * Filter, which BenefitClaim to fetch.
     */
    where?: BenefitClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenefitClaims to fetch.
     */
    orderBy?: Enumerable<BenefitClaimOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BenefitClaims.
     */
    cursor?: BenefitClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenefitClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenefitClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BenefitClaims.
     */
    distinct?: Enumerable<BenefitClaimScalarFieldEnum>
  }


  /**
   * BenefitClaim findMany
   */
  export type BenefitClaimFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitClaim
     */
    select?: BenefitClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BenefitClaimInclude<ExtArgs> | null
    /**
     * Filter, which BenefitClaims to fetch.
     */
    where?: BenefitClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenefitClaims to fetch.
     */
    orderBy?: Enumerable<BenefitClaimOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BenefitClaims.
     */
    cursor?: BenefitClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenefitClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenefitClaims.
     */
    skip?: number
    distinct?: Enumerable<BenefitClaimScalarFieldEnum>
  }


  /**
   * BenefitClaim create
   */
  export type BenefitClaimCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitClaim
     */
    select?: BenefitClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BenefitClaimInclude<ExtArgs> | null
    /**
     * The data needed to create a BenefitClaim.
     */
    data: XOR<BenefitClaimCreateInput, BenefitClaimUncheckedCreateInput>
  }


  /**
   * BenefitClaim createMany
   */
  export type BenefitClaimCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BenefitClaims.
     */
    data: Enumerable<BenefitClaimCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BenefitClaim update
   */
  export type BenefitClaimUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitClaim
     */
    select?: BenefitClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BenefitClaimInclude<ExtArgs> | null
    /**
     * The data needed to update a BenefitClaim.
     */
    data: XOR<BenefitClaimUpdateInput, BenefitClaimUncheckedUpdateInput>
    /**
     * Choose, which BenefitClaim to update.
     */
    where: BenefitClaimWhereUniqueInput
  }


  /**
   * BenefitClaim updateMany
   */
  export type BenefitClaimUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BenefitClaims.
     */
    data: XOR<BenefitClaimUpdateManyMutationInput, BenefitClaimUncheckedUpdateManyInput>
    /**
     * Filter which BenefitClaims to update
     */
    where?: BenefitClaimWhereInput
  }


  /**
   * BenefitClaim upsert
   */
  export type BenefitClaimUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitClaim
     */
    select?: BenefitClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BenefitClaimInclude<ExtArgs> | null
    /**
     * The filter to search for the BenefitClaim to update in case it exists.
     */
    where: BenefitClaimWhereUniqueInput
    /**
     * In case the BenefitClaim found by the `where` argument doesn't exist, create a new BenefitClaim with this data.
     */
    create: XOR<BenefitClaimCreateInput, BenefitClaimUncheckedCreateInput>
    /**
     * In case the BenefitClaim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BenefitClaimUpdateInput, BenefitClaimUncheckedUpdateInput>
  }


  /**
   * BenefitClaim delete
   */
  export type BenefitClaimDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitClaim
     */
    select?: BenefitClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BenefitClaimInclude<ExtArgs> | null
    /**
     * Filter which BenefitClaim to delete.
     */
    where: BenefitClaimWhereUniqueInput
  }


  /**
   * BenefitClaim deleteMany
   */
  export type BenefitClaimDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BenefitClaims to delete
     */
    where?: BenefitClaimWhereInput
  }


  /**
   * BenefitClaim without action
   */
  export type BenefitClaimArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitClaim
     */
    select?: BenefitClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BenefitClaimInclude<ExtArgs> | null
  }



  /**
   * Model PayrollRecord
   */


  export type AggregatePayrollRecord = {
    _count: PayrollRecordCountAggregateOutputType | null
    _avg: PayrollRecordAvgAggregateOutputType | null
    _sum: PayrollRecordSumAggregateOutputType | null
    _min: PayrollRecordMinAggregateOutputType | null
    _max: PayrollRecordMaxAggregateOutputType | null
  }

  export type PayrollRecordAvgAggregateOutputType = {
    salary: number | null
  }

  export type PayrollRecordSumAggregateOutputType = {
    salary: number | null
  }

  export type PayrollRecordMinAggregateOutputType = {
    id: string | null
    userId: string | null
    salary: number | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollRecordMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    salary: number | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollRecordCountAggregateOutputType = {
    id: number
    userId: number
    salary: number
    periodStart: number
    periodEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayrollRecordAvgAggregateInputType = {
    salary?: true
  }

  export type PayrollRecordSumAggregateInputType = {
    salary?: true
  }

  export type PayrollRecordMinAggregateInputType = {
    id?: true
    userId?: true
    salary?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollRecordMaxAggregateInputType = {
    id?: true
    userId?: true
    salary?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollRecordCountAggregateInputType = {
    id?: true
    userId?: true
    salary?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayrollRecordAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollRecord to aggregate.
     */
    where?: PayrollRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollRecords to fetch.
     */
    orderBy?: Enumerable<PayrollRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayrollRecords
    **/
    _count?: true | PayrollRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollRecordMaxAggregateInputType
  }

  export type GetPayrollRecordAggregateType<T extends PayrollRecordAggregateArgs> = {
        [P in keyof T & keyof AggregatePayrollRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayrollRecord[P]>
      : GetScalarType<T[P], AggregatePayrollRecord[P]>
  }




  export type PayrollRecordGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PayrollRecordWhereInput
    orderBy?: Enumerable<PayrollRecordOrderByWithAggregationInput>
    by: PayrollRecordScalarFieldEnum[]
    having?: PayrollRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollRecordCountAggregateInputType | true
    _avg?: PayrollRecordAvgAggregateInputType
    _sum?: PayrollRecordSumAggregateInputType
    _min?: PayrollRecordMinAggregateInputType
    _max?: PayrollRecordMaxAggregateInputType
  }


  export type PayrollRecordGroupByOutputType = {
    id: string
    userId: string
    salary: number
    periodStart: Date
    periodEnd: Date
    createdAt: Date
    updatedAt: Date
    _count: PayrollRecordCountAggregateOutputType | null
    _avg: PayrollRecordAvgAggregateOutputType | null
    _sum: PayrollRecordSumAggregateOutputType | null
    _min: PayrollRecordMinAggregateOutputType | null
    _max: PayrollRecordMaxAggregateOutputType | null
  }

  type GetPayrollRecordGroupByPayload<T extends PayrollRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PayrollRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollRecordGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollRecordGroupByOutputType[P]>
        }
      >
    >


  export type PayrollRecordSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    salary?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["payrollRecord"]>

  export type PayrollRecordSelectScalar = {
    id?: boolean
    userId?: boolean
    salary?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayrollRecordInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type PayrollRecordGetPayload<S extends boolean | null | undefined | PayrollRecordArgs> = $Types.GetResult<PayrollRecordPayload, S>

  type PayrollRecordCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PayrollRecordFindManyArgs, 'select' | 'include'> & {
      select?: PayrollRecordCountAggregateInputType | true
    }

  export interface PayrollRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayrollRecord'], meta: { name: 'PayrollRecord' } }
    /**
     * Find zero or one PayrollRecord that matches the filter.
     * @param {PayrollRecordFindUniqueArgs} args - Arguments to find a PayrollRecord
     * @example
     * // Get one PayrollRecord
     * const payrollRecord = await prisma.payrollRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PayrollRecordFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PayrollRecordFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PayrollRecord'> extends True ? Prisma__PayrollRecordClient<$Types.GetResult<PayrollRecordPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PayrollRecordClient<$Types.GetResult<PayrollRecordPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one PayrollRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PayrollRecordFindUniqueOrThrowArgs} args - Arguments to find a PayrollRecord
     * @example
     * // Get one PayrollRecord
     * const payrollRecord = await prisma.payrollRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PayrollRecordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PayrollRecordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PayrollRecordClient<$Types.GetResult<PayrollRecordPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first PayrollRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollRecordFindFirstArgs} args - Arguments to find a PayrollRecord
     * @example
     * // Get one PayrollRecord
     * const payrollRecord = await prisma.payrollRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PayrollRecordFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PayrollRecordFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PayrollRecord'> extends True ? Prisma__PayrollRecordClient<$Types.GetResult<PayrollRecordPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PayrollRecordClient<$Types.GetResult<PayrollRecordPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first PayrollRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollRecordFindFirstOrThrowArgs} args - Arguments to find a PayrollRecord
     * @example
     * // Get one PayrollRecord
     * const payrollRecord = await prisma.payrollRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PayrollRecordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PayrollRecordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PayrollRecordClient<$Types.GetResult<PayrollRecordPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more PayrollRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayrollRecords
     * const payrollRecords = await prisma.payrollRecord.findMany()
     * 
     * // Get first 10 PayrollRecords
     * const payrollRecords = await prisma.payrollRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollRecordWithIdOnly = await prisma.payrollRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PayrollRecordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PayrollRecordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PayrollRecordPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a PayrollRecord.
     * @param {PayrollRecordCreateArgs} args - Arguments to create a PayrollRecord.
     * @example
     * // Create one PayrollRecord
     * const PayrollRecord = await prisma.payrollRecord.create({
     *   data: {
     *     // ... data to create a PayrollRecord
     *   }
     * })
     * 
    **/
    create<T extends PayrollRecordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PayrollRecordCreateArgs<ExtArgs>>
    ): Prisma__PayrollRecordClient<$Types.GetResult<PayrollRecordPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many PayrollRecords.
     *     @param {PayrollRecordCreateManyArgs} args - Arguments to create many PayrollRecords.
     *     @example
     *     // Create many PayrollRecords
     *     const payrollRecord = await prisma.payrollRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PayrollRecordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PayrollRecordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PayrollRecord.
     * @param {PayrollRecordDeleteArgs} args - Arguments to delete one PayrollRecord.
     * @example
     * // Delete one PayrollRecord
     * const PayrollRecord = await prisma.payrollRecord.delete({
     *   where: {
     *     // ... filter to delete one PayrollRecord
     *   }
     * })
     * 
    **/
    delete<T extends PayrollRecordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PayrollRecordDeleteArgs<ExtArgs>>
    ): Prisma__PayrollRecordClient<$Types.GetResult<PayrollRecordPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one PayrollRecord.
     * @param {PayrollRecordUpdateArgs} args - Arguments to update one PayrollRecord.
     * @example
     * // Update one PayrollRecord
     * const payrollRecord = await prisma.payrollRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PayrollRecordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PayrollRecordUpdateArgs<ExtArgs>>
    ): Prisma__PayrollRecordClient<$Types.GetResult<PayrollRecordPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more PayrollRecords.
     * @param {PayrollRecordDeleteManyArgs} args - Arguments to filter PayrollRecords to delete.
     * @example
     * // Delete a few PayrollRecords
     * const { count } = await prisma.payrollRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PayrollRecordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PayrollRecordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayrollRecords
     * const payrollRecord = await prisma.payrollRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PayrollRecordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PayrollRecordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PayrollRecord.
     * @param {PayrollRecordUpsertArgs} args - Arguments to update or create a PayrollRecord.
     * @example
     * // Update or create a PayrollRecord
     * const payrollRecord = await prisma.payrollRecord.upsert({
     *   create: {
     *     // ... data to create a PayrollRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayrollRecord we want to update
     *   }
     * })
    **/
    upsert<T extends PayrollRecordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PayrollRecordUpsertArgs<ExtArgs>>
    ): Prisma__PayrollRecordClient<$Types.GetResult<PayrollRecordPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of PayrollRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollRecordCountArgs} args - Arguments to filter PayrollRecords to count.
     * @example
     * // Count the number of PayrollRecords
     * const count = await prisma.payrollRecord.count({
     *   where: {
     *     // ... the filter for the PayrollRecords we want to count
     *   }
     * })
    **/
    count<T extends PayrollRecordCountArgs>(
      args?: Subset<T, PayrollRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayrollRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollRecordAggregateArgs>(args: Subset<T, PayrollRecordAggregateArgs>): Prisma.PrismaPromise<GetPayrollRecordAggregateType<T>>

    /**
     * Group by PayrollRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollRecordGroupByArgs['orderBy'] }
        : { orderBy?: PayrollRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PayrollRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PayrollRecordClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PayrollRecord base type for findUnique actions
   */
  export type PayrollRecordFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRecord
     */
    select?: PayrollRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayrollRecordInclude<ExtArgs> | null
    /**
     * Filter, which PayrollRecord to fetch.
     */
    where: PayrollRecordWhereUniqueInput
  }

  /**
   * PayrollRecord findUnique
   */
  export interface PayrollRecordFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PayrollRecordFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PayrollRecord findUniqueOrThrow
   */
  export type PayrollRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRecord
     */
    select?: PayrollRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayrollRecordInclude<ExtArgs> | null
    /**
     * Filter, which PayrollRecord to fetch.
     */
    where: PayrollRecordWhereUniqueInput
  }


  /**
   * PayrollRecord base type for findFirst actions
   */
  export type PayrollRecordFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRecord
     */
    select?: PayrollRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayrollRecordInclude<ExtArgs> | null
    /**
     * Filter, which PayrollRecord to fetch.
     */
    where?: PayrollRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollRecords to fetch.
     */
    orderBy?: Enumerable<PayrollRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollRecords.
     */
    cursor?: PayrollRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollRecords.
     */
    distinct?: Enumerable<PayrollRecordScalarFieldEnum>
  }

  /**
   * PayrollRecord findFirst
   */
  export interface PayrollRecordFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PayrollRecordFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PayrollRecord findFirstOrThrow
   */
  export type PayrollRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRecord
     */
    select?: PayrollRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayrollRecordInclude<ExtArgs> | null
    /**
     * Filter, which PayrollRecord to fetch.
     */
    where?: PayrollRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollRecords to fetch.
     */
    orderBy?: Enumerable<PayrollRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollRecords.
     */
    cursor?: PayrollRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollRecords.
     */
    distinct?: Enumerable<PayrollRecordScalarFieldEnum>
  }


  /**
   * PayrollRecord findMany
   */
  export type PayrollRecordFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRecord
     */
    select?: PayrollRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayrollRecordInclude<ExtArgs> | null
    /**
     * Filter, which PayrollRecords to fetch.
     */
    where?: PayrollRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollRecords to fetch.
     */
    orderBy?: Enumerable<PayrollRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayrollRecords.
     */
    cursor?: PayrollRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollRecords.
     */
    skip?: number
    distinct?: Enumerable<PayrollRecordScalarFieldEnum>
  }


  /**
   * PayrollRecord create
   */
  export type PayrollRecordCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRecord
     */
    select?: PayrollRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayrollRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a PayrollRecord.
     */
    data: XOR<PayrollRecordCreateInput, PayrollRecordUncheckedCreateInput>
  }


  /**
   * PayrollRecord createMany
   */
  export type PayrollRecordCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayrollRecords.
     */
    data: Enumerable<PayrollRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PayrollRecord update
   */
  export type PayrollRecordUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRecord
     */
    select?: PayrollRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayrollRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a PayrollRecord.
     */
    data: XOR<PayrollRecordUpdateInput, PayrollRecordUncheckedUpdateInput>
    /**
     * Choose, which PayrollRecord to update.
     */
    where: PayrollRecordWhereUniqueInput
  }


  /**
   * PayrollRecord updateMany
   */
  export type PayrollRecordUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayrollRecords.
     */
    data: XOR<PayrollRecordUpdateManyMutationInput, PayrollRecordUncheckedUpdateManyInput>
    /**
     * Filter which PayrollRecords to update
     */
    where?: PayrollRecordWhereInput
  }


  /**
   * PayrollRecord upsert
   */
  export type PayrollRecordUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRecord
     */
    select?: PayrollRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayrollRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the PayrollRecord to update in case it exists.
     */
    where: PayrollRecordWhereUniqueInput
    /**
     * In case the PayrollRecord found by the `where` argument doesn't exist, create a new PayrollRecord with this data.
     */
    create: XOR<PayrollRecordCreateInput, PayrollRecordUncheckedCreateInput>
    /**
     * In case the PayrollRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollRecordUpdateInput, PayrollRecordUncheckedUpdateInput>
  }


  /**
   * PayrollRecord delete
   */
  export type PayrollRecordDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRecord
     */
    select?: PayrollRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayrollRecordInclude<ExtArgs> | null
    /**
     * Filter which PayrollRecord to delete.
     */
    where: PayrollRecordWhereUniqueInput
  }


  /**
   * PayrollRecord deleteMany
   */
  export type PayrollRecordDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollRecords to delete
     */
    where?: PayrollRecordWhereInput
  }


  /**
   * PayrollRecord without action
   */
  export type PayrollRecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollRecord
     */
    select?: PayrollRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PayrollRecordInclude<ExtArgs> | null
  }



  /**
   * Model Booking
   */


  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    duration: number | null
  }

  export type BookingSumAggregateOutputType = {
    duration: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    appointmentDate: Date | null
    duration: number | null
    specialRequests: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    googleEventId: string | null
    outlookEventId: string | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    appointmentDate: Date | null
    duration: number | null
    specialRequests: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    googleEventId: string | null
    outlookEventId: string | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    userId: number
    serviceId: number
    appointmentDate: number
    duration: number
    specialRequests: number
    status: number
    createdAt: number
    updatedAt: number
    googleEventId: number
    outlookEventId: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    duration?: true
  }

  export type BookingSumAggregateInputType = {
    duration?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    appointmentDate?: true
    duration?: true
    specialRequests?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    googleEventId?: true
    outlookEventId?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    appointmentDate?: true
    duration?: true
    specialRequests?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    googleEventId?: true
    outlookEventId?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    appointmentDate?: true
    duration?: true
    specialRequests?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    googleEventId?: true
    outlookEventId?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: Enumerable<BookingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: Enumerable<BookingOrderByWithAggregationInput>
    by: BookingScalarFieldEnum[]
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }


  export type BookingGroupByOutputType = {
    id: string
    userId: string
    serviceId: string
    appointmentDate: Date
    duration: number
    specialRequests: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    googleEventId: string | null
    outlookEventId: string | null
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    appointmentDate?: boolean
    duration?: boolean
    specialRequests?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    googleEventId?: boolean
    outlookEventId?: boolean
    user?: boolean | UserArgs<ExtArgs>
    service?: boolean | ServiceArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    appointmentDate?: boolean
    duration?: boolean
    specialRequests?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    googleEventId?: boolean
    outlookEventId?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    service?: boolean | ServiceArgs<ExtArgs>
  }


  type BookingGetPayload<S extends boolean | null | undefined | BookingArgs> = $Types.GetResult<BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BookingFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Booking'> extends True ? Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BookingFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Booking'> extends True ? Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BookingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BookingPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
    **/
    create<T extends BookingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BookingCreateArgs<ExtArgs>>
    ): Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Bookings.
     *     @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     *     @example
     *     // Create many Bookings
     *     const booking = await prisma.booking.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BookingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
    **/
    delete<T extends BookingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>
    ): Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BookingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>
    ): Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BookingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BookingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
    **/
    upsert<T extends BookingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>
    ): Prisma__BookingClient<$Types.GetResult<BookingPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    service<T extends ServiceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceArgs<ExtArgs>>): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Booking base type for findUnique actions
   */
  export type BookingFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUnique
   */
  export interface BookingFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BookingFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }


  /**
   * Booking base type for findFirst actions
   */
  export type BookingFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: Enumerable<BookingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: Enumerable<BookingScalarFieldEnum>
  }

  /**
   * Booking findFirst
   */
  export interface BookingFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BookingFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: Enumerable<BookingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: Enumerable<BookingScalarFieldEnum>
  }


  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: Enumerable<BookingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: Enumerable<BookingScalarFieldEnum>
  }


  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }


  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: Enumerable<BookingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }


  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }


  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }


  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }


  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }


  /**
   * Booking without action
   */
  export type BookingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BookingInclude<ExtArgs> | null
  }



  /**
   * Model TwoFactorAuth
   */


  export type AggregateTwoFactorAuth = {
    _count: TwoFactorAuthCountAggregateOutputType | null
    _min: TwoFactorAuthMinAggregateOutputType | null
    _max: TwoFactorAuthMaxAggregateOutputType | null
  }

  export type TwoFactorAuthMinAggregateOutputType = {
    id: string | null
    userId: string | null
    secret: string | null
    verified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwoFactorAuthMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    secret: string | null
    verified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwoFactorAuthCountAggregateOutputType = {
    id: number
    userId: number
    secret: number
    verified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwoFactorAuthMinAggregateInputType = {
    id?: true
    userId?: true
    secret?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwoFactorAuthMaxAggregateInputType = {
    id?: true
    userId?: true
    secret?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwoFactorAuthCountAggregateInputType = {
    id?: true
    userId?: true
    secret?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwoFactorAuthAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorAuth to aggregate.
     */
    where?: TwoFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAuths to fetch.
     */
    orderBy?: Enumerable<TwoFactorAuthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwoFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwoFactorAuths
    **/
    _count?: true | TwoFactorAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwoFactorAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwoFactorAuthMaxAggregateInputType
  }

  export type GetTwoFactorAuthAggregateType<T extends TwoFactorAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateTwoFactorAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwoFactorAuth[P]>
      : GetScalarType<T[P], AggregateTwoFactorAuth[P]>
  }




  export type TwoFactorAuthGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TwoFactorAuthWhereInput
    orderBy?: Enumerable<TwoFactorAuthOrderByWithAggregationInput>
    by: TwoFactorAuthScalarFieldEnum[]
    having?: TwoFactorAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwoFactorAuthCountAggregateInputType | true
    _min?: TwoFactorAuthMinAggregateInputType
    _max?: TwoFactorAuthMaxAggregateInputType
  }


  export type TwoFactorAuthGroupByOutputType = {
    id: string
    userId: string
    secret: string
    verified: boolean
    createdAt: Date
    updatedAt: Date
    _count: TwoFactorAuthCountAggregateOutputType | null
    _min: TwoFactorAuthMinAggregateOutputType | null
    _max: TwoFactorAuthMaxAggregateOutputType | null
  }

  type GetTwoFactorAuthGroupByPayload<T extends TwoFactorAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TwoFactorAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwoFactorAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwoFactorAuthGroupByOutputType[P]>
            : GetScalarType<T[P], TwoFactorAuthGroupByOutputType[P]>
        }
      >
    >


  export type TwoFactorAuthSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    secret?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactorAuth"]>

  export type TwoFactorAuthSelectScalar = {
    id?: boolean
    userId?: boolean
    secret?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TwoFactorAuthInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type TwoFactorAuthGetPayload<S extends boolean | null | undefined | TwoFactorAuthArgs> = $Types.GetResult<TwoFactorAuthPayload, S>

  type TwoFactorAuthCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TwoFactorAuthFindManyArgs, 'select' | 'include'> & {
      select?: TwoFactorAuthCountAggregateInputType | true
    }

  export interface TwoFactorAuthDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwoFactorAuth'], meta: { name: 'TwoFactorAuth' } }
    /**
     * Find zero or one TwoFactorAuth that matches the filter.
     * @param {TwoFactorAuthFindUniqueArgs} args - Arguments to find a TwoFactorAuth
     * @example
     * // Get one TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TwoFactorAuthFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TwoFactorAuthFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TwoFactorAuth'> extends True ? Prisma__TwoFactorAuthClient<$Types.GetResult<TwoFactorAuthPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TwoFactorAuthClient<$Types.GetResult<TwoFactorAuthPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one TwoFactorAuth that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TwoFactorAuthFindUniqueOrThrowArgs} args - Arguments to find a TwoFactorAuth
     * @example
     * // Get one TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TwoFactorAuthFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorAuthFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TwoFactorAuthClient<$Types.GetResult<TwoFactorAuthPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first TwoFactorAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthFindFirstArgs} args - Arguments to find a TwoFactorAuth
     * @example
     * // Get one TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TwoFactorAuthFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TwoFactorAuthFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TwoFactorAuth'> extends True ? Prisma__TwoFactorAuthClient<$Types.GetResult<TwoFactorAuthPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TwoFactorAuthClient<$Types.GetResult<TwoFactorAuthPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first TwoFactorAuth that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthFindFirstOrThrowArgs} args - Arguments to find a TwoFactorAuth
     * @example
     * // Get one TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TwoFactorAuthFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorAuthFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TwoFactorAuthClient<$Types.GetResult<TwoFactorAuthPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more TwoFactorAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwoFactorAuths
     * const twoFactorAuths = await prisma.twoFactorAuth.findMany()
     * 
     * // Get first 10 TwoFactorAuths
     * const twoFactorAuths = await prisma.twoFactorAuth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twoFactorAuthWithIdOnly = await prisma.twoFactorAuth.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TwoFactorAuthFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorAuthFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TwoFactorAuthPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a TwoFactorAuth.
     * @param {TwoFactorAuthCreateArgs} args - Arguments to create a TwoFactorAuth.
     * @example
     * // Create one TwoFactorAuth
     * const TwoFactorAuth = await prisma.twoFactorAuth.create({
     *   data: {
     *     // ... data to create a TwoFactorAuth
     *   }
     * })
     * 
    **/
    create<T extends TwoFactorAuthCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorAuthCreateArgs<ExtArgs>>
    ): Prisma__TwoFactorAuthClient<$Types.GetResult<TwoFactorAuthPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many TwoFactorAuths.
     *     @param {TwoFactorAuthCreateManyArgs} args - Arguments to create many TwoFactorAuths.
     *     @example
     *     // Create many TwoFactorAuths
     *     const twoFactorAuth = await prisma.twoFactorAuth.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TwoFactorAuthCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorAuthCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwoFactorAuth.
     * @param {TwoFactorAuthDeleteArgs} args - Arguments to delete one TwoFactorAuth.
     * @example
     * // Delete one TwoFactorAuth
     * const TwoFactorAuth = await prisma.twoFactorAuth.delete({
     *   where: {
     *     // ... filter to delete one TwoFactorAuth
     *   }
     * })
     * 
    **/
    delete<T extends TwoFactorAuthDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorAuthDeleteArgs<ExtArgs>>
    ): Prisma__TwoFactorAuthClient<$Types.GetResult<TwoFactorAuthPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one TwoFactorAuth.
     * @param {TwoFactorAuthUpdateArgs} args - Arguments to update one TwoFactorAuth.
     * @example
     * // Update one TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TwoFactorAuthUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorAuthUpdateArgs<ExtArgs>>
    ): Prisma__TwoFactorAuthClient<$Types.GetResult<TwoFactorAuthPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more TwoFactorAuths.
     * @param {TwoFactorAuthDeleteManyArgs} args - Arguments to filter TwoFactorAuths to delete.
     * @example
     * // Delete a few TwoFactorAuths
     * const { count } = await prisma.twoFactorAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TwoFactorAuthDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TwoFactorAuthDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactorAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwoFactorAuths
     * const twoFactorAuth = await prisma.twoFactorAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TwoFactorAuthUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorAuthUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwoFactorAuth.
     * @param {TwoFactorAuthUpsertArgs} args - Arguments to update or create a TwoFactorAuth.
     * @example
     * // Update or create a TwoFactorAuth
     * const twoFactorAuth = await prisma.twoFactorAuth.upsert({
     *   create: {
     *     // ... data to create a TwoFactorAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwoFactorAuth we want to update
     *   }
     * })
    **/
    upsert<T extends TwoFactorAuthUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TwoFactorAuthUpsertArgs<ExtArgs>>
    ): Prisma__TwoFactorAuthClient<$Types.GetResult<TwoFactorAuthPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of TwoFactorAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthCountArgs} args - Arguments to filter TwoFactorAuths to count.
     * @example
     * // Count the number of TwoFactorAuths
     * const count = await prisma.twoFactorAuth.count({
     *   where: {
     *     // ... the filter for the TwoFactorAuths we want to count
     *   }
     * })
    **/
    count<T extends TwoFactorAuthCountArgs>(
      args?: Subset<T, TwoFactorAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwoFactorAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwoFactorAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwoFactorAuthAggregateArgs>(args: Subset<T, TwoFactorAuthAggregateArgs>): Prisma.PrismaPromise<GetTwoFactorAuthAggregateType<T>>

    /**
     * Group by TwoFactorAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwoFactorAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwoFactorAuthGroupByArgs['orderBy'] }
        : { orderBy?: TwoFactorAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwoFactorAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwoFactorAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TwoFactorAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TwoFactorAuthClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TwoFactorAuth base type for findUnique actions
   */
  export type TwoFactorAuthFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAuth to fetch.
     */
    where: TwoFactorAuthWhereUniqueInput
  }

  /**
   * TwoFactorAuth findUnique
   */
  export interface TwoFactorAuthFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TwoFactorAuthFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwoFactorAuth findUniqueOrThrow
   */
  export type TwoFactorAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAuth to fetch.
     */
    where: TwoFactorAuthWhereUniqueInput
  }


  /**
   * TwoFactorAuth base type for findFirst actions
   */
  export type TwoFactorAuthFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAuth to fetch.
     */
    where?: TwoFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAuths to fetch.
     */
    orderBy?: Enumerable<TwoFactorAuthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorAuths.
     */
    cursor?: TwoFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorAuths.
     */
    distinct?: Enumerable<TwoFactorAuthScalarFieldEnum>
  }

  /**
   * TwoFactorAuth findFirst
   */
  export interface TwoFactorAuthFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TwoFactorAuthFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TwoFactorAuth findFirstOrThrow
   */
  export type TwoFactorAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAuth to fetch.
     */
    where?: TwoFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAuths to fetch.
     */
    orderBy?: Enumerable<TwoFactorAuthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorAuths.
     */
    cursor?: TwoFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorAuths.
     */
    distinct?: Enumerable<TwoFactorAuthScalarFieldEnum>
  }


  /**
   * TwoFactorAuth findMany
   */
  export type TwoFactorAuthFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAuths to fetch.
     */
    where?: TwoFactorAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAuths to fetch.
     */
    orderBy?: Enumerable<TwoFactorAuthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwoFactorAuths.
     */
    cursor?: TwoFactorAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAuths.
     */
    skip?: number
    distinct?: Enumerable<TwoFactorAuthScalarFieldEnum>
  }


  /**
   * TwoFactorAuth create
   */
  export type TwoFactorAuthCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a TwoFactorAuth.
     */
    data: XOR<TwoFactorAuthCreateInput, TwoFactorAuthUncheckedCreateInput>
  }


  /**
   * TwoFactorAuth createMany
   */
  export type TwoFactorAuthCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwoFactorAuths.
     */
    data: Enumerable<TwoFactorAuthCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TwoFactorAuth update
   */
  export type TwoFactorAuthUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a TwoFactorAuth.
     */
    data: XOR<TwoFactorAuthUpdateInput, TwoFactorAuthUncheckedUpdateInput>
    /**
     * Choose, which TwoFactorAuth to update.
     */
    where: TwoFactorAuthWhereUniqueInput
  }


  /**
   * TwoFactorAuth updateMany
   */
  export type TwoFactorAuthUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwoFactorAuths.
     */
    data: XOR<TwoFactorAuthUpdateManyMutationInput, TwoFactorAuthUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactorAuths to update
     */
    where?: TwoFactorAuthWhereInput
  }


  /**
   * TwoFactorAuth upsert
   */
  export type TwoFactorAuthUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the TwoFactorAuth to update in case it exists.
     */
    where: TwoFactorAuthWhereUniqueInput
    /**
     * In case the TwoFactorAuth found by the `where` argument doesn't exist, create a new TwoFactorAuth with this data.
     */
    create: XOR<TwoFactorAuthCreateInput, TwoFactorAuthUncheckedCreateInput>
    /**
     * In case the TwoFactorAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwoFactorAuthUpdateInput, TwoFactorAuthUncheckedUpdateInput>
  }


  /**
   * TwoFactorAuth delete
   */
  export type TwoFactorAuthDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
    /**
     * Filter which TwoFactorAuth to delete.
     */
    where: TwoFactorAuthWhereUniqueInput
  }


  /**
   * TwoFactorAuth deleteMany
   */
  export type TwoFactorAuthDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorAuths to delete
     */
    where?: TwoFactorAuthWhereInput
  }


  /**
   * TwoFactorAuth without action
   */
  export type TwoFactorAuthArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAuth
     */
    select?: TwoFactorAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TwoFactorAuthInclude<ExtArgs> | null
  }



  /**
   * Model WebAuthnCredential
   */


  export type AggregateWebAuthnCredential = {
    _count: WebAuthnCredentialCountAggregateOutputType | null
    _avg: WebAuthnCredentialAvgAggregateOutputType | null
    _sum: WebAuthnCredentialSumAggregateOutputType | null
    _min: WebAuthnCredentialMinAggregateOutputType | null
    _max: WebAuthnCredentialMaxAggregateOutputType | null
  }

  export type WebAuthnCredentialAvgAggregateOutputType = {
    counter: number | null
  }

  export type WebAuthnCredentialSumAggregateOutputType = {
    counter: number | null
  }

  export type WebAuthnCredentialMinAggregateOutputType = {
    id: string | null
    userId: string | null
    credentialId: string | null
    publicKey: string | null
    counter: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebAuthnCredentialMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    credentialId: string | null
    publicKey: string | null
    counter: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebAuthnCredentialCountAggregateOutputType = {
    id: number
    userId: number
    credentialId: number
    publicKey: number
    counter: number
    transports: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebAuthnCredentialAvgAggregateInputType = {
    counter?: true
  }

  export type WebAuthnCredentialSumAggregateInputType = {
    counter?: true
  }

  export type WebAuthnCredentialMinAggregateInputType = {
    id?: true
    userId?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebAuthnCredentialMaxAggregateInputType = {
    id?: true
    userId?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebAuthnCredentialCountAggregateInputType = {
    id?: true
    userId?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    transports?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebAuthnCredentialAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebAuthnCredential to aggregate.
     */
    where?: WebAuthnCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebAuthnCredentials to fetch.
     */
    orderBy?: Enumerable<WebAuthnCredentialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebAuthnCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebAuthnCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebAuthnCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebAuthnCredentials
    **/
    _count?: true | WebAuthnCredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebAuthnCredentialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebAuthnCredentialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebAuthnCredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebAuthnCredentialMaxAggregateInputType
  }

  export type GetWebAuthnCredentialAggregateType<T extends WebAuthnCredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateWebAuthnCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebAuthnCredential[P]>
      : GetScalarType<T[P], AggregateWebAuthnCredential[P]>
  }




  export type WebAuthnCredentialGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WebAuthnCredentialWhereInput
    orderBy?: Enumerable<WebAuthnCredentialOrderByWithAggregationInput>
    by: WebAuthnCredentialScalarFieldEnum[]
    having?: WebAuthnCredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebAuthnCredentialCountAggregateInputType | true
    _avg?: WebAuthnCredentialAvgAggregateInputType
    _sum?: WebAuthnCredentialSumAggregateInputType
    _min?: WebAuthnCredentialMinAggregateInputType
    _max?: WebAuthnCredentialMaxAggregateInputType
  }


  export type WebAuthnCredentialGroupByOutputType = {
    id: string
    userId: string
    credentialId: string
    publicKey: string
    counter: number
    transports: string[]
    createdAt: Date
    updatedAt: Date
    _count: WebAuthnCredentialCountAggregateOutputType | null
    _avg: WebAuthnCredentialAvgAggregateOutputType | null
    _sum: WebAuthnCredentialSumAggregateOutputType | null
    _min: WebAuthnCredentialMinAggregateOutputType | null
    _max: WebAuthnCredentialMaxAggregateOutputType | null
  }

  type GetWebAuthnCredentialGroupByPayload<T extends WebAuthnCredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WebAuthnCredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebAuthnCredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebAuthnCredentialGroupByOutputType[P]>
            : GetScalarType<T[P], WebAuthnCredentialGroupByOutputType[P]>
        }
      >
    >


  export type WebAuthnCredentialSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    transports?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["webAuthnCredential"]>

  export type WebAuthnCredentialSelectScalar = {
    id?: boolean
    userId?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    transports?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebAuthnCredentialInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type WebAuthnCredentialGetPayload<S extends boolean | null | undefined | WebAuthnCredentialArgs> = $Types.GetResult<WebAuthnCredentialPayload, S>

  type WebAuthnCredentialCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<WebAuthnCredentialFindManyArgs, 'select' | 'include'> & {
      select?: WebAuthnCredentialCountAggregateInputType | true
    }

  export interface WebAuthnCredentialDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebAuthnCredential'], meta: { name: 'WebAuthnCredential' } }
    /**
     * Find zero or one WebAuthnCredential that matches the filter.
     * @param {WebAuthnCredentialFindUniqueArgs} args - Arguments to find a WebAuthnCredential
     * @example
     * // Get one WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WebAuthnCredentialFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WebAuthnCredentialFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WebAuthnCredential'> extends True ? Prisma__WebAuthnCredentialClient<$Types.GetResult<WebAuthnCredentialPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__WebAuthnCredentialClient<$Types.GetResult<WebAuthnCredentialPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one WebAuthnCredential that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WebAuthnCredentialFindUniqueOrThrowArgs} args - Arguments to find a WebAuthnCredential
     * @example
     * // Get one WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WebAuthnCredentialFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WebAuthnCredentialFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WebAuthnCredentialClient<$Types.GetResult<WebAuthnCredentialPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first WebAuthnCredential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialFindFirstArgs} args - Arguments to find a WebAuthnCredential
     * @example
     * // Get one WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WebAuthnCredentialFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WebAuthnCredentialFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WebAuthnCredential'> extends True ? Prisma__WebAuthnCredentialClient<$Types.GetResult<WebAuthnCredentialPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__WebAuthnCredentialClient<$Types.GetResult<WebAuthnCredentialPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first WebAuthnCredential that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialFindFirstOrThrowArgs} args - Arguments to find a WebAuthnCredential
     * @example
     * // Get one WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WebAuthnCredentialFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WebAuthnCredentialFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WebAuthnCredentialClient<$Types.GetResult<WebAuthnCredentialPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more WebAuthnCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebAuthnCredentials
     * const webAuthnCredentials = await prisma.webAuthnCredential.findMany()
     * 
     * // Get first 10 WebAuthnCredentials
     * const webAuthnCredentials = await prisma.webAuthnCredential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webAuthnCredentialWithIdOnly = await prisma.webAuthnCredential.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WebAuthnCredentialFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WebAuthnCredentialFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<WebAuthnCredentialPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a WebAuthnCredential.
     * @param {WebAuthnCredentialCreateArgs} args - Arguments to create a WebAuthnCredential.
     * @example
     * // Create one WebAuthnCredential
     * const WebAuthnCredential = await prisma.webAuthnCredential.create({
     *   data: {
     *     // ... data to create a WebAuthnCredential
     *   }
     * })
     * 
    **/
    create<T extends WebAuthnCredentialCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WebAuthnCredentialCreateArgs<ExtArgs>>
    ): Prisma__WebAuthnCredentialClient<$Types.GetResult<WebAuthnCredentialPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many WebAuthnCredentials.
     *     @param {WebAuthnCredentialCreateManyArgs} args - Arguments to create many WebAuthnCredentials.
     *     @example
     *     // Create many WebAuthnCredentials
     *     const webAuthnCredential = await prisma.webAuthnCredential.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WebAuthnCredentialCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WebAuthnCredentialCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WebAuthnCredential.
     * @param {WebAuthnCredentialDeleteArgs} args - Arguments to delete one WebAuthnCredential.
     * @example
     * // Delete one WebAuthnCredential
     * const WebAuthnCredential = await prisma.webAuthnCredential.delete({
     *   where: {
     *     // ... filter to delete one WebAuthnCredential
     *   }
     * })
     * 
    **/
    delete<T extends WebAuthnCredentialDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WebAuthnCredentialDeleteArgs<ExtArgs>>
    ): Prisma__WebAuthnCredentialClient<$Types.GetResult<WebAuthnCredentialPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one WebAuthnCredential.
     * @param {WebAuthnCredentialUpdateArgs} args - Arguments to update one WebAuthnCredential.
     * @example
     * // Update one WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WebAuthnCredentialUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WebAuthnCredentialUpdateArgs<ExtArgs>>
    ): Prisma__WebAuthnCredentialClient<$Types.GetResult<WebAuthnCredentialPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more WebAuthnCredentials.
     * @param {WebAuthnCredentialDeleteManyArgs} args - Arguments to filter WebAuthnCredentials to delete.
     * @example
     * // Delete a few WebAuthnCredentials
     * const { count } = await prisma.webAuthnCredential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WebAuthnCredentialDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WebAuthnCredentialDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebAuthnCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebAuthnCredentials
     * const webAuthnCredential = await prisma.webAuthnCredential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WebAuthnCredentialUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WebAuthnCredentialUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebAuthnCredential.
     * @param {WebAuthnCredentialUpsertArgs} args - Arguments to update or create a WebAuthnCredential.
     * @example
     * // Update or create a WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.upsert({
     *   create: {
     *     // ... data to create a WebAuthnCredential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebAuthnCredential we want to update
     *   }
     * })
    **/
    upsert<T extends WebAuthnCredentialUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WebAuthnCredentialUpsertArgs<ExtArgs>>
    ): Prisma__WebAuthnCredentialClient<$Types.GetResult<WebAuthnCredentialPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of WebAuthnCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialCountArgs} args - Arguments to filter WebAuthnCredentials to count.
     * @example
     * // Count the number of WebAuthnCredentials
     * const count = await prisma.webAuthnCredential.count({
     *   where: {
     *     // ... the filter for the WebAuthnCredentials we want to count
     *   }
     * })
    **/
    count<T extends WebAuthnCredentialCountArgs>(
      args?: Subset<T, WebAuthnCredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebAuthnCredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebAuthnCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebAuthnCredentialAggregateArgs>(args: Subset<T, WebAuthnCredentialAggregateArgs>): Prisma.PrismaPromise<GetWebAuthnCredentialAggregateType<T>>

    /**
     * Group by WebAuthnCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebAuthnCredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebAuthnCredentialGroupByArgs['orderBy'] }
        : { orderBy?: WebAuthnCredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebAuthnCredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebAuthnCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WebAuthnCredential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WebAuthnCredentialClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WebAuthnCredential base type for findUnique actions
   */
  export type WebAuthnCredentialFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * Filter, which WebAuthnCredential to fetch.
     */
    where: WebAuthnCredentialWhereUniqueInput
  }

  /**
   * WebAuthnCredential findUnique
   */
  export interface WebAuthnCredentialFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends WebAuthnCredentialFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WebAuthnCredential findUniqueOrThrow
   */
  export type WebAuthnCredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * Filter, which WebAuthnCredential to fetch.
     */
    where: WebAuthnCredentialWhereUniqueInput
  }


  /**
   * WebAuthnCredential base type for findFirst actions
   */
  export type WebAuthnCredentialFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * Filter, which WebAuthnCredential to fetch.
     */
    where?: WebAuthnCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebAuthnCredentials to fetch.
     */
    orderBy?: Enumerable<WebAuthnCredentialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebAuthnCredentials.
     */
    cursor?: WebAuthnCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebAuthnCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebAuthnCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebAuthnCredentials.
     */
    distinct?: Enumerable<WebAuthnCredentialScalarFieldEnum>
  }

  /**
   * WebAuthnCredential findFirst
   */
  export interface WebAuthnCredentialFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends WebAuthnCredentialFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WebAuthnCredential findFirstOrThrow
   */
  export type WebAuthnCredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * Filter, which WebAuthnCredential to fetch.
     */
    where?: WebAuthnCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebAuthnCredentials to fetch.
     */
    orderBy?: Enumerable<WebAuthnCredentialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebAuthnCredentials.
     */
    cursor?: WebAuthnCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebAuthnCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebAuthnCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebAuthnCredentials.
     */
    distinct?: Enumerable<WebAuthnCredentialScalarFieldEnum>
  }


  /**
   * WebAuthnCredential findMany
   */
  export type WebAuthnCredentialFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * Filter, which WebAuthnCredentials to fetch.
     */
    where?: WebAuthnCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebAuthnCredentials to fetch.
     */
    orderBy?: Enumerable<WebAuthnCredentialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebAuthnCredentials.
     */
    cursor?: WebAuthnCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebAuthnCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebAuthnCredentials.
     */
    skip?: number
    distinct?: Enumerable<WebAuthnCredentialScalarFieldEnum>
  }


  /**
   * WebAuthnCredential create
   */
  export type WebAuthnCredentialCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * The data needed to create a WebAuthnCredential.
     */
    data: XOR<WebAuthnCredentialCreateInput, WebAuthnCredentialUncheckedCreateInput>
  }


  /**
   * WebAuthnCredential createMany
   */
  export type WebAuthnCredentialCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebAuthnCredentials.
     */
    data: Enumerable<WebAuthnCredentialCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WebAuthnCredential update
   */
  export type WebAuthnCredentialUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * The data needed to update a WebAuthnCredential.
     */
    data: XOR<WebAuthnCredentialUpdateInput, WebAuthnCredentialUncheckedUpdateInput>
    /**
     * Choose, which WebAuthnCredential to update.
     */
    where: WebAuthnCredentialWhereUniqueInput
  }


  /**
   * WebAuthnCredential updateMany
   */
  export type WebAuthnCredentialUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebAuthnCredentials.
     */
    data: XOR<WebAuthnCredentialUpdateManyMutationInput, WebAuthnCredentialUncheckedUpdateManyInput>
    /**
     * Filter which WebAuthnCredentials to update
     */
    where?: WebAuthnCredentialWhereInput
  }


  /**
   * WebAuthnCredential upsert
   */
  export type WebAuthnCredentialUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * The filter to search for the WebAuthnCredential to update in case it exists.
     */
    where: WebAuthnCredentialWhereUniqueInput
    /**
     * In case the WebAuthnCredential found by the `where` argument doesn't exist, create a new WebAuthnCredential with this data.
     */
    create: XOR<WebAuthnCredentialCreateInput, WebAuthnCredentialUncheckedCreateInput>
    /**
     * In case the WebAuthnCredential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebAuthnCredentialUpdateInput, WebAuthnCredentialUncheckedUpdateInput>
  }


  /**
   * WebAuthnCredential delete
   */
  export type WebAuthnCredentialDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
    /**
     * Filter which WebAuthnCredential to delete.
     */
    where: WebAuthnCredentialWhereUniqueInput
  }


  /**
   * WebAuthnCredential deleteMany
   */
  export type WebAuthnCredentialDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebAuthnCredentials to delete
     */
    where?: WebAuthnCredentialWhereInput
  }


  /**
   * WebAuthnCredential without action
   */
  export type WebAuthnCredentialArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    auth0Id: 'auth0Id',
    email: 'email',
    name: 'name',
    avatar: 'avatar',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    pushTokens: 'pushTokens',
    notificationSettings: 'notificationSettings',
    referralCode: 'referralCode',
    referredById: 'referredById'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProviderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    businessName: 'businessName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProviderScalarFieldEnum = (typeof ProviderScalarFieldEnum)[keyof typeof ProviderScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    name: 'name',
    price: 'price',
    duration: 'duration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const BusinessScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    name: 'name',
    address: 'address',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessScalarFieldEnum = (typeof BusinessScalarFieldEnum)[keyof typeof BusinessScalarFieldEnum]


  export const BusinessHourScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    dayOfWeek: 'dayOfWeek',
    openTime: 'openTime',
    closeTime: 'closeTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessHourScalarFieldEnum = (typeof BusinessHourScalarFieldEnum)[keyof typeof BusinessHourScalarFieldEnum]


  export const StaffScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    name: 'name',
    role: 'role',
    email: 'email',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const StaffScheduleScalarFieldEnum: {
    id: 'id',
    staffId: 'staffId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffScheduleScalarFieldEnum = (typeof StaffScheduleScalarFieldEnum)[keyof typeof StaffScheduleScalarFieldEnum]


  export const AttendanceRecordScalarFieldEnum: {
    id: 'id',
    scheduleId: 'scheduleId',
    status: 'status',
    timestamp: 'timestamp'
  };

  export type AttendanceRecordScalarFieldEnum = (typeof AttendanceRecordScalarFieldEnum)[keyof typeof AttendanceRecordScalarFieldEnum]


  export const TrainingModuleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    contentUrl: 'contentUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingModuleScalarFieldEnum = (typeof TrainingModuleScalarFieldEnum)[keyof typeof TrainingModuleScalarFieldEnum]


  export const TrainingProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    moduleId: 'moduleId',
    completedAt: 'completedAt'
  };

  export type TrainingProgressScalarFieldEnum = (typeof TrainingProgressScalarFieldEnum)[keyof typeof TrainingProgressScalarFieldEnum]


  export const LoyaltyTierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    requiredPoints: 'requiredPoints',
    discount: 'discount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoyaltyTierScalarFieldEnum = (typeof LoyaltyTierScalarFieldEnum)[keyof typeof LoyaltyTierScalarFieldEnum]


  export const LoyaltyTransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tierId: 'tierId',
    points: 'points',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type LoyaltyTransactionScalarFieldEnum = (typeof LoyaltyTransactionScalarFieldEnum)[keyof typeof LoyaltyTransactionScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    priceId: 'priceId',
    status: 'status',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const AnalyticsEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    event: 'event',
    properties: 'properties',
    createdAt: 'createdAt'
  };

  export type AnalyticsEventScalarFieldEnum = (typeof AnalyticsEventScalarFieldEnum)[keyof typeof AnalyticsEventScalarFieldEnum]


  export const PaymentTransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    currency: 'currency',
    mode: 'mode',
    createdAt: 'createdAt',
    serviceId: 'serviceId'
  };

  export type PaymentTransactionScalarFieldEnum = (typeof PaymentTransactionScalarFieldEnum)[keyof typeof PaymentTransactionScalarFieldEnum]


  export const PromotionCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    discount: 'discount',
    validFrom: 'validFrom',
    validTo: 'validTo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromotionCodeScalarFieldEnum = (typeof PromotionCodeScalarFieldEnum)[keyof typeof PromotionCodeScalarFieldEnum]


  export const EmailCampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    body: 'body',
    scheduledAt: 'scheduledAt',
    sent: 'sent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailCampaignScalarFieldEnum = (typeof EmailCampaignScalarFieldEnum)[keyof typeof EmailCampaignScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    read: 'read',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const GoogleCalendarTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    scope: 'scope',
    tokenType: 'tokenType',
    expiryDate: 'expiryDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GoogleCalendarTokenScalarFieldEnum = (typeof GoogleCalendarTokenScalarFieldEnum)[keyof typeof GoogleCalendarTokenScalarFieldEnum]


  export const OutlookCalendarTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    scope: 'scope',
    tokenType: 'tokenType',
    expiryDate: 'expiryDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OutlookCalendarTokenScalarFieldEnum = (typeof OutlookCalendarTokenScalarFieldEnum)[keyof typeof OutlookCalendarTokenScalarFieldEnum]


  export const FormDefinitionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    fields: 'fields',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormDefinitionScalarFieldEnum = (typeof FormDefinitionScalarFieldEnum)[keyof typeof FormDefinitionScalarFieldEnum]


  export const FormSubmissionScalarFieldEnum: {
    id: 'id',
    definitionId: 'definitionId',
    data: 'data',
    submittedAt: 'submittedAt'
  };

  export type FormSubmissionScalarFieldEnum = (typeof FormSubmissionScalarFieldEnum)[keyof typeof FormSubmissionScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    url: 'url',
    type: 'type',
    submissionId: 'submissionId',
    createdAt: 'createdAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const EquipmentItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    serialNumber: 'serialNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipmentItemScalarFieldEnum = (typeof EquipmentItemScalarFieldEnum)[keyof typeof EquipmentItemScalarFieldEnum]


  export const EquipmentAssignmentScalarFieldEnum: {
    id: 'id',
    equipmentId: 'equipmentId',
    assignedTo: 'assignedTo',
    assignedAt: 'assignedAt',
    returnedAt: 'returnedAt'
  };

  export type EquipmentAssignmentScalarFieldEnum = (typeof EquipmentAssignmentScalarFieldEnum)[keyof typeof EquipmentAssignmentScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    authorId: 'authorId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const CommunityEventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startAt: 'startAt',
    endAt: 'endAt',
    location: 'location',
    createdAt: 'createdAt'
  };

  export type CommunityEventScalarFieldEnum = (typeof CommunityEventScalarFieldEnum)[keyof typeof CommunityEventScalarFieldEnum]


  export const SocialPostScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialPostScalarFieldEnum = (typeof SocialPostScalarFieldEnum)[keyof typeof SocialPostScalarFieldEnum]


  export const PostCommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    authorId: 'authorId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type PostCommentScalarFieldEnum = (typeof PostCommentScalarFieldEnum)[keyof typeof PostCommentScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventRegistrationScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    registeredAt: 'registeredAt'
  };

  export type EventRegistrationScalarFieldEnum = (typeof EventRegistrationScalarFieldEnum)[keyof typeof EventRegistrationScalarFieldEnum]


  export const ForumThreadScalarFieldEnum: {
    id: 'id',
    title: 'title',
    authorId: 'authorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumThreadScalarFieldEnum = (typeof ForumThreadScalarFieldEnum)[keyof typeof ForumThreadScalarFieldEnum]


  export const ForumPostScalarFieldEnum: {
    id: 'id',
    threadId: 'threadId',
    authorId: 'authorId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type ForumPostScalarFieldEnum = (typeof ForumPostScalarFieldEnum)[keyof typeof ForumPostScalarFieldEnum]


  export const BenefitClaimScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    status: 'status',
    amount: 'amount',
    requestedAt: 'requestedAt',
    processedAt: 'processedAt'
  };

  export type BenefitClaimScalarFieldEnum = (typeof BenefitClaimScalarFieldEnum)[keyof typeof BenefitClaimScalarFieldEnum]


  export const PayrollRecordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    salary: 'salary',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayrollRecordScalarFieldEnum = (typeof PayrollRecordScalarFieldEnum)[keyof typeof PayrollRecordScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    serviceId: 'serviceId',
    appointmentDate: 'appointmentDate',
    duration: 'duration',
    specialRequests: 'specialRequests',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    googleEventId: 'googleEventId',
    outlookEventId: 'outlookEventId'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const TwoFactorAuthScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    secret: 'secret',
    verified: 'verified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwoFactorAuthScalarFieldEnum = (typeof TwoFactorAuthScalarFieldEnum)[keyof typeof TwoFactorAuthScalarFieldEnum]


  export const WebAuthnCredentialScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    credentialId: 'credentialId',
    publicKey: 'publicKey',
    counter: 'counter',
    transports: 'transports',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebAuthnCredentialScalarFieldEnum = (typeof WebAuthnCredentialScalarFieldEnum)[keyof typeof WebAuthnCredentialScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    auth0Id?: StringNullableFilter | string | null
    email?: StringFilter | string
    name?: StringNullableFilter | string | null
    avatar?: StringNullableFilter | string | null
    role?: EnumRoleFilter | Role
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    pushTokens?: JsonFilter
    notificationSettings?: JsonFilter
    referralCode?: StringFilter | string
    referredById?: StringNullableFilter | string | null
    transactions?: LoyaltyTransactionListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    referredBy?: XOR<UserRelationFilter, UserWhereInput> | null
    referrals?: UserListRelationFilter
    analyticsEvents?: AnalyticsEventListRelationFilter
    paymentTransactions?: PaymentTransactionListRelationFilter
    trainingProgress?: TrainingProgressListRelationFilter
    googleCalendarToken?: XOR<GoogleCalendarTokenRelationFilter, GoogleCalendarTokenWhereInput> | null
    outlookCalendarToken?: XOR<OutlookCalendarTokenRelationFilter, OutlookCalendarTokenWhereInput> | null
    assignments?: EquipmentAssignmentListRelationFilter
    socialPosts?: SocialPostListRelationFilter
    postComments?: PostCommentListRelationFilter
    eventRegistrations?: EventRegistrationListRelationFilter
    forumThreads?: ForumThreadListRelationFilter
    forumPosts?: ForumPostListRelationFilter
    benefitClaims?: BenefitClaimListRelationFilter
    payrollRecords?: PayrollRecordListRelationFilter
    bookings?: BookingListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    twoFactorAuth?: XOR<TwoFactorAuthRelationFilter, TwoFactorAuthWhereInput> | null
    webAuthnCredentials?: WebAuthnCredentialListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    auth0Id?: SortOrderInput | SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pushTokens?: SortOrder
    notificationSettings?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrderInput | SortOrder
    transactions?: LoyaltyTransactionOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    referredBy?: UserOrderByWithRelationInput
    referrals?: UserOrderByRelationAggregateInput
    analyticsEvents?: AnalyticsEventOrderByRelationAggregateInput
    paymentTransactions?: PaymentTransactionOrderByRelationAggregateInput
    trainingProgress?: TrainingProgressOrderByRelationAggregateInput
    googleCalendarToken?: GoogleCalendarTokenOrderByWithRelationInput
    outlookCalendarToken?: OutlookCalendarTokenOrderByWithRelationInput
    assignments?: EquipmentAssignmentOrderByRelationAggregateInput
    socialPosts?: SocialPostOrderByRelationAggregateInput
    postComments?: PostCommentOrderByRelationAggregateInput
    eventRegistrations?: EventRegistrationOrderByRelationAggregateInput
    forumThreads?: ForumThreadOrderByRelationAggregateInput
    forumPosts?: ForumPostOrderByRelationAggregateInput
    benefitClaims?: BenefitClaimOrderByRelationAggregateInput
    payrollRecords?: PayrollRecordOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    twoFactorAuth?: TwoFactorAuthOrderByWithRelationInput
    webAuthnCredentials?: WebAuthnCredentialOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    auth0Id?: string
    email?: string
    referralCode?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    auth0Id?: SortOrderInput | SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pushTokens?: SortOrder
    notificationSettings?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    auth0Id?: StringNullableWithAggregatesFilter | string | null
    email?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    avatar?: StringNullableWithAggregatesFilter | string | null
    role?: EnumRoleWithAggregatesFilter | Role
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    pushTokens?: JsonWithAggregatesFilter
    notificationSettings?: JsonWithAggregatesFilter
    referralCode?: StringWithAggregatesFilter | string
    referredById?: StringNullableWithAggregatesFilter | string | null
  }

  export type ProviderWhereInput = {
    AND?: Enumerable<ProviderWhereInput>
    OR?: Enumerable<ProviderWhereInput>
    NOT?: Enumerable<ProviderWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    businessName?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    services?: ServiceListRelationFilter
    businesses?: BusinessListRelationFilter
  }

  export type ProviderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
    businesses?: BusinessOrderByRelationAggregateInput
  }

  export type ProviderWhereUniqueInput = {
    id?: string
  }

  export type ProviderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProviderCountOrderByAggregateInput
    _max?: ProviderMaxOrderByAggregateInput
    _min?: ProviderMinOrderByAggregateInput
  }

  export type ProviderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProviderScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProviderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProviderScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    businessName?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ServiceWhereInput = {
    AND?: Enumerable<ServiceWhereInput>
    OR?: Enumerable<ServiceWhereInput>
    NOT?: Enumerable<ServiceWhereInput>
    id?: StringFilter | string
    providerId?: StringFilter | string
    name?: StringFilter | string
    price?: FloatFilter | number
    duration?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    provider?: XOR<ProviderRelationFilter, ProviderWhereInput>
    paymentTransactions?: PaymentTransactionListRelationFilter
    bookings?: BookingListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: ProviderOrderByWithRelationInput
    paymentTransactions?: PaymentTransactionOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = {
    id?: string
  }

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    providerId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    duration?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BusinessWhereInput = {
    AND?: Enumerable<BusinessWhereInput>
    OR?: Enumerable<BusinessWhereInput>
    NOT?: Enumerable<BusinessWhereInput>
    id?: StringFilter | string
    providerId?: StringFilter | string
    name?: StringFilter | string
    address?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    provider?: XOR<ProviderRelationFilter, ProviderWhereInput>
    hours?: BusinessHourListRelationFilter
    staff?: StaffListRelationFilter
  }

  export type BusinessOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: ProviderOrderByWithRelationInput
    hours?: BusinessHourOrderByRelationAggregateInput
    staff?: StaffOrderByRelationAggregateInput
  }

  export type BusinessWhereUniqueInput = {
    id?: string
    providerId?: string
  }

  export type BusinessOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessCountOrderByAggregateInput
    _max?: BusinessMaxOrderByAggregateInput
    _min?: BusinessMinOrderByAggregateInput
  }

  export type BusinessScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BusinessScalarWhereWithAggregatesInput>
    OR?: Enumerable<BusinessScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BusinessScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    providerId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    address?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BusinessHourWhereInput = {
    AND?: Enumerable<BusinessHourWhereInput>
    OR?: Enumerable<BusinessHourWhereInput>
    NOT?: Enumerable<BusinessHourWhereInput>
    id?: StringFilter | string
    businessId?: StringFilter | string
    dayOfWeek?: IntFilter | number
    openTime?: StringFilter | string
    closeTime?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }

  export type BusinessHourOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
  }

  export type BusinessHourWhereUniqueInput = {
    id?: string
  }

  export type BusinessHourOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessHourCountOrderByAggregateInput
    _avg?: BusinessHourAvgOrderByAggregateInput
    _max?: BusinessHourMaxOrderByAggregateInput
    _min?: BusinessHourMinOrderByAggregateInput
    _sum?: BusinessHourSumOrderByAggregateInput
  }

  export type BusinessHourScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BusinessHourScalarWhereWithAggregatesInput>
    OR?: Enumerable<BusinessHourScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BusinessHourScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    businessId?: StringWithAggregatesFilter | string
    dayOfWeek?: IntWithAggregatesFilter | number
    openTime?: StringWithAggregatesFilter | string
    closeTime?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StaffWhereInput = {
    AND?: Enumerable<StaffWhereInput>
    OR?: Enumerable<StaffWhereInput>
    NOT?: Enumerable<StaffWhereInput>
    id?: StringFilter | string
    businessId?: StringFilter | string
    name?: StringFilter | string
    role?: StringFilter | string
    email?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
    schedules?: StaffScheduleListRelationFilter
  }

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
    schedules?: StaffScheduleOrderByRelationAggregateInput
  }

  export type StaffWhereUniqueInput = {
    id?: string
  }

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffCountOrderByAggregateInput
    _max?: StaffMaxOrderByAggregateInput
    _min?: StaffMinOrderByAggregateInput
  }

  export type StaffScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StaffScalarWhereWithAggregatesInput>
    OR?: Enumerable<StaffScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StaffScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    businessId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    role?: StringWithAggregatesFilter | string
    email?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StaffScheduleWhereInput = {
    AND?: Enumerable<StaffScheduleWhereInput>
    OR?: Enumerable<StaffScheduleWhereInput>
    NOT?: Enumerable<StaffScheduleWhereInput>
    id?: StringFilter | string
    staffId?: StringFilter | string
    date?: DateTimeFilter | Date | string
    startTime?: DateTimeFilter | Date | string
    endTime?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    staff?: XOR<StaffRelationFilter, StaffWhereInput>
    attendanceRecords?: AttendanceRecordListRelationFilter
  }

  export type StaffScheduleOrderByWithRelationInput = {
    id?: SortOrder
    staffId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    staff?: StaffOrderByWithRelationInput
    attendanceRecords?: AttendanceRecordOrderByRelationAggregateInput
  }

  export type StaffScheduleWhereUniqueInput = {
    id?: string
  }

  export type StaffScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    staffId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffScheduleCountOrderByAggregateInput
    _max?: StaffScheduleMaxOrderByAggregateInput
    _min?: StaffScheduleMinOrderByAggregateInput
  }

  export type StaffScheduleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StaffScheduleScalarWhereWithAggregatesInput>
    OR?: Enumerable<StaffScheduleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StaffScheduleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    staffId?: StringWithAggregatesFilter | string
    date?: DateTimeWithAggregatesFilter | Date | string
    startTime?: DateTimeWithAggregatesFilter | Date | string
    endTime?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AttendanceRecordWhereInput = {
    AND?: Enumerable<AttendanceRecordWhereInput>
    OR?: Enumerable<AttendanceRecordWhereInput>
    NOT?: Enumerable<AttendanceRecordWhereInput>
    id?: StringFilter | string
    scheduleId?: StringFilter | string
    status?: StringFilter | string
    timestamp?: DateTimeFilter | Date | string
    schedule?: XOR<StaffScheduleRelationFilter, StaffScheduleWhereInput>
  }

  export type AttendanceRecordOrderByWithRelationInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    schedule?: StaffScheduleOrderByWithRelationInput
  }

  export type AttendanceRecordWhereUniqueInput = {
    id?: string
  }

  export type AttendanceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    _count?: AttendanceRecordCountOrderByAggregateInput
    _max?: AttendanceRecordMaxOrderByAggregateInput
    _min?: AttendanceRecordMinOrderByAggregateInput
  }

  export type AttendanceRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AttendanceRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<AttendanceRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AttendanceRecordScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    scheduleId?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    timestamp?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TrainingModuleWhereInput = {
    AND?: Enumerable<TrainingModuleWhereInput>
    OR?: Enumerable<TrainingModuleWhereInput>
    NOT?: Enumerable<TrainingModuleWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    contentUrl?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    trainingProgress?: TrainingProgressListRelationFilter
  }

  export type TrainingModuleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    contentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingProgress?: TrainingProgressOrderByRelationAggregateInput
  }

  export type TrainingModuleWhereUniqueInput = {
    id?: string
  }

  export type TrainingModuleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    contentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingModuleCountOrderByAggregateInput
    _max?: TrainingModuleMaxOrderByAggregateInput
    _min?: TrainingModuleMinOrderByAggregateInput
  }

  export type TrainingModuleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TrainingModuleScalarWhereWithAggregatesInput>
    OR?: Enumerable<TrainingModuleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TrainingModuleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    contentUrl?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TrainingProgressWhereInput = {
    AND?: Enumerable<TrainingProgressWhereInput>
    OR?: Enumerable<TrainingProgressWhereInput>
    NOT?: Enumerable<TrainingProgressWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    moduleId?: StringFilter | string
    completedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    module?: XOR<TrainingModuleRelationFilter, TrainingModuleWhereInput>
  }

  export type TrainingProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    moduleId?: SortOrder
    completedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    module?: TrainingModuleOrderByWithRelationInput
  }

  export type TrainingProgressWhereUniqueInput = {
    id?: string
  }

  export type TrainingProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    moduleId?: SortOrder
    completedAt?: SortOrder
    _count?: TrainingProgressCountOrderByAggregateInput
    _max?: TrainingProgressMaxOrderByAggregateInput
    _min?: TrainingProgressMinOrderByAggregateInput
  }

  export type TrainingProgressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TrainingProgressScalarWhereWithAggregatesInput>
    OR?: Enumerable<TrainingProgressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TrainingProgressScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    moduleId?: StringWithAggregatesFilter | string
    completedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LoyaltyTierWhereInput = {
    AND?: Enumerable<LoyaltyTierWhereInput>
    OR?: Enumerable<LoyaltyTierWhereInput>
    NOT?: Enumerable<LoyaltyTierWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    requiredPoints?: IntFilter | number
    discount?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    transactions?: LoyaltyTransactionListRelationFilter
  }

  export type LoyaltyTierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    requiredPoints?: SortOrder
    discount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactions?: LoyaltyTransactionOrderByRelationAggregateInput
  }

  export type LoyaltyTierWhereUniqueInput = {
    id?: string
  }

  export type LoyaltyTierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    requiredPoints?: SortOrder
    discount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoyaltyTierCountOrderByAggregateInput
    _avg?: LoyaltyTierAvgOrderByAggregateInput
    _max?: LoyaltyTierMaxOrderByAggregateInput
    _min?: LoyaltyTierMinOrderByAggregateInput
    _sum?: LoyaltyTierSumOrderByAggregateInput
  }

  export type LoyaltyTierScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LoyaltyTierScalarWhereWithAggregatesInput>
    OR?: Enumerable<LoyaltyTierScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LoyaltyTierScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    requiredPoints?: IntWithAggregatesFilter | number
    discount?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type LoyaltyTransactionWhereInput = {
    AND?: Enumerable<LoyaltyTransactionWhereInput>
    OR?: Enumerable<LoyaltyTransactionWhereInput>
    NOT?: Enumerable<LoyaltyTransactionWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    tierId?: StringNullableFilter | string | null
    points?: IntFilter | number
    type?: EnumTransactionTypeFilter | TransactionType
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tier?: XOR<LoyaltyTierRelationFilter, LoyaltyTierWhereInput> | null
  }

  export type LoyaltyTransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tierId?: SortOrderInput | SortOrder
    points?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tier?: LoyaltyTierOrderByWithRelationInput
  }

  export type LoyaltyTransactionWhereUniqueInput = {
    id?: string
  }

  export type LoyaltyTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tierId?: SortOrderInput | SortOrder
    points?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: LoyaltyTransactionCountOrderByAggregateInput
    _avg?: LoyaltyTransactionAvgOrderByAggregateInput
    _max?: LoyaltyTransactionMaxOrderByAggregateInput
    _min?: LoyaltyTransactionMinOrderByAggregateInput
    _sum?: LoyaltyTransactionSumOrderByAggregateInput
  }

  export type LoyaltyTransactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LoyaltyTransactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<LoyaltyTransactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LoyaltyTransactionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    tierId?: StringNullableWithAggregatesFilter | string | null
    points?: IntWithAggregatesFilter | number
    type?: EnumTransactionTypeWithAggregatesFilter | TransactionType
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: Enumerable<SubscriptionWhereInput>
    OR?: Enumerable<SubscriptionWhereInput>
    NOT?: Enumerable<SubscriptionWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    stripeSubscriptionId?: StringFilter | string
    priceId?: StringFilter | string
    status?: StringFilter | string
    currentPeriodStart?: DateTimeFilter | Date | string
    currentPeriodEnd?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeSubscriptionId?: SortOrder
    priceId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = {
    id?: string
    stripeSubscriptionId?: string
  }

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeSubscriptionId?: SortOrder
    priceId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    stripeSubscriptionId?: StringWithAggregatesFilter | string
    priceId?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    currentPeriodStart?: DateTimeWithAggregatesFilter | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AnalyticsEventWhereInput = {
    AND?: Enumerable<AnalyticsEventWhereInput>
    OR?: Enumerable<AnalyticsEventWhereInput>
    NOT?: Enumerable<AnalyticsEventWhereInput>
    id?: StringFilter | string
    userId?: StringNullableFilter | string | null
    event?: StringFilter | string
    properties?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type AnalyticsEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    event?: SortOrder
    properties?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AnalyticsEventWhereUniqueInput = {
    id?: string
  }

  export type AnalyticsEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    event?: SortOrder
    properties?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AnalyticsEventCountOrderByAggregateInput
    _max?: AnalyticsEventMaxOrderByAggregateInput
    _min?: AnalyticsEventMinOrderByAggregateInput
  }

  export type AnalyticsEventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AnalyticsEventScalarWhereWithAggregatesInput>
    OR?: Enumerable<AnalyticsEventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AnalyticsEventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    event?: StringWithAggregatesFilter | string
    properties?: JsonNullableWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PaymentTransactionWhereInput = {
    AND?: Enumerable<PaymentTransactionWhereInput>
    OR?: Enumerable<PaymentTransactionWhereInput>
    NOT?: Enumerable<PaymentTransactionWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    amount?: IntFilter | number
    currency?: StringFilter | string
    mode?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    serviceId?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput> | null
  }

  export type PaymentTransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    mode?: SortOrder
    createdAt?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type PaymentTransactionWhereUniqueInput = {
    id?: string
  }

  export type PaymentTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    mode?: SortOrder
    createdAt?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    _count?: PaymentTransactionCountOrderByAggregateInput
    _avg?: PaymentTransactionAvgOrderByAggregateInput
    _max?: PaymentTransactionMaxOrderByAggregateInput
    _min?: PaymentTransactionMinOrderByAggregateInput
    _sum?: PaymentTransactionSumOrderByAggregateInput
  }

  export type PaymentTransactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentTransactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentTransactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentTransactionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    amount?: IntWithAggregatesFilter | number
    currency?: StringWithAggregatesFilter | string
    mode?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    serviceId?: StringNullableWithAggregatesFilter | string | null
  }

  export type PromotionCodeWhereInput = {
    AND?: Enumerable<PromotionCodeWhereInput>
    OR?: Enumerable<PromotionCodeWhereInput>
    NOT?: Enumerable<PromotionCodeWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    description?: StringNullableFilter | string | null
    discount?: FloatFilter | number
    validFrom?: DateTimeFilter | Date | string
    validTo?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PromotionCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discount?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionCodeWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type PromotionCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discount?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromotionCodeCountOrderByAggregateInput
    _avg?: PromotionCodeAvgOrderByAggregateInput
    _max?: PromotionCodeMaxOrderByAggregateInput
    _min?: PromotionCodeMinOrderByAggregateInput
    _sum?: PromotionCodeSumOrderByAggregateInput
  }

  export type PromotionCodeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PromotionCodeScalarWhereWithAggregatesInput>
    OR?: Enumerable<PromotionCodeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PromotionCodeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    discount?: FloatWithAggregatesFilter | number
    validFrom?: DateTimeWithAggregatesFilter | Date | string
    validTo?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EmailCampaignWhereInput = {
    AND?: Enumerable<EmailCampaignWhereInput>
    OR?: Enumerable<EmailCampaignWhereInput>
    NOT?: Enumerable<EmailCampaignWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    subject?: StringFilter | string
    body?: StringFilter | string
    scheduledAt?: DateTimeNullableFilter | Date | string | null
    sent?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type EmailCampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    sent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailCampaignWhereUniqueInput = {
    id?: string
  }

  export type EmailCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    sent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailCampaignCountOrderByAggregateInput
    _max?: EmailCampaignMaxOrderByAggregateInput
    _min?: EmailCampaignMinOrderByAggregateInput
  }

  export type EmailCampaignScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EmailCampaignScalarWhereWithAggregatesInput>
    OR?: Enumerable<EmailCampaignScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EmailCampaignScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    subject?: StringWithAggregatesFilter | string
    body?: StringWithAggregatesFilter | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    sent?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type NotificationWhereInput = {
    AND?: Enumerable<NotificationWhereInput>
    OR?: Enumerable<NotificationWhereInput>
    NOT?: Enumerable<NotificationWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    title?: StringFilter | string
    message?: StringFilter | string
    read?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = {
    id?: string
  }

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    read?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type GoogleCalendarTokenWhereInput = {
    AND?: Enumerable<GoogleCalendarTokenWhereInput>
    OR?: Enumerable<GoogleCalendarTokenWhereInput>
    NOT?: Enumerable<GoogleCalendarTokenWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    accessToken?: StringFilter | string
    refreshToken?: StringFilter | string
    scope?: StringNullableFilter | string | null
    tokenType?: StringNullableFilter | string | null
    expiryDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type GoogleCalendarTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    scope?: SortOrderInput | SortOrder
    tokenType?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GoogleCalendarTokenWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type GoogleCalendarTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    scope?: SortOrderInput | SortOrder
    tokenType?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GoogleCalendarTokenCountOrderByAggregateInput
    _max?: GoogleCalendarTokenMaxOrderByAggregateInput
    _min?: GoogleCalendarTokenMinOrderByAggregateInput
  }

  export type GoogleCalendarTokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GoogleCalendarTokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<GoogleCalendarTokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GoogleCalendarTokenScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    accessToken?: StringWithAggregatesFilter | string
    refreshToken?: StringWithAggregatesFilter | string
    scope?: StringNullableWithAggregatesFilter | string | null
    tokenType?: StringNullableWithAggregatesFilter | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OutlookCalendarTokenWhereInput = {
    AND?: Enumerable<OutlookCalendarTokenWhereInput>
    OR?: Enumerable<OutlookCalendarTokenWhereInput>
    NOT?: Enumerable<OutlookCalendarTokenWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    accessToken?: StringFilter | string
    refreshToken?: StringFilter | string
    scope?: StringNullableFilter | string | null
    tokenType?: StringNullableFilter | string | null
    expiryDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OutlookCalendarTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    scope?: SortOrderInput | SortOrder
    tokenType?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OutlookCalendarTokenWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type OutlookCalendarTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    scope?: SortOrderInput | SortOrder
    tokenType?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OutlookCalendarTokenCountOrderByAggregateInput
    _max?: OutlookCalendarTokenMaxOrderByAggregateInput
    _min?: OutlookCalendarTokenMinOrderByAggregateInput
  }

  export type OutlookCalendarTokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OutlookCalendarTokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<OutlookCalendarTokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OutlookCalendarTokenScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    accessToken?: StringWithAggregatesFilter | string
    refreshToken?: StringWithAggregatesFilter | string
    scope?: StringNullableWithAggregatesFilter | string | null
    tokenType?: StringNullableWithAggregatesFilter | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FormDefinitionWhereInput = {
    AND?: Enumerable<FormDefinitionWhereInput>
    OR?: Enumerable<FormDefinitionWhereInput>
    NOT?: Enumerable<FormDefinitionWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    fields?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    submissions?: FormSubmissionListRelationFilter
  }

  export type FormDefinitionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    fields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submissions?: FormSubmissionOrderByRelationAggregateInput
  }

  export type FormDefinitionWhereUniqueInput = {
    id?: string
  }

  export type FormDefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    fields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormDefinitionCountOrderByAggregateInput
    _max?: FormDefinitionMaxOrderByAggregateInput
    _min?: FormDefinitionMinOrderByAggregateInput
  }

  export type FormDefinitionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FormDefinitionScalarWhereWithAggregatesInput>
    OR?: Enumerable<FormDefinitionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FormDefinitionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    fields?: JsonWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FormSubmissionWhereInput = {
    AND?: Enumerable<FormSubmissionWhereInput>
    OR?: Enumerable<FormSubmissionWhereInput>
    NOT?: Enumerable<FormSubmissionWhereInput>
    id?: StringFilter | string
    definitionId?: StringFilter | string
    data?: JsonFilter
    submittedAt?: DateTimeFilter | Date | string
    definition?: XOR<FormDefinitionRelationFilter, FormDefinitionWhereInput>
    documents?: DocumentListRelationFilter
  }

  export type FormSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    definitionId?: SortOrder
    data?: SortOrder
    submittedAt?: SortOrder
    definition?: FormDefinitionOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
  }

  export type FormSubmissionWhereUniqueInput = {
    id?: string
  }

  export type FormSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    definitionId?: SortOrder
    data?: SortOrder
    submittedAt?: SortOrder
    _count?: FormSubmissionCountOrderByAggregateInput
    _max?: FormSubmissionMaxOrderByAggregateInput
    _min?: FormSubmissionMinOrderByAggregateInput
  }

  export type FormSubmissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FormSubmissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<FormSubmissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FormSubmissionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    definitionId?: StringWithAggregatesFilter | string
    data?: JsonWithAggregatesFilter
    submittedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DocumentWhereInput = {
    AND?: Enumerable<DocumentWhereInput>
    OR?: Enumerable<DocumentWhereInput>
    NOT?: Enumerable<DocumentWhereInput>
    id?: StringFilter | string
    url?: StringFilter | string
    type?: StringFilter | string
    submissionId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    submission?: XOR<FormSubmissionRelationFilter, FormSubmissionWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    submissionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    submission?: FormSubmissionOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = {
    id?: string
  }

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    submissionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    submissionId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type InventoryItemWhereInput = {
    AND?: Enumerable<InventoryItemWhereInput>
    OR?: Enumerable<InventoryItemWhereInput>
    NOT?: Enumerable<InventoryItemWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    quantity?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemWhereUniqueInput = {
    id?: string
  }

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InventoryItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<InventoryItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InventoryItemScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    quantity?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EquipmentItemWhereInput = {
    AND?: Enumerable<EquipmentItemWhereInput>
    OR?: Enumerable<EquipmentItemWhereInput>
    NOT?: Enumerable<EquipmentItemWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    serialNumber?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    assignments?: EquipmentAssignmentListRelationFilter
  }

  export type EquipmentItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignments?: EquipmentAssignmentOrderByRelationAggregateInput
  }

  export type EquipmentItemWhereUniqueInput = {
    id?: string
  }

  export type EquipmentItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipmentItemCountOrderByAggregateInput
    _max?: EquipmentItemMaxOrderByAggregateInput
    _min?: EquipmentItemMinOrderByAggregateInput
  }

  export type EquipmentItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EquipmentItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<EquipmentItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EquipmentItemScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    serialNumber?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EquipmentAssignmentWhereInput = {
    AND?: Enumerable<EquipmentAssignmentWhereInput>
    OR?: Enumerable<EquipmentAssignmentWhereInput>
    NOT?: Enumerable<EquipmentAssignmentWhereInput>
    id?: StringFilter | string
    equipmentId?: StringFilter | string
    assignedTo?: StringFilter | string
    assignedAt?: DateTimeFilter | Date | string
    returnedAt?: DateTimeNullableFilter | Date | string | null
    equipment?: XOR<EquipmentItemRelationFilter, EquipmentItemWhereInput>
    assignedToUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EquipmentAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    assignedTo?: SortOrder
    assignedAt?: SortOrder
    returnedAt?: SortOrderInput | SortOrder
    equipment?: EquipmentItemOrderByWithRelationInput
    assignedToUser?: UserOrderByWithRelationInput
  }

  export type EquipmentAssignmentWhereUniqueInput = {
    id?: string
  }

  export type EquipmentAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    assignedTo?: SortOrder
    assignedAt?: SortOrder
    returnedAt?: SortOrderInput | SortOrder
    _count?: EquipmentAssignmentCountOrderByAggregateInput
    _max?: EquipmentAssignmentMaxOrderByAggregateInput
    _min?: EquipmentAssignmentMinOrderByAggregateInput
  }

  export type EquipmentAssignmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EquipmentAssignmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<EquipmentAssignmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EquipmentAssignmentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    equipmentId?: StringWithAggregatesFilter | string
    assignedTo?: StringWithAggregatesFilter | string
    assignedAt?: DateTimeWithAggregatesFilter | Date | string
    returnedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type PostWhereInput = {
    AND?: Enumerable<PostWhereInput>
    OR?: Enumerable<PostWhereInput>
    NOT?: Enumerable<PostWhereInput>
    id?: StringFilter | string
    authorId?: StringFilter | string
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    author?: UserOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = {
    id?: string
  }

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    authorId?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CommentWhereInput = {
    AND?: Enumerable<CommentWhereInput>
    OR?: Enumerable<CommentWhereInput>
    NOT?: Enumerable<CommentWhereInput>
    id?: StringFilter | string
    postId?: StringFilter | string
    authorId?: StringFilter | string
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    post?: XOR<PostRelationFilter, PostWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    post?: PostOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = {
    id?: string
  }

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    postId?: StringWithAggregatesFilter | string
    authorId?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CommunityEventWhereInput = {
    AND?: Enumerable<CommunityEventWhereInput>
    OR?: Enumerable<CommunityEventWhereInput>
    NOT?: Enumerable<CommunityEventWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    startAt?: DateTimeFilter | Date | string
    endAt?: DateTimeNullableFilter | Date | string | null
    location?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type CommunityEventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startAt?: SortOrder
    endAt?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type CommunityEventWhereUniqueInput = {
    id?: string
  }

  export type CommunityEventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startAt?: SortOrder
    endAt?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CommunityEventCountOrderByAggregateInput
    _max?: CommunityEventMaxOrderByAggregateInput
    _min?: CommunityEventMinOrderByAggregateInput
  }

  export type CommunityEventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommunityEventScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommunityEventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommunityEventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    startAt?: DateTimeWithAggregatesFilter | Date | string
    endAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    location?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SocialPostWhereInput = {
    AND?: Enumerable<SocialPostWhereInput>
    OR?: Enumerable<SocialPostWhereInput>
    NOT?: Enumerable<SocialPostWhereInput>
    id?: StringFilter | string
    authorId?: StringFilter | string
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    comments?: PostCommentListRelationFilter
  }

  export type SocialPostOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    comments?: PostCommentOrderByRelationAggregateInput
  }

  export type SocialPostWhereUniqueInput = {
    id?: string
  }

  export type SocialPostOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocialPostCountOrderByAggregateInput
    _max?: SocialPostMaxOrderByAggregateInput
    _min?: SocialPostMinOrderByAggregateInput
  }

  export type SocialPostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SocialPostScalarWhereWithAggregatesInput>
    OR?: Enumerable<SocialPostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SocialPostScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    authorId?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PostCommentWhereInput = {
    AND?: Enumerable<PostCommentWhereInput>
    OR?: Enumerable<PostCommentWhereInput>
    NOT?: Enumerable<PostCommentWhereInput>
    id?: StringFilter | string
    postId?: StringFilter | string
    authorId?: StringFilter | string
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    post?: XOR<SocialPostRelationFilter, SocialPostWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PostCommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    post?: SocialPostOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type PostCommentWhereUniqueInput = {
    id?: string
  }

  export type PostCommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: PostCommentCountOrderByAggregateInput
    _max?: PostCommentMaxOrderByAggregateInput
    _min?: PostCommentMinOrderByAggregateInput
  }

  export type PostCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostCommentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    postId?: StringWithAggregatesFilter | string
    authorId?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EventWhereInput = {
    AND?: Enumerable<EventWhereInput>
    OR?: Enumerable<EventWhereInput>
    NOT?: Enumerable<EventWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    date?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    registrations?: EventRegistrationListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    registrations?: EventRegistrationOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = {
    id?: string
  }

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EventScalarWhereWithAggregatesInput>
    OR?: Enumerable<EventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EventScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    date?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EventRegistrationWhereInput = {
    AND?: Enumerable<EventRegistrationWhereInput>
    OR?: Enumerable<EventRegistrationWhereInput>
    NOT?: Enumerable<EventRegistrationWhereInput>
    id?: StringFilter | string
    eventId?: StringFilter | string
    userId?: StringFilter | string
    registeredAt?: DateTimeFilter | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EventRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    registeredAt?: SortOrder
    event?: EventOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type EventRegistrationWhereUniqueInput = {
    id?: string
  }

  export type EventRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    registeredAt?: SortOrder
    _count?: EventRegistrationCountOrderByAggregateInput
    _max?: EventRegistrationMaxOrderByAggregateInput
    _min?: EventRegistrationMinOrderByAggregateInput
  }

  export type EventRegistrationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EventRegistrationScalarWhereWithAggregatesInput>
    OR?: Enumerable<EventRegistrationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EventRegistrationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    eventId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    registeredAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ForumThreadWhereInput = {
    AND?: Enumerable<ForumThreadWhereInput>
    OR?: Enumerable<ForumThreadWhereInput>
    NOT?: Enumerable<ForumThreadWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    authorId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    posts?: ForumPostListRelationFilter
  }

  export type ForumThreadOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    posts?: ForumPostOrderByRelationAggregateInput
  }

  export type ForumThreadWhereUniqueInput = {
    id?: string
  }

  export type ForumThreadOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumThreadCountOrderByAggregateInput
    _max?: ForumThreadMaxOrderByAggregateInput
    _min?: ForumThreadMinOrderByAggregateInput
  }

  export type ForumThreadScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ForumThreadScalarWhereWithAggregatesInput>
    OR?: Enumerable<ForumThreadScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ForumThreadScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    authorId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ForumPostWhereInput = {
    AND?: Enumerable<ForumPostWhereInput>
    OR?: Enumerable<ForumPostWhereInput>
    NOT?: Enumerable<ForumPostWhereInput>
    id?: StringFilter | string
    threadId?: StringFilter | string
    authorId?: StringFilter | string
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    thread?: XOR<ForumThreadRelationFilter, ForumThreadWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ForumPostOrderByWithRelationInput = {
    id?: SortOrder
    threadId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    thread?: ForumThreadOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type ForumPostWhereUniqueInput = {
    id?: string
  }

  export type ForumPostOrderByWithAggregationInput = {
    id?: SortOrder
    threadId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: ForumPostCountOrderByAggregateInput
    _max?: ForumPostMaxOrderByAggregateInput
    _min?: ForumPostMinOrderByAggregateInput
  }

  export type ForumPostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ForumPostScalarWhereWithAggregatesInput>
    OR?: Enumerable<ForumPostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ForumPostScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    threadId?: StringWithAggregatesFilter | string
    authorId?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BenefitClaimWhereInput = {
    AND?: Enumerable<BenefitClaimWhereInput>
    OR?: Enumerable<BenefitClaimWhereInput>
    NOT?: Enumerable<BenefitClaimWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    status?: StringFilter | string
    amount?: FloatNullableFilter | number | null
    requestedAt?: DateTimeFilter | Date | string
    processedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BenefitClaimOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BenefitClaimWhereUniqueInput = {
    id?: string
  }

  export type BenefitClaimOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    _count?: BenefitClaimCountOrderByAggregateInput
    _avg?: BenefitClaimAvgOrderByAggregateInput
    _max?: BenefitClaimMaxOrderByAggregateInput
    _min?: BenefitClaimMinOrderByAggregateInput
    _sum?: BenefitClaimSumOrderByAggregateInput
  }

  export type BenefitClaimScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BenefitClaimScalarWhereWithAggregatesInput>
    OR?: Enumerable<BenefitClaimScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BenefitClaimScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
    amount?: FloatNullableWithAggregatesFilter | number | null
    requestedAt?: DateTimeWithAggregatesFilter | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type PayrollRecordWhereInput = {
    AND?: Enumerable<PayrollRecordWhereInput>
    OR?: Enumerable<PayrollRecordWhereInput>
    NOT?: Enumerable<PayrollRecordWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    salary?: FloatFilter | number
    periodStart?: DateTimeFilter | Date | string
    periodEnd?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PayrollRecordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    salary?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PayrollRecordWhereUniqueInput = {
    id?: string
  }

  export type PayrollRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    salary?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayrollRecordCountOrderByAggregateInput
    _avg?: PayrollRecordAvgOrderByAggregateInput
    _max?: PayrollRecordMaxOrderByAggregateInput
    _min?: PayrollRecordMinOrderByAggregateInput
    _sum?: PayrollRecordSumOrderByAggregateInput
  }

  export type PayrollRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PayrollRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<PayrollRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PayrollRecordScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    salary?: FloatWithAggregatesFilter | number
    periodStart?: DateTimeWithAggregatesFilter | Date | string
    periodEnd?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BookingWhereInput = {
    AND?: Enumerable<BookingWhereInput>
    OR?: Enumerable<BookingWhereInput>
    NOT?: Enumerable<BookingWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    serviceId?: StringFilter | string
    appointmentDate?: DateTimeFilter | Date | string
    duration?: IntFilter | number
    specialRequests?: StringNullableFilter | string | null
    status?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    googleEventId?: StringNullableFilter | string | null
    outlookEventId?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    appointmentDate?: SortOrder
    duration?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    googleEventId?: SortOrderInput | SortOrder
    outlookEventId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = {
    id?: string
  }

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    appointmentDate?: SortOrder
    duration?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    googleEventId?: SortOrderInput | SortOrder
    outlookEventId?: SortOrderInput | SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BookingScalarWhereWithAggregatesInput>
    OR?: Enumerable<BookingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BookingScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    serviceId?: StringWithAggregatesFilter | string
    appointmentDate?: DateTimeWithAggregatesFilter | Date | string
    duration?: IntWithAggregatesFilter | number
    specialRequests?: StringNullableWithAggregatesFilter | string | null
    status?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    googleEventId?: StringNullableWithAggregatesFilter | string | null
    outlookEventId?: StringNullableWithAggregatesFilter | string | null
  }

  export type TwoFactorAuthWhereInput = {
    AND?: Enumerable<TwoFactorAuthWhereInput>
    OR?: Enumerable<TwoFactorAuthWhereInput>
    NOT?: Enumerable<TwoFactorAuthWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    secret?: StringFilter | string
    verified?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TwoFactorAuthOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    secret?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TwoFactorAuthWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type TwoFactorAuthOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    secret?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwoFactorAuthCountOrderByAggregateInput
    _max?: TwoFactorAuthMaxOrderByAggregateInput
    _min?: TwoFactorAuthMinOrderByAggregateInput
  }

  export type TwoFactorAuthScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TwoFactorAuthScalarWhereWithAggregatesInput>
    OR?: Enumerable<TwoFactorAuthScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TwoFactorAuthScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    secret?: StringWithAggregatesFilter | string
    verified?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type WebAuthnCredentialWhereInput = {
    AND?: Enumerable<WebAuthnCredentialWhereInput>
    OR?: Enumerable<WebAuthnCredentialWhereInput>
    NOT?: Enumerable<WebAuthnCredentialWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    credentialId?: StringFilter | string
    publicKey?: StringFilter | string
    counter?: IntFilter | number
    transports?: StringNullableListFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WebAuthnCredentialOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    transports?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WebAuthnCredentialWhereUniqueInput = {
    id?: string
    credentialId?: string
  }

  export type WebAuthnCredentialOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    transports?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebAuthnCredentialCountOrderByAggregateInput
    _avg?: WebAuthnCredentialAvgOrderByAggregateInput
    _max?: WebAuthnCredentialMaxOrderByAggregateInput
    _min?: WebAuthnCredentialMinOrderByAggregateInput
    _sum?: WebAuthnCredentialSumOrderByAggregateInput
  }

  export type WebAuthnCredentialScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WebAuthnCredentialScalarWhereWithAggregatesInput>
    OR?: Enumerable<WebAuthnCredentialScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WebAuthnCredentialScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    credentialId?: StringWithAggregatesFilter | string
    publicKey?: StringWithAggregatesFilter | string
    counter?: IntWithAggregatesFilter | number
    transports?: StringNullableListFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserCreateInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProviderCreateInput = {
    id?: string
    name: string
    description?: string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutProviderInput
    businesses?: BusinessCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutProviderNestedInput
    businesses?: BusinessUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutServiceInput
    bookings?: BookingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    providerId: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutServiceInput
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutServiceNestedInput
    bookings?: BookingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutServiceNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    providerId: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessCreateInput = {
    id?: string
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutBusinessesInput
    hours?: BusinessHourCreateNestedManyWithoutBusinessInput
    staff?: StaffCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateInput = {
    id?: string
    providerId: string
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hours?: BusinessHourUncheckedCreateNestedManyWithoutBusinessInput
    staff?: StaffUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutBusinessesNestedInput
    hours?: BusinessHourUpdateManyWithoutBusinessNestedInput
    staff?: StaffUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: BusinessHourUncheckedUpdateManyWithoutBusinessNestedInput
    staff?: StaffUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateManyInput = {
    id?: string
    providerId: string
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessHourCreateInput = {
    id?: string
    dayOfWeek: number
    openTime: string
    closeTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutHoursInput
  }

  export type BusinessHourUncheckedCreateInput = {
    id?: string
    businessId: string
    dayOfWeek: number
    openTime: string
    closeTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessHourUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutHoursNestedInput
  }

  export type BusinessHourUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessHourCreateManyInput = {
    id?: string
    businessId: string
    dayOfWeek: number
    openTime: string
    closeTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessHourUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessHourUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateInput = {
    id?: string
    name: string
    role: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutStaffInput
    schedules?: StaffScheduleCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateInput = {
    id?: string
    businessId: string
    name: string
    role: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: StaffScheduleUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutStaffNestedInput
    schedules?: StaffScheduleUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: StaffScheduleUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type StaffCreateManyInput = {
    id?: string
    businessId: string
    name: string
    role: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffScheduleCreateInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffCreateNestedOneWithoutSchedulesInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutScheduleInput
  }

  export type StaffScheduleUncheckedCreateInput = {
    id?: string
    staffId: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type StaffScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutSchedulesNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutScheduleNestedInput
  }

  export type StaffScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type StaffScheduleCreateManyInput = {
    id?: string
    staffId: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordCreateInput = {
    id?: string
    status: string
    timestamp?: Date | string
    schedule: StaffScheduleCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type AttendanceRecordUncheckedCreateInput = {
    id?: string
    scheduleId: string
    status: string
    timestamp?: Date | string
  }

  export type AttendanceRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: StaffScheduleUpdateOneRequiredWithoutAttendanceRecordsNestedInput
  }

  export type AttendanceRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordCreateManyInput = {
    id?: string
    scheduleId: string
    status: string
    timestamp?: Date | string
  }

  export type AttendanceRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingModuleCreateInput = {
    id?: string
    title: string
    description?: string | null
    contentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingProgress?: TrainingProgressCreateNestedManyWithoutModuleInput
  }

  export type TrainingModuleUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    contentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutModuleInput
  }

  export type TrainingModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingProgress?: TrainingProgressUpdateManyWithoutModuleNestedInput
  }

  export type TrainingModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type TrainingModuleCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    contentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingProgressCreateInput = {
    id?: string
    completedAt?: Date | string
    user: UserCreateNestedOneWithoutTrainingProgressInput
    module: TrainingModuleCreateNestedOneWithoutTrainingProgressInput
  }

  export type TrainingProgressUncheckedCreateInput = {
    id?: string
    userId: string
    moduleId: string
    completedAt?: Date | string
  }

  export type TrainingProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrainingProgressNestedInput
    module?: TrainingModuleUpdateOneRequiredWithoutTrainingProgressNestedInput
  }

  export type TrainingProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingProgressCreateManyInput = {
    id?: string
    userId: string
    moduleId: string
    completedAt?: Date | string
  }

  export type TrainingProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTierCreateInput = {
    id?: string
    name: string
    requiredPoints: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutTierInput
  }

  export type LoyaltyTierUncheckedCreateInput = {
    id?: string
    name: string
    requiredPoints: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutTierInput
  }

  export type LoyaltyTierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    requiredPoints?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: LoyaltyTransactionUpdateManyWithoutTierNestedInput
  }

  export type LoyaltyTierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    requiredPoints?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutTierNestedInput
  }

  export type LoyaltyTierCreateManyInput = {
    id?: string
    name: string
    requiredPoints: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyTierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    requiredPoints?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    requiredPoints?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionCreateInput = {
    id?: string
    points: number
    type: TransactionType
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    tier?: LoyaltyTierCreateNestedOneWithoutTransactionsInput
  }

  export type LoyaltyTransactionUncheckedCreateInput = {
    id?: string
    userId: string
    tierId?: string | null
    points: number
    type: TransactionType
    createdAt?: Date | string
  }

  export type LoyaltyTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    tier?: LoyaltyTierUpdateOneWithoutTransactionsNestedInput
  }

  export type LoyaltyTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tierId?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionCreateManyInput = {
    id?: string
    userId: string
    tierId?: string | null
    points: number
    type: TransactionType
    createdAt?: Date | string
  }

  export type LoyaltyTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tierId?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    stripeSubscriptionId: string
    priceId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    stripeSubscriptionId: string
    priceId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    priceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    priceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    stripeSubscriptionId: string
    priceId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    priceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    priceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventCreateInput = {
    id?: string
    event: string
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAnalyticsEventsInput
  }

  export type AnalyticsEventUncheckedCreateInput = {
    id?: string
    userId?: string | null
    event: string
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAnalyticsEventsNestedInput
  }

  export type AnalyticsEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    event?: StringFieldUpdateOperationsInput | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventCreateManyInput = {
    id?: string
    userId?: string | null
    event: string
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    event?: StringFieldUpdateOperationsInput | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionCreateInput = {
    id?: string
    amount: number
    currency: string
    mode: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentTransactionsInput
    service?: ServiceCreateNestedOneWithoutPaymentTransactionsInput
  }

  export type PaymentTransactionUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    mode: string
    createdAt?: Date | string
    serviceId?: string | null
  }

  export type PaymentTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentTransactionsNestedInput
    service?: ServiceUpdateOneWithoutPaymentTransactionsNestedInput
  }

  export type PaymentTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentTransactionCreateManyInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    mode: string
    createdAt?: Date | string
    serviceId?: string | null
  }

  export type PaymentTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromotionCodeCreateInput = {
    id?: string
    code: string
    description?: string | null
    discount: number
    validFrom: Date | string
    validTo: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionCodeUncheckedCreateInput = {
    id?: string
    code: string
    description?: string | null
    discount: number
    validFrom: Date | string
    validTo: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: FloatFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: FloatFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCodeCreateManyInput = {
    id?: string
    code: string
    description?: string | null
    discount: number
    validFrom: Date | string
    validTo: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: FloatFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: FloatFieldUpdateOperationsInput | number
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailCampaignCreateInput = {
    id?: string
    name: string
    subject: string
    body: string
    scheduledAt?: Date | string | null
    sent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailCampaignUncheckedCreateInput = {
    id?: string
    name: string
    subject: string
    body: string
    scheduledAt?: Date | string | null
    sent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailCampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailCampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailCampaignCreateManyInput = {
    id?: string
    name: string
    subject: string
    body: string
    scheduledAt?: Date | string | null
    sent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailCampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailCampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoogleCalendarTokenCreateInput = {
    id?: string
    accessToken: string
    refreshToken: string
    scope?: string | null
    tokenType?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGoogleCalendarTokenInput
  }

  export type GoogleCalendarTokenUncheckedCreateInput = {
    id?: string
    userId: string
    accessToken: string
    refreshToken: string
    scope?: string | null
    tokenType?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoogleCalendarTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGoogleCalendarTokenNestedInput
  }

  export type GoogleCalendarTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoogleCalendarTokenCreateManyInput = {
    id?: string
    userId: string
    accessToken: string
    refreshToken: string
    scope?: string | null
    tokenType?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoogleCalendarTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoogleCalendarTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutlookCalendarTokenCreateInput = {
    id?: string
    accessToken: string
    refreshToken: string
    scope?: string | null
    tokenType?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOutlookCalendarTokenInput
  }

  export type OutlookCalendarTokenUncheckedCreateInput = {
    id?: string
    userId: string
    accessToken: string
    refreshToken: string
    scope?: string | null
    tokenType?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutlookCalendarTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOutlookCalendarTokenNestedInput
  }

  export type OutlookCalendarTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutlookCalendarTokenCreateManyInput = {
    id?: string
    userId: string
    accessToken: string
    refreshToken: string
    scope?: string | null
    tokenType?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutlookCalendarTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutlookCalendarTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormDefinitionCreateInput = {
    id?: string
    name: string
    fields: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: FormSubmissionCreateNestedManyWithoutDefinitionInput
  }

  export type FormDefinitionUncheckedCreateInput = {
    id?: string
    name: string
    fields: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: FormSubmissionUncheckedCreateNestedManyWithoutDefinitionInput
  }

  export type FormDefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: FormSubmissionUpdateManyWithoutDefinitionNestedInput
  }

  export type FormDefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: FormSubmissionUncheckedUpdateManyWithoutDefinitionNestedInput
  }

  export type FormDefinitionCreateManyInput = {
    id?: string
    name: string
    fields: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormDefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormDefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    submittedAt?: Date | string
    definition: FormDefinitionCreateNestedOneWithoutSubmissionsInput
    documents?: DocumentCreateNestedManyWithoutSubmissionInput
  }

  export type FormSubmissionUncheckedCreateInput = {
    id?: string
    definitionId: string
    data: JsonNullValueInput | InputJsonValue
    submittedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type FormSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    definition?: FormDefinitionUpdateOneRequiredWithoutSubmissionsNestedInput
    documents?: DocumentUpdateManyWithoutSubmissionNestedInput
  }

  export type FormSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    definitionId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type FormSubmissionCreateManyInput = {
    id?: string
    definitionId: string
    data: JsonNullValueInput | InputJsonValue
    submittedAt?: Date | string
  }

  export type FormSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    definitionId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    url: string
    type: string
    createdAt?: Date | string
    submission?: FormSubmissionCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    url: string
    type: string
    submissionId?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submission?: FormSubmissionUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    url: string
    type: string
    submissionId?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentItemCreateInput = {
    id?: string
    name: string
    description?: string | null
    serialNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: EquipmentAssignmentCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentItemUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    serialNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: EquipmentAssignmentUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentItemCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    serialNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentAssignmentCreateInput = {
    id?: string
    assignedAt?: Date | string
    returnedAt?: Date | string | null
    equipment: EquipmentItemCreateNestedOneWithoutAssignmentsInput
    assignedToUser: UserCreateNestedOneWithoutAssignmentsInput
  }

  export type EquipmentAssignmentUncheckedCreateInput = {
    id?: string
    equipmentId: string
    assignedTo: string
    assignedAt?: Date | string
    returnedAt?: Date | string | null
  }

  export type EquipmentAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: EquipmentItemUpdateOneRequiredWithoutAssignmentsNestedInput
    assignedToUser?: UserUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type EquipmentAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EquipmentAssignmentCreateManyInput = {
    id?: string
    equipmentId: string
    assignedTo: string
    assignedAt?: Date | string
    returnedAt?: Date | string | null
  }

  export type EquipmentAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EquipmentAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityEventCreateInput = {
    id?: string
    title: string
    description?: string | null
    startAt: Date | string
    endAt?: Date | string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type CommunityEventUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    startAt: Date | string
    endAt?: Date | string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type CommunityEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityEventCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    startAt: Date | string
    endAt?: Date | string | null
    location?: string | null
    createdAt?: Date | string
  }

  export type CommunityEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialPostCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutSocialPostsInput
    comments?: PostCommentCreateNestedManyWithoutPostInput
  }

  export type SocialPostUncheckedCreateInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: PostCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type SocialPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutSocialPostsNestedInput
    comments?: PostCommentUpdateManyWithoutPostNestedInput
  }

  export type SocialPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: PostCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type SocialPostCreateManyInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    post: SocialPostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutPostCommentsInput
  }

  export type PostCommentUncheckedCreateInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type PostCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: SocialPostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutPostCommentsNestedInput
  }

  export type PostCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCommentCreateManyInput = {
    id?: string
    postId: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type PostCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: EventRegistrationCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: EventRegistrationUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationCreateInput = {
    id?: string
    registeredAt?: Date | string
    event: EventCreateNestedOneWithoutRegistrationsInput
    user: UserCreateNestedOneWithoutEventRegistrationsInput
  }

  export type EventRegistrationUncheckedCreateInput = {
    id?: string
    eventId: string
    userId: string
    registeredAt?: Date | string
  }

  export type EventRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutRegistrationsNestedInput
    user?: UserUpdateOneRequiredWithoutEventRegistrationsNestedInput
  }

  export type EventRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationCreateManyInput = {
    id?: string
    eventId: string
    userId: string
    registeredAt?: Date | string
  }

  export type EventRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumThreadCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutForumThreadsInput
    posts?: ForumPostCreateNestedManyWithoutThreadInput
  }

  export type ForumThreadUncheckedCreateInput = {
    id?: string
    title: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: ForumPostUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ForumThreadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutForumThreadsNestedInput
    posts?: ForumPostUpdateManyWithoutThreadNestedInput
  }

  export type ForumThreadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: ForumPostUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ForumThreadCreateManyInput = {
    id?: string
    title: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumThreadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumThreadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    thread: ForumThreadCreateNestedOneWithoutPostsInput
    author: UserCreateNestedOneWithoutForumPostsInput
  }

  export type ForumPostUncheckedCreateInput = {
    id?: string
    threadId: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type ForumPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: ForumThreadUpdateOneRequiredWithoutPostsNestedInput
    author?: UserUpdateOneRequiredWithoutForumPostsNestedInput
  }

  export type ForumPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostCreateManyInput = {
    id?: string
    threadId: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type ForumPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BenefitClaimCreateInput = {
    id?: string
    type: string
    status: string
    amount?: number | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
    user: UserCreateNestedOneWithoutBenefitClaimsInput
  }

  export type BenefitClaimUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    status: string
    amount?: number | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type BenefitClaimUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBenefitClaimsNestedInput
  }

  export type BenefitClaimUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BenefitClaimCreateManyInput = {
    id?: string
    userId: string
    type: string
    status: string
    amount?: number | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type BenefitClaimUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BenefitClaimUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayrollRecordCreateInput = {
    id?: string
    salary: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPayrollRecordsInput
  }

  export type PayrollRecordUncheckedCreateInput = {
    id?: string
    userId: string
    salary: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    salary?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPayrollRecordsNestedInput
  }

  export type PayrollRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    salary?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollRecordCreateManyInput = {
    id?: string
    userId: string
    salary: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    salary?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    salary?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    appointmentDate: Date | string
    duration: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    googleEventId?: string | null
    outlookEventId?: string | null
    user: UserCreateNestedOneWithoutBookingsInput
    service: ServiceCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    userId: string
    serviceId: string
    appointmentDate: Date | string
    duration: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    googleEventId?: string | null
    outlookEventId?: string | null
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingCreateManyInput = {
    id?: string
    userId: string
    serviceId: string
    appointmentDate: Date | string
    duration: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    googleEventId?: string | null
    outlookEventId?: string | null
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TwoFactorAuthCreateInput = {
    id?: string
    secret: string
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTwoFactorAuthInput
  }

  export type TwoFactorAuthUncheckedCreateInput = {
    id?: string
    userId: string
    secret: string
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAuthUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTwoFactorAuthNestedInput
  }

  export type TwoFactorAuthUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAuthCreateManyInput = {
    id?: string
    userId: string
    secret: string
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAuthUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAuthUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebAuthnCredentialCreateInput = {
    id?: string
    credentialId: string
    publicKey: string
    counter: number
    transports?: WebAuthnCredentialCreatetransportsInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWebAuthnCredentialsInput
  }

  export type WebAuthnCredentialUncheckedCreateInput = {
    id?: string
    userId: string
    credentialId: string
    publicKey: string
    counter: number
    transports?: WebAuthnCredentialCreatetransportsInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebAuthnCredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: WebAuthnCredentialUpdatetransportsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWebAuthnCredentialsNestedInput
  }

  export type WebAuthnCredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: WebAuthnCredentialUpdatetransportsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebAuthnCredentialCreateManyInput = {
    id?: string
    userId: string
    credentialId: string
    publicKey: string
    counter: number
    transports?: WebAuthnCredentialCreatetransportsInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebAuthnCredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: WebAuthnCredentialUpdatetransportsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebAuthnCredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: WebAuthnCredentialUpdatetransportsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type EnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type LoyaltyTransactionListRelationFilter = {
    every?: LoyaltyTransactionWhereInput
    some?: LoyaltyTransactionWhereInput
    none?: LoyaltyTransactionWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type AnalyticsEventListRelationFilter = {
    every?: AnalyticsEventWhereInput
    some?: AnalyticsEventWhereInput
    none?: AnalyticsEventWhereInput
  }

  export type PaymentTransactionListRelationFilter = {
    every?: PaymentTransactionWhereInput
    some?: PaymentTransactionWhereInput
    none?: PaymentTransactionWhereInput
  }

  export type TrainingProgressListRelationFilter = {
    every?: TrainingProgressWhereInput
    some?: TrainingProgressWhereInput
    none?: TrainingProgressWhereInput
  }

  export type GoogleCalendarTokenRelationFilter = {
    is?: GoogleCalendarTokenWhereInput | null
    isNot?: GoogleCalendarTokenWhereInput | null
  }

  export type OutlookCalendarTokenRelationFilter = {
    is?: OutlookCalendarTokenWhereInput | null
    isNot?: OutlookCalendarTokenWhereInput | null
  }

  export type EquipmentAssignmentListRelationFilter = {
    every?: EquipmentAssignmentWhereInput
    some?: EquipmentAssignmentWhereInput
    none?: EquipmentAssignmentWhereInput
  }

  export type SocialPostListRelationFilter = {
    every?: SocialPostWhereInput
    some?: SocialPostWhereInput
    none?: SocialPostWhereInput
  }

  export type PostCommentListRelationFilter = {
    every?: PostCommentWhereInput
    some?: PostCommentWhereInput
    none?: PostCommentWhereInput
  }

  export type EventRegistrationListRelationFilter = {
    every?: EventRegistrationWhereInput
    some?: EventRegistrationWhereInput
    none?: EventRegistrationWhereInput
  }

  export type ForumThreadListRelationFilter = {
    every?: ForumThreadWhereInput
    some?: ForumThreadWhereInput
    none?: ForumThreadWhereInput
  }

  export type ForumPostListRelationFilter = {
    every?: ForumPostWhereInput
    some?: ForumPostWhereInput
    none?: ForumPostWhereInput
  }

  export type BenefitClaimListRelationFilter = {
    every?: BenefitClaimWhereInput
    some?: BenefitClaimWhereInput
    none?: BenefitClaimWhereInput
  }

  export type PayrollRecordListRelationFilter = {
    every?: PayrollRecordWhereInput
    some?: PayrollRecordWhereInput
    none?: PayrollRecordWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type TwoFactorAuthRelationFilter = {
    is?: TwoFactorAuthWhereInput | null
    isNot?: TwoFactorAuthWhereInput | null
  }

  export type WebAuthnCredentialListRelationFilter = {
    every?: WebAuthnCredentialWhereInput
    some?: WebAuthnCredentialWhereInput
    none?: WebAuthnCredentialWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LoyaltyTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalyticsEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocialPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumThreadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BenefitClaimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebAuthnCredentialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pushTokens?: SortOrder
    notificationSettings?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type BusinessListRelationFilter = {
    every?: BusinessWhereInput
    some?: BusinessWhereInput
    none?: BusinessWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    businessName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    businessName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    businessName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type ProviderRelationFilter = {
    is?: ProviderWhereInput | null
    isNot?: ProviderWhereInput | null
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type BusinessHourListRelationFilter = {
    every?: BusinessHourWhereInput
    some?: BusinessHourWhereInput
    none?: BusinessHourWhereInput
  }

  export type StaffListRelationFilter = {
    every?: StaffWhereInput
    some?: StaffWhereInput
    none?: StaffWhereInput
  }

  export type BusinessHourOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessRelationFilter = {
    is?: BusinessWhereInput | null
    isNot?: BusinessWhereInput | null
  }

  export type BusinessHourCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessHourAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type BusinessHourMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessHourMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessHourSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type StaffScheduleListRelationFilter = {
    every?: StaffScheduleWhereInput
    some?: StaffScheduleWhereInput
    none?: StaffScheduleWhereInput
  }

  export type StaffScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffRelationFilter = {
    is?: StaffWhereInput | null
    isNot?: StaffWhereInput | null
  }

  export type AttendanceRecordListRelationFilter = {
    every?: AttendanceRecordWhereInput
    some?: AttendanceRecordWhereInput
    none?: AttendanceRecordWhereInput
  }

  export type AttendanceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffScheduleRelationFilter = {
    is?: StaffScheduleWhereInput | null
    isNot?: StaffScheduleWhereInput | null
  }

  export type AttendanceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
  }

  export type AttendanceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
  }

  export type AttendanceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
  }

  export type TrainingModuleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    contentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    contentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingModuleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    contentUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingModuleRelationFilter = {
    is?: TrainingModuleWhereInput | null
    isNot?: TrainingModuleWhereInput | null
  }

  export type TrainingProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    moduleId?: SortOrder
    completedAt?: SortOrder
  }

  export type TrainingProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    moduleId?: SortOrder
    completedAt?: SortOrder
  }

  export type TrainingProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    moduleId?: SortOrder
    completedAt?: SortOrder
  }

  export type LoyaltyTierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    requiredPoints?: SortOrder
    discount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyTierAvgOrderByAggregateInput = {
    requiredPoints?: SortOrder
    discount?: SortOrder
  }

  export type LoyaltyTierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    requiredPoints?: SortOrder
    discount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyTierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    requiredPoints?: SortOrder
    discount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyTierSumOrderByAggregateInput = {
    requiredPoints?: SortOrder
    discount?: SortOrder
  }

  export type EnumTransactionTypeFilter = {
    equals?: TransactionType
    in?: Enumerable<TransactionType>
    notIn?: Enumerable<TransactionType>
    not?: NestedEnumTransactionTypeFilter | TransactionType
  }

  export type LoyaltyTierRelationFilter = {
    is?: LoyaltyTierWhereInput | null
    isNot?: LoyaltyTierWhereInput | null
  }

  export type LoyaltyTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tierId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type LoyaltyTransactionAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type LoyaltyTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tierId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type LoyaltyTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tierId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type LoyaltyTransactionSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter = {
    equals?: TransactionType
    in?: Enumerable<TransactionType>
    notIn?: Enumerable<TransactionType>
    not?: NestedEnumTransactionTypeWithAggregatesFilter | TransactionType
    _count?: NestedIntFilter
    _min?: NestedEnumTransactionTypeFilter
    _max?: NestedEnumTransactionTypeFilter
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeSubscriptionId?: SortOrder
    priceId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeSubscriptionId?: SortOrder
    priceId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeSubscriptionId?: SortOrder
    priceId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type AnalyticsEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    event?: SortOrder
    properties?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    event?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    event?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type PaymentTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    mode?: SortOrder
    createdAt?: SortOrder
    serviceId?: SortOrder
  }

  export type PaymentTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    mode?: SortOrder
    createdAt?: SortOrder
    serviceId?: SortOrder
  }

  export type PaymentTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    mode?: SortOrder
    createdAt?: SortOrder
    serviceId?: SortOrder
  }

  export type PaymentTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PromotionCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionCodeAvgOrderByAggregateInput = {
    discount?: SortOrder
  }

  export type PromotionCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionCodeSumOrderByAggregateInput = {
    discount?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type EmailCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    scheduledAt?: SortOrder
    sent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    scheduledAt?: SortOrder
    sent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    scheduledAt?: SortOrder
    sent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoogleCalendarTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    scope?: SortOrder
    tokenType?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoogleCalendarTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    scope?: SortOrder
    tokenType?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoogleCalendarTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    scope?: SortOrder
    tokenType?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutlookCalendarTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    scope?: SortOrder
    tokenType?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutlookCalendarTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    scope?: SortOrder
    tokenType?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutlookCalendarTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    scope?: SortOrder
    tokenType?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormSubmissionListRelationFilter = {
    every?: FormSubmissionWhereInput
    some?: FormSubmissionWhereInput
    none?: FormSubmissionWhereInput
  }

  export type FormSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormDefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormDefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormDefinitionRelationFilter = {
    is?: FormDefinitionWhereInput | null
    isNot?: FormDefinitionWhereInput | null
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    definitionId?: SortOrder
    data?: SortOrder
    submittedAt?: SortOrder
  }

  export type FormSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    definitionId?: SortOrder
    submittedAt?: SortOrder
  }

  export type FormSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    definitionId?: SortOrder
    submittedAt?: SortOrder
  }

  export type FormSubmissionRelationFilter = {
    is?: FormSubmissionWhereInput | null
    isNot?: FormSubmissionWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    submissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    submissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    submissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EquipmentItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    serialNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    serialNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    serialNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentItemRelationFilter = {
    is?: EquipmentItemWhereInput | null
    isNot?: EquipmentItemWhereInput | null
  }

  export type EquipmentAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    assignedTo?: SortOrder
    assignedAt?: SortOrder
    returnedAt?: SortOrder
  }

  export type EquipmentAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    assignedTo?: SortOrder
    assignedAt?: SortOrder
    returnedAt?: SortOrder
  }

  export type EquipmentAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    assignedTo?: SortOrder
    assignedAt?: SortOrder
    returnedAt?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type PostRelationFilter = {
    is?: PostWhereInput | null
    isNot?: PostWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityEventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityEventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityEventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
  }

  export type SocialPostCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialPostMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialPostMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialPostRelationFilter = {
    is?: SocialPostWhereInput | null
    isNot?: SocialPostWhereInput | null
  }

  export type PostCommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type PostCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type PostCommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventRelationFilter = {
    is?: EventWhereInput | null
    isNot?: EventWhereInput | null
  }

  export type EventRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    registeredAt?: SortOrder
  }

  export type EventRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    registeredAt?: SortOrder
  }

  export type EventRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    registeredAt?: SortOrder
  }

  export type ForumThreadCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumThreadMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumThreadRelationFilter = {
    is?: ForumThreadWhereInput | null
    isNot?: ForumThreadWhereInput | null
  }

  export type ForumPostCountOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ForumPostMaxOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ForumPostMinOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type BenefitClaimCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
  }

  export type BenefitClaimAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BenefitClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
  }

  export type BenefitClaimMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    requestedAt?: SortOrder
    processedAt?: SortOrder
  }

  export type BenefitClaimSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type PayrollRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    salary?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollRecordAvgOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type PayrollRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    salary?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    salary?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollRecordSumOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    appointmentDate?: SortOrder
    duration?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    googleEventId?: SortOrder
    outlookEventId?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    appointmentDate?: SortOrder
    duration?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    googleEventId?: SortOrder
    outlookEventId?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    appointmentDate?: SortOrder
    duration?: SortOrder
    specialRequests?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    googleEventId?: SortOrder
    outlookEventId?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type TwoFactorAuthCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    secret?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwoFactorAuthMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    secret?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwoFactorAuthMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    secret?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type WebAuthnCredentialCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    transports?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebAuthnCredentialAvgOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type WebAuthnCredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebAuthnCredentialMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebAuthnCredentialSumOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type LoyaltyTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LoyaltyTransactionCreateWithoutUserInput>, Enumerable<LoyaltyTransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoyaltyTransactionCreateOrConnectWithoutUserInput>
    createMany?: LoyaltyTransactionCreateManyUserInputEnvelope
    connect?: Enumerable<LoyaltyTransactionWhereUniqueInput>
  }

  export type SubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutUserInput>, Enumerable<SubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutUserInput>
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutReferredByInput = {
    create?: XOR<Enumerable<UserCreateWithoutReferredByInput>, Enumerable<UserUncheckedCreateWithoutReferredByInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutReferredByInput>
    createMany?: UserCreateManyReferredByInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type AnalyticsEventCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AnalyticsEventCreateWithoutUserInput>, Enumerable<AnalyticsEventUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AnalyticsEventCreateOrConnectWithoutUserInput>
    createMany?: AnalyticsEventCreateManyUserInputEnvelope
    connect?: Enumerable<AnalyticsEventWhereUniqueInput>
  }

  export type PaymentTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PaymentTransactionCreateWithoutUserInput>, Enumerable<PaymentTransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PaymentTransactionCreateOrConnectWithoutUserInput>
    createMany?: PaymentTransactionCreateManyUserInputEnvelope
    connect?: Enumerable<PaymentTransactionWhereUniqueInput>
  }

  export type TrainingProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TrainingProgressCreateWithoutUserInput>, Enumerable<TrainingProgressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TrainingProgressCreateOrConnectWithoutUserInput>
    createMany?: TrainingProgressCreateManyUserInputEnvelope
    connect?: Enumerable<TrainingProgressWhereUniqueInput>
  }

  export type GoogleCalendarTokenCreateNestedOneWithoutUserInput = {
    create?: XOR<GoogleCalendarTokenCreateWithoutUserInput, GoogleCalendarTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleCalendarTokenCreateOrConnectWithoutUserInput
    connect?: GoogleCalendarTokenWhereUniqueInput
  }

  export type OutlookCalendarTokenCreateNestedOneWithoutUserInput = {
    create?: XOR<OutlookCalendarTokenCreateWithoutUserInput, OutlookCalendarTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: OutlookCalendarTokenCreateOrConnectWithoutUserInput
    connect?: OutlookCalendarTokenWhereUniqueInput
  }

  export type EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput = {
    create?: XOR<Enumerable<EquipmentAssignmentCreateWithoutAssignedToUserInput>, Enumerable<EquipmentAssignmentUncheckedCreateWithoutAssignedToUserInput>>
    connectOrCreate?: Enumerable<EquipmentAssignmentCreateOrConnectWithoutAssignedToUserInput>
    createMany?: EquipmentAssignmentCreateManyAssignedToUserInputEnvelope
    connect?: Enumerable<EquipmentAssignmentWhereUniqueInput>
  }

  export type SocialPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<SocialPostCreateWithoutAuthorInput>, Enumerable<SocialPostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<SocialPostCreateOrConnectWithoutAuthorInput>
    createMany?: SocialPostCreateManyAuthorInputEnvelope
    connect?: Enumerable<SocialPostWhereUniqueInput>
  }

  export type PostCommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutAuthorInput>, Enumerable<PostCommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutAuthorInput>
    createMany?: PostCommentCreateManyAuthorInputEnvelope
    connect?: Enumerable<PostCommentWhereUniqueInput>
  }

  export type EventRegistrationCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EventRegistrationCreateWithoutUserInput>, Enumerable<EventRegistrationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EventRegistrationCreateOrConnectWithoutUserInput>
    createMany?: EventRegistrationCreateManyUserInputEnvelope
    connect?: Enumerable<EventRegistrationWhereUniqueInput>
  }

  export type ForumThreadCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ForumThreadCreateWithoutAuthorInput>, Enumerable<ForumThreadUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ForumThreadCreateOrConnectWithoutAuthorInput>
    createMany?: ForumThreadCreateManyAuthorInputEnvelope
    connect?: Enumerable<ForumThreadWhereUniqueInput>
  }

  export type ForumPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ForumPostCreateWithoutAuthorInput>, Enumerable<ForumPostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ForumPostCreateOrConnectWithoutAuthorInput>
    createMany?: ForumPostCreateManyAuthorInputEnvelope
    connect?: Enumerable<ForumPostWhereUniqueInput>
  }

  export type BenefitClaimCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BenefitClaimCreateWithoutUserInput>, Enumerable<BenefitClaimUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BenefitClaimCreateOrConnectWithoutUserInput>
    createMany?: BenefitClaimCreateManyUserInputEnvelope
    connect?: Enumerable<BenefitClaimWhereUniqueInput>
  }

  export type PayrollRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PayrollRecordCreateWithoutUserInput>, Enumerable<PayrollRecordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PayrollRecordCreateOrConnectWithoutUserInput>
    createMany?: PayrollRecordCreateManyUserInputEnvelope
    connect?: Enumerable<PayrollRecordWhereUniqueInput>
  }

  export type BookingCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BookingCreateWithoutUserInput>, Enumerable<BookingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BookingCreateOrConnectWithoutUserInput>
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: Enumerable<BookingWhereUniqueInput>
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<PostCreateWithoutAuthorInput>, Enumerable<PostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutAuthorInput>
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type TwoFactorAuthCreateNestedOneWithoutUserInput = {
    create?: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: TwoFactorAuthCreateOrConnectWithoutUserInput
    connect?: TwoFactorAuthWhereUniqueInput
  }

  export type WebAuthnCredentialCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WebAuthnCredentialCreateWithoutUserInput>, Enumerable<WebAuthnCredentialUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WebAuthnCredentialCreateOrConnectWithoutUserInput>
    createMany?: WebAuthnCredentialCreateManyUserInputEnvelope
    connect?: Enumerable<WebAuthnCredentialWhereUniqueInput>
  }

  export type LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LoyaltyTransactionCreateWithoutUserInput>, Enumerable<LoyaltyTransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoyaltyTransactionCreateOrConnectWithoutUserInput>
    createMany?: LoyaltyTransactionCreateManyUserInputEnvelope
    connect?: Enumerable<LoyaltyTransactionWhereUniqueInput>
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutUserInput>, Enumerable<SubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutUserInput>
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutReferredByInput = {
    create?: XOR<Enumerable<UserCreateWithoutReferredByInput>, Enumerable<UserUncheckedCreateWithoutReferredByInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutReferredByInput>
    createMany?: UserCreateManyReferredByInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type AnalyticsEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AnalyticsEventCreateWithoutUserInput>, Enumerable<AnalyticsEventUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AnalyticsEventCreateOrConnectWithoutUserInput>
    createMany?: AnalyticsEventCreateManyUserInputEnvelope
    connect?: Enumerable<AnalyticsEventWhereUniqueInput>
  }

  export type PaymentTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PaymentTransactionCreateWithoutUserInput>, Enumerable<PaymentTransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PaymentTransactionCreateOrConnectWithoutUserInput>
    createMany?: PaymentTransactionCreateManyUserInputEnvelope
    connect?: Enumerable<PaymentTransactionWhereUniqueInput>
  }

  export type TrainingProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TrainingProgressCreateWithoutUserInput>, Enumerable<TrainingProgressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TrainingProgressCreateOrConnectWithoutUserInput>
    createMany?: TrainingProgressCreateManyUserInputEnvelope
    connect?: Enumerable<TrainingProgressWhereUniqueInput>
  }

  export type GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<GoogleCalendarTokenCreateWithoutUserInput, GoogleCalendarTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleCalendarTokenCreateOrConnectWithoutUserInput
    connect?: GoogleCalendarTokenWhereUniqueInput
  }

  export type OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<OutlookCalendarTokenCreateWithoutUserInput, OutlookCalendarTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: OutlookCalendarTokenCreateOrConnectWithoutUserInput
    connect?: OutlookCalendarTokenWhereUniqueInput
  }

  export type EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput = {
    create?: XOR<Enumerable<EquipmentAssignmentCreateWithoutAssignedToUserInput>, Enumerable<EquipmentAssignmentUncheckedCreateWithoutAssignedToUserInput>>
    connectOrCreate?: Enumerable<EquipmentAssignmentCreateOrConnectWithoutAssignedToUserInput>
    createMany?: EquipmentAssignmentCreateManyAssignedToUserInputEnvelope
    connect?: Enumerable<EquipmentAssignmentWhereUniqueInput>
  }

  export type SocialPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<SocialPostCreateWithoutAuthorInput>, Enumerable<SocialPostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<SocialPostCreateOrConnectWithoutAuthorInput>
    createMany?: SocialPostCreateManyAuthorInputEnvelope
    connect?: Enumerable<SocialPostWhereUniqueInput>
  }

  export type PostCommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutAuthorInput>, Enumerable<PostCommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutAuthorInput>
    createMany?: PostCommentCreateManyAuthorInputEnvelope
    connect?: Enumerable<PostCommentWhereUniqueInput>
  }

  export type EventRegistrationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EventRegistrationCreateWithoutUserInput>, Enumerable<EventRegistrationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EventRegistrationCreateOrConnectWithoutUserInput>
    createMany?: EventRegistrationCreateManyUserInputEnvelope
    connect?: Enumerable<EventRegistrationWhereUniqueInput>
  }

  export type ForumThreadUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ForumThreadCreateWithoutAuthorInput>, Enumerable<ForumThreadUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ForumThreadCreateOrConnectWithoutAuthorInput>
    createMany?: ForumThreadCreateManyAuthorInputEnvelope
    connect?: Enumerable<ForumThreadWhereUniqueInput>
  }

  export type ForumPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ForumPostCreateWithoutAuthorInput>, Enumerable<ForumPostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ForumPostCreateOrConnectWithoutAuthorInput>
    createMany?: ForumPostCreateManyAuthorInputEnvelope
    connect?: Enumerable<ForumPostWhereUniqueInput>
  }

  export type BenefitClaimUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BenefitClaimCreateWithoutUserInput>, Enumerable<BenefitClaimUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BenefitClaimCreateOrConnectWithoutUserInput>
    createMany?: BenefitClaimCreateManyUserInputEnvelope
    connect?: Enumerable<BenefitClaimWhereUniqueInput>
  }

  export type PayrollRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PayrollRecordCreateWithoutUserInput>, Enumerable<PayrollRecordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PayrollRecordCreateOrConnectWithoutUserInput>
    createMany?: PayrollRecordCreateManyUserInputEnvelope
    connect?: Enumerable<PayrollRecordWhereUniqueInput>
  }

  export type BookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BookingCreateWithoutUserInput>, Enumerable<BookingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BookingCreateOrConnectWithoutUserInput>
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: Enumerable<BookingWhereUniqueInput>
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<PostCreateWithoutAuthorInput>, Enumerable<PostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutAuthorInput>
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: TwoFactorAuthCreateOrConnectWithoutUserInput
    connect?: TwoFactorAuthWhereUniqueInput
  }

  export type WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WebAuthnCredentialCreateWithoutUserInput>, Enumerable<WebAuthnCredentialUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WebAuthnCredentialCreateOrConnectWithoutUserInput>
    createMany?: WebAuthnCredentialCreateManyUserInputEnvelope
    connect?: Enumerable<WebAuthnCredentialWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type LoyaltyTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LoyaltyTransactionCreateWithoutUserInput>, Enumerable<LoyaltyTransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoyaltyTransactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LoyaltyTransactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LoyaltyTransactionCreateManyUserInputEnvelope
    set?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    disconnect?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    delete?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    connect?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    update?: Enumerable<LoyaltyTransactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LoyaltyTransactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LoyaltyTransactionScalarWhereInput>
  }

  export type SubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutUserInput>, Enumerable<SubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type UserUpdateOneWithoutReferralsNestedInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    upsert?: UserUpsertWithoutReferralsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateManyWithoutReferredByNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutReferredByInput>, Enumerable<UserUncheckedCreateWithoutReferredByInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutReferredByInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutReferredByInput>
    createMany?: UserCreateManyReferredByInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutReferredByInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutReferredByInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type AnalyticsEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AnalyticsEventCreateWithoutUserInput>, Enumerable<AnalyticsEventUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AnalyticsEventCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AnalyticsEventUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AnalyticsEventCreateManyUserInputEnvelope
    set?: Enumerable<AnalyticsEventWhereUniqueInput>
    disconnect?: Enumerable<AnalyticsEventWhereUniqueInput>
    delete?: Enumerable<AnalyticsEventWhereUniqueInput>
    connect?: Enumerable<AnalyticsEventWhereUniqueInput>
    update?: Enumerable<AnalyticsEventUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AnalyticsEventUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AnalyticsEventScalarWhereInput>
  }

  export type PaymentTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PaymentTransactionCreateWithoutUserInput>, Enumerable<PaymentTransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PaymentTransactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PaymentTransactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PaymentTransactionCreateManyUserInputEnvelope
    set?: Enumerable<PaymentTransactionWhereUniqueInput>
    disconnect?: Enumerable<PaymentTransactionWhereUniqueInput>
    delete?: Enumerable<PaymentTransactionWhereUniqueInput>
    connect?: Enumerable<PaymentTransactionWhereUniqueInput>
    update?: Enumerable<PaymentTransactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PaymentTransactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PaymentTransactionScalarWhereInput>
  }

  export type TrainingProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TrainingProgressCreateWithoutUserInput>, Enumerable<TrainingProgressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TrainingProgressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TrainingProgressUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TrainingProgressCreateManyUserInputEnvelope
    set?: Enumerable<TrainingProgressWhereUniqueInput>
    disconnect?: Enumerable<TrainingProgressWhereUniqueInput>
    delete?: Enumerable<TrainingProgressWhereUniqueInput>
    connect?: Enumerable<TrainingProgressWhereUniqueInput>
    update?: Enumerable<TrainingProgressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TrainingProgressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TrainingProgressScalarWhereInput>
  }

  export type GoogleCalendarTokenUpdateOneWithoutUserNestedInput = {
    create?: XOR<GoogleCalendarTokenCreateWithoutUserInput, GoogleCalendarTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleCalendarTokenCreateOrConnectWithoutUserInput
    upsert?: GoogleCalendarTokenUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: GoogleCalendarTokenWhereUniqueInput
    update?: XOR<GoogleCalendarTokenUpdateWithoutUserInput, GoogleCalendarTokenUncheckedUpdateWithoutUserInput>
  }

  export type OutlookCalendarTokenUpdateOneWithoutUserNestedInput = {
    create?: XOR<OutlookCalendarTokenCreateWithoutUserInput, OutlookCalendarTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: OutlookCalendarTokenCreateOrConnectWithoutUserInput
    upsert?: OutlookCalendarTokenUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: OutlookCalendarTokenWhereUniqueInput
    update?: XOR<OutlookCalendarTokenUpdateWithoutUserInput, OutlookCalendarTokenUncheckedUpdateWithoutUserInput>
  }

  export type EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput = {
    create?: XOR<Enumerable<EquipmentAssignmentCreateWithoutAssignedToUserInput>, Enumerable<EquipmentAssignmentUncheckedCreateWithoutAssignedToUserInput>>
    connectOrCreate?: Enumerable<EquipmentAssignmentCreateOrConnectWithoutAssignedToUserInput>
    upsert?: Enumerable<EquipmentAssignmentUpsertWithWhereUniqueWithoutAssignedToUserInput>
    createMany?: EquipmentAssignmentCreateManyAssignedToUserInputEnvelope
    set?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    disconnect?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    delete?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    connect?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    update?: Enumerable<EquipmentAssignmentUpdateWithWhereUniqueWithoutAssignedToUserInput>
    updateMany?: Enumerable<EquipmentAssignmentUpdateManyWithWhereWithoutAssignedToUserInput>
    deleteMany?: Enumerable<EquipmentAssignmentScalarWhereInput>
  }

  export type SocialPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<SocialPostCreateWithoutAuthorInput>, Enumerable<SocialPostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<SocialPostCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<SocialPostUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: SocialPostCreateManyAuthorInputEnvelope
    set?: Enumerable<SocialPostWhereUniqueInput>
    disconnect?: Enumerable<SocialPostWhereUniqueInput>
    delete?: Enumerable<SocialPostWhereUniqueInput>
    connect?: Enumerable<SocialPostWhereUniqueInput>
    update?: Enumerable<SocialPostUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<SocialPostUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<SocialPostScalarWhereInput>
  }

  export type PostCommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutAuthorInput>, Enumerable<PostCommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<PostCommentUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: PostCommentCreateManyAuthorInputEnvelope
    set?: Enumerable<PostCommentWhereUniqueInput>
    disconnect?: Enumerable<PostCommentWhereUniqueInput>
    delete?: Enumerable<PostCommentWhereUniqueInput>
    connect?: Enumerable<PostCommentWhereUniqueInput>
    update?: Enumerable<PostCommentUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<PostCommentUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<PostCommentScalarWhereInput>
  }

  export type EventRegistrationUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<EventRegistrationCreateWithoutUserInput>, Enumerable<EventRegistrationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EventRegistrationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EventRegistrationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EventRegistrationCreateManyUserInputEnvelope
    set?: Enumerable<EventRegistrationWhereUniqueInput>
    disconnect?: Enumerable<EventRegistrationWhereUniqueInput>
    delete?: Enumerable<EventRegistrationWhereUniqueInput>
    connect?: Enumerable<EventRegistrationWhereUniqueInput>
    update?: Enumerable<EventRegistrationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EventRegistrationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EventRegistrationScalarWhereInput>
  }

  export type ForumThreadUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<ForumThreadCreateWithoutAuthorInput>, Enumerable<ForumThreadUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ForumThreadCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ForumThreadUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ForumThreadCreateManyAuthorInputEnvelope
    set?: Enumerable<ForumThreadWhereUniqueInput>
    disconnect?: Enumerable<ForumThreadWhereUniqueInput>
    delete?: Enumerable<ForumThreadWhereUniqueInput>
    connect?: Enumerable<ForumThreadWhereUniqueInput>
    update?: Enumerable<ForumThreadUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ForumThreadUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ForumThreadScalarWhereInput>
  }

  export type ForumPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<ForumPostCreateWithoutAuthorInput>, Enumerable<ForumPostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ForumPostCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ForumPostUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ForumPostCreateManyAuthorInputEnvelope
    set?: Enumerable<ForumPostWhereUniqueInput>
    disconnect?: Enumerable<ForumPostWhereUniqueInput>
    delete?: Enumerable<ForumPostWhereUniqueInput>
    connect?: Enumerable<ForumPostWhereUniqueInput>
    update?: Enumerable<ForumPostUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ForumPostUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ForumPostScalarWhereInput>
  }

  export type BenefitClaimUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BenefitClaimCreateWithoutUserInput>, Enumerable<BenefitClaimUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BenefitClaimCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BenefitClaimUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BenefitClaimCreateManyUserInputEnvelope
    set?: Enumerable<BenefitClaimWhereUniqueInput>
    disconnect?: Enumerable<BenefitClaimWhereUniqueInput>
    delete?: Enumerable<BenefitClaimWhereUniqueInput>
    connect?: Enumerable<BenefitClaimWhereUniqueInput>
    update?: Enumerable<BenefitClaimUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BenefitClaimUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BenefitClaimScalarWhereInput>
  }

  export type PayrollRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PayrollRecordCreateWithoutUserInput>, Enumerable<PayrollRecordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PayrollRecordCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PayrollRecordUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PayrollRecordCreateManyUserInputEnvelope
    set?: Enumerable<PayrollRecordWhereUniqueInput>
    disconnect?: Enumerable<PayrollRecordWhereUniqueInput>
    delete?: Enumerable<PayrollRecordWhereUniqueInput>
    connect?: Enumerable<PayrollRecordWhereUniqueInput>
    update?: Enumerable<PayrollRecordUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PayrollRecordUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PayrollRecordScalarWhereInput>
  }

  export type BookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BookingCreateWithoutUserInput>, Enumerable<BookingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BookingCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BookingUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BookingCreateManyUserInputEnvelope
    set?: Enumerable<BookingWhereUniqueInput>
    disconnect?: Enumerable<BookingWhereUniqueInput>
    delete?: Enumerable<BookingWhereUniqueInput>
    connect?: Enumerable<BookingWhereUniqueInput>
    update?: Enumerable<BookingUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BookingUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BookingScalarWhereInput>
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutAuthorInput>, Enumerable<PostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type TwoFactorAuthUpdateOneWithoutUserNestedInput = {
    create?: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: TwoFactorAuthCreateOrConnectWithoutUserInput
    upsert?: TwoFactorAuthUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: TwoFactorAuthWhereUniqueInput
    update?: XOR<TwoFactorAuthUpdateWithoutUserInput, TwoFactorAuthUncheckedUpdateWithoutUserInput>
  }

  export type WebAuthnCredentialUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WebAuthnCredentialCreateWithoutUserInput>, Enumerable<WebAuthnCredentialUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WebAuthnCredentialCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WebAuthnCredentialUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WebAuthnCredentialCreateManyUserInputEnvelope
    set?: Enumerable<WebAuthnCredentialWhereUniqueInput>
    disconnect?: Enumerable<WebAuthnCredentialWhereUniqueInput>
    delete?: Enumerable<WebAuthnCredentialWhereUniqueInput>
    connect?: Enumerable<WebAuthnCredentialWhereUniqueInput>
    update?: Enumerable<WebAuthnCredentialUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WebAuthnCredentialUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WebAuthnCredentialScalarWhereInput>
  }

  export type LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LoyaltyTransactionCreateWithoutUserInput>, Enumerable<LoyaltyTransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LoyaltyTransactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LoyaltyTransactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LoyaltyTransactionCreateManyUserInputEnvelope
    set?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    disconnect?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    delete?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    connect?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    update?: Enumerable<LoyaltyTransactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LoyaltyTransactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LoyaltyTransactionScalarWhereInput>
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutUserInput>, Enumerable<SubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutReferredByNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutReferredByInput>, Enumerable<UserUncheckedCreateWithoutReferredByInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutReferredByInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutReferredByInput>
    createMany?: UserCreateManyReferredByInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutReferredByInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutReferredByInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AnalyticsEventCreateWithoutUserInput>, Enumerable<AnalyticsEventUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AnalyticsEventCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AnalyticsEventUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AnalyticsEventCreateManyUserInputEnvelope
    set?: Enumerable<AnalyticsEventWhereUniqueInput>
    disconnect?: Enumerable<AnalyticsEventWhereUniqueInput>
    delete?: Enumerable<AnalyticsEventWhereUniqueInput>
    connect?: Enumerable<AnalyticsEventWhereUniqueInput>
    update?: Enumerable<AnalyticsEventUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AnalyticsEventUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AnalyticsEventScalarWhereInput>
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PaymentTransactionCreateWithoutUserInput>, Enumerable<PaymentTransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PaymentTransactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PaymentTransactionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PaymentTransactionCreateManyUserInputEnvelope
    set?: Enumerable<PaymentTransactionWhereUniqueInput>
    disconnect?: Enumerable<PaymentTransactionWhereUniqueInput>
    delete?: Enumerable<PaymentTransactionWhereUniqueInput>
    connect?: Enumerable<PaymentTransactionWhereUniqueInput>
    update?: Enumerable<PaymentTransactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PaymentTransactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PaymentTransactionScalarWhereInput>
  }

  export type TrainingProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TrainingProgressCreateWithoutUserInput>, Enumerable<TrainingProgressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TrainingProgressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TrainingProgressUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TrainingProgressCreateManyUserInputEnvelope
    set?: Enumerable<TrainingProgressWhereUniqueInput>
    disconnect?: Enumerable<TrainingProgressWhereUniqueInput>
    delete?: Enumerable<TrainingProgressWhereUniqueInput>
    connect?: Enumerable<TrainingProgressWhereUniqueInput>
    update?: Enumerable<TrainingProgressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TrainingProgressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TrainingProgressScalarWhereInput>
  }

  export type GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<GoogleCalendarTokenCreateWithoutUserInput, GoogleCalendarTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleCalendarTokenCreateOrConnectWithoutUserInput
    upsert?: GoogleCalendarTokenUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: GoogleCalendarTokenWhereUniqueInput
    update?: XOR<GoogleCalendarTokenUpdateWithoutUserInput, GoogleCalendarTokenUncheckedUpdateWithoutUserInput>
  }

  export type OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<OutlookCalendarTokenCreateWithoutUserInput, OutlookCalendarTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: OutlookCalendarTokenCreateOrConnectWithoutUserInput
    upsert?: OutlookCalendarTokenUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: OutlookCalendarTokenWhereUniqueInput
    update?: XOR<OutlookCalendarTokenUpdateWithoutUserInput, OutlookCalendarTokenUncheckedUpdateWithoutUserInput>
  }

  export type EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput = {
    create?: XOR<Enumerable<EquipmentAssignmentCreateWithoutAssignedToUserInput>, Enumerable<EquipmentAssignmentUncheckedCreateWithoutAssignedToUserInput>>
    connectOrCreate?: Enumerable<EquipmentAssignmentCreateOrConnectWithoutAssignedToUserInput>
    upsert?: Enumerable<EquipmentAssignmentUpsertWithWhereUniqueWithoutAssignedToUserInput>
    createMany?: EquipmentAssignmentCreateManyAssignedToUserInputEnvelope
    set?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    disconnect?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    delete?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    connect?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    update?: Enumerable<EquipmentAssignmentUpdateWithWhereUniqueWithoutAssignedToUserInput>
    updateMany?: Enumerable<EquipmentAssignmentUpdateManyWithWhereWithoutAssignedToUserInput>
    deleteMany?: Enumerable<EquipmentAssignmentScalarWhereInput>
  }

  export type SocialPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<SocialPostCreateWithoutAuthorInput>, Enumerable<SocialPostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<SocialPostCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<SocialPostUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: SocialPostCreateManyAuthorInputEnvelope
    set?: Enumerable<SocialPostWhereUniqueInput>
    disconnect?: Enumerable<SocialPostWhereUniqueInput>
    delete?: Enumerable<SocialPostWhereUniqueInput>
    connect?: Enumerable<SocialPostWhereUniqueInput>
    update?: Enumerable<SocialPostUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<SocialPostUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<SocialPostScalarWhereInput>
  }

  export type PostCommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutAuthorInput>, Enumerable<PostCommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<PostCommentUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: PostCommentCreateManyAuthorInputEnvelope
    set?: Enumerable<PostCommentWhereUniqueInput>
    disconnect?: Enumerable<PostCommentWhereUniqueInput>
    delete?: Enumerable<PostCommentWhereUniqueInput>
    connect?: Enumerable<PostCommentWhereUniqueInput>
    update?: Enumerable<PostCommentUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<PostCommentUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<PostCommentScalarWhereInput>
  }

  export type EventRegistrationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<EventRegistrationCreateWithoutUserInput>, Enumerable<EventRegistrationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EventRegistrationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EventRegistrationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EventRegistrationCreateManyUserInputEnvelope
    set?: Enumerable<EventRegistrationWhereUniqueInput>
    disconnect?: Enumerable<EventRegistrationWhereUniqueInput>
    delete?: Enumerable<EventRegistrationWhereUniqueInput>
    connect?: Enumerable<EventRegistrationWhereUniqueInput>
    update?: Enumerable<EventRegistrationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EventRegistrationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EventRegistrationScalarWhereInput>
  }

  export type ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<ForumThreadCreateWithoutAuthorInput>, Enumerable<ForumThreadUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ForumThreadCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ForumThreadUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ForumThreadCreateManyAuthorInputEnvelope
    set?: Enumerable<ForumThreadWhereUniqueInput>
    disconnect?: Enumerable<ForumThreadWhereUniqueInput>
    delete?: Enumerable<ForumThreadWhereUniqueInput>
    connect?: Enumerable<ForumThreadWhereUniqueInput>
    update?: Enumerable<ForumThreadUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ForumThreadUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ForumThreadScalarWhereInput>
  }

  export type ForumPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<ForumPostCreateWithoutAuthorInput>, Enumerable<ForumPostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ForumPostCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ForumPostUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ForumPostCreateManyAuthorInputEnvelope
    set?: Enumerable<ForumPostWhereUniqueInput>
    disconnect?: Enumerable<ForumPostWhereUniqueInput>
    delete?: Enumerable<ForumPostWhereUniqueInput>
    connect?: Enumerable<ForumPostWhereUniqueInput>
    update?: Enumerable<ForumPostUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ForumPostUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ForumPostScalarWhereInput>
  }

  export type BenefitClaimUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BenefitClaimCreateWithoutUserInput>, Enumerable<BenefitClaimUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BenefitClaimCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BenefitClaimUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BenefitClaimCreateManyUserInputEnvelope
    set?: Enumerable<BenefitClaimWhereUniqueInput>
    disconnect?: Enumerable<BenefitClaimWhereUniqueInput>
    delete?: Enumerable<BenefitClaimWhereUniqueInput>
    connect?: Enumerable<BenefitClaimWhereUniqueInput>
    update?: Enumerable<BenefitClaimUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BenefitClaimUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BenefitClaimScalarWhereInput>
  }

  export type PayrollRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PayrollRecordCreateWithoutUserInput>, Enumerable<PayrollRecordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PayrollRecordCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PayrollRecordUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PayrollRecordCreateManyUserInputEnvelope
    set?: Enumerable<PayrollRecordWhereUniqueInput>
    disconnect?: Enumerable<PayrollRecordWhereUniqueInput>
    delete?: Enumerable<PayrollRecordWhereUniqueInput>
    connect?: Enumerable<PayrollRecordWhereUniqueInput>
    update?: Enumerable<PayrollRecordUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PayrollRecordUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PayrollRecordScalarWhereInput>
  }

  export type BookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BookingCreateWithoutUserInput>, Enumerable<BookingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BookingCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BookingUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BookingCreateManyUserInputEnvelope
    set?: Enumerable<BookingWhereUniqueInput>
    disconnect?: Enumerable<BookingWhereUniqueInput>
    delete?: Enumerable<BookingWhereUniqueInput>
    connect?: Enumerable<BookingWhereUniqueInput>
    update?: Enumerable<BookingUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BookingUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BookingScalarWhereInput>
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutAuthorInput>, Enumerable<PostUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: TwoFactorAuthCreateOrConnectWithoutUserInput
    upsert?: TwoFactorAuthUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: TwoFactorAuthWhereUniqueInput
    update?: XOR<TwoFactorAuthUpdateWithoutUserInput, TwoFactorAuthUncheckedUpdateWithoutUserInput>
  }

  export type WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WebAuthnCredentialCreateWithoutUserInput>, Enumerable<WebAuthnCredentialUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WebAuthnCredentialCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WebAuthnCredentialUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WebAuthnCredentialCreateManyUserInputEnvelope
    set?: Enumerable<WebAuthnCredentialWhereUniqueInput>
    disconnect?: Enumerable<WebAuthnCredentialWhereUniqueInput>
    delete?: Enumerable<WebAuthnCredentialWhereUniqueInput>
    connect?: Enumerable<WebAuthnCredentialWhereUniqueInput>
    update?: Enumerable<WebAuthnCredentialUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WebAuthnCredentialUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WebAuthnCredentialScalarWhereInput>
  }

  export type ServiceCreateNestedManyWithoutProviderInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutProviderInput>, Enumerable<ServiceUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutProviderInput>
    createMany?: ServiceCreateManyProviderInputEnvelope
    connect?: Enumerable<ServiceWhereUniqueInput>
  }

  export type BusinessCreateNestedManyWithoutProviderInput = {
    create?: XOR<Enumerable<BusinessCreateWithoutProviderInput>, Enumerable<BusinessUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<BusinessCreateOrConnectWithoutProviderInput>
    createMany?: BusinessCreateManyProviderInputEnvelope
    connect?: Enumerable<BusinessWhereUniqueInput>
  }

  export type ServiceUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutProviderInput>, Enumerable<ServiceUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutProviderInput>
    createMany?: ServiceCreateManyProviderInputEnvelope
    connect?: Enumerable<ServiceWhereUniqueInput>
  }

  export type BusinessUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<Enumerable<BusinessCreateWithoutProviderInput>, Enumerable<BusinessUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<BusinessCreateOrConnectWithoutProviderInput>
    createMany?: BusinessCreateManyProviderInputEnvelope
    connect?: Enumerable<BusinessWhereUniqueInput>
  }

  export type ServiceUpdateManyWithoutProviderNestedInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutProviderInput>, Enumerable<ServiceUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutProviderInput>
    upsert?: Enumerable<ServiceUpsertWithWhereUniqueWithoutProviderInput>
    createMany?: ServiceCreateManyProviderInputEnvelope
    set?: Enumerable<ServiceWhereUniqueInput>
    disconnect?: Enumerable<ServiceWhereUniqueInput>
    delete?: Enumerable<ServiceWhereUniqueInput>
    connect?: Enumerable<ServiceWhereUniqueInput>
    update?: Enumerable<ServiceUpdateWithWhereUniqueWithoutProviderInput>
    updateMany?: Enumerable<ServiceUpdateManyWithWhereWithoutProviderInput>
    deleteMany?: Enumerable<ServiceScalarWhereInput>
  }

  export type BusinessUpdateManyWithoutProviderNestedInput = {
    create?: XOR<Enumerable<BusinessCreateWithoutProviderInput>, Enumerable<BusinessUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<BusinessCreateOrConnectWithoutProviderInput>
    upsert?: Enumerable<BusinessUpsertWithWhereUniqueWithoutProviderInput>
    createMany?: BusinessCreateManyProviderInputEnvelope
    set?: Enumerable<BusinessWhereUniqueInput>
    disconnect?: Enumerable<BusinessWhereUniqueInput>
    delete?: Enumerable<BusinessWhereUniqueInput>
    connect?: Enumerable<BusinessWhereUniqueInput>
    update?: Enumerable<BusinessUpdateWithWhereUniqueWithoutProviderInput>
    updateMany?: Enumerable<BusinessUpdateManyWithWhereWithoutProviderInput>
    deleteMany?: Enumerable<BusinessScalarWhereInput>
  }

  export type ServiceUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<Enumerable<ServiceCreateWithoutProviderInput>, Enumerable<ServiceUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<ServiceCreateOrConnectWithoutProviderInput>
    upsert?: Enumerable<ServiceUpsertWithWhereUniqueWithoutProviderInput>
    createMany?: ServiceCreateManyProviderInputEnvelope
    set?: Enumerable<ServiceWhereUniqueInput>
    disconnect?: Enumerable<ServiceWhereUniqueInput>
    delete?: Enumerable<ServiceWhereUniqueInput>
    connect?: Enumerable<ServiceWhereUniqueInput>
    update?: Enumerable<ServiceUpdateWithWhereUniqueWithoutProviderInput>
    updateMany?: Enumerable<ServiceUpdateManyWithWhereWithoutProviderInput>
    deleteMany?: Enumerable<ServiceScalarWhereInput>
  }

  export type BusinessUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<Enumerable<BusinessCreateWithoutProviderInput>, Enumerable<BusinessUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<BusinessCreateOrConnectWithoutProviderInput>
    upsert?: Enumerable<BusinessUpsertWithWhereUniqueWithoutProviderInput>
    createMany?: BusinessCreateManyProviderInputEnvelope
    set?: Enumerable<BusinessWhereUniqueInput>
    disconnect?: Enumerable<BusinessWhereUniqueInput>
    delete?: Enumerable<BusinessWhereUniqueInput>
    connect?: Enumerable<BusinessWhereUniqueInput>
    update?: Enumerable<BusinessUpdateWithWhereUniqueWithoutProviderInput>
    updateMany?: Enumerable<BusinessUpdateManyWithWhereWithoutProviderInput>
    deleteMany?: Enumerable<BusinessScalarWhereInput>
  }

  export type ProviderCreateNestedOneWithoutServicesInput = {
    create?: XOR<ProviderCreateWithoutServicesInput, ProviderUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutServicesInput
    connect?: ProviderWhereUniqueInput
  }

  export type PaymentTransactionCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<PaymentTransactionCreateWithoutServiceInput>, Enumerable<PaymentTransactionUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<PaymentTransactionCreateOrConnectWithoutServiceInput>
    createMany?: PaymentTransactionCreateManyServiceInputEnvelope
    connect?: Enumerable<PaymentTransactionWhereUniqueInput>
  }

  export type BookingCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<BookingCreateWithoutServiceInput>, Enumerable<BookingUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<BookingCreateOrConnectWithoutServiceInput>
    createMany?: BookingCreateManyServiceInputEnvelope
    connect?: Enumerable<BookingWhereUniqueInput>
  }

  export type PaymentTransactionUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<PaymentTransactionCreateWithoutServiceInput>, Enumerable<PaymentTransactionUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<PaymentTransactionCreateOrConnectWithoutServiceInput>
    createMany?: PaymentTransactionCreateManyServiceInputEnvelope
    connect?: Enumerable<PaymentTransactionWhereUniqueInput>
  }

  export type BookingUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<BookingCreateWithoutServiceInput>, Enumerable<BookingUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<BookingCreateOrConnectWithoutServiceInput>
    createMany?: BookingCreateManyServiceInputEnvelope
    connect?: Enumerable<BookingWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProviderUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<ProviderCreateWithoutServicesInput, ProviderUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutServicesInput
    upsert?: ProviderUpsertWithoutServicesInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<ProviderUpdateWithoutServicesInput, ProviderUncheckedUpdateWithoutServicesInput>
  }

  export type PaymentTransactionUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<PaymentTransactionCreateWithoutServiceInput>, Enumerable<PaymentTransactionUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<PaymentTransactionCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<PaymentTransactionUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: PaymentTransactionCreateManyServiceInputEnvelope
    set?: Enumerable<PaymentTransactionWhereUniqueInput>
    disconnect?: Enumerable<PaymentTransactionWhereUniqueInput>
    delete?: Enumerable<PaymentTransactionWhereUniqueInput>
    connect?: Enumerable<PaymentTransactionWhereUniqueInput>
    update?: Enumerable<PaymentTransactionUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<PaymentTransactionUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<PaymentTransactionScalarWhereInput>
  }

  export type BookingUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<BookingCreateWithoutServiceInput>, Enumerable<BookingUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<BookingCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<BookingUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: BookingCreateManyServiceInputEnvelope
    set?: Enumerable<BookingWhereUniqueInput>
    disconnect?: Enumerable<BookingWhereUniqueInput>
    delete?: Enumerable<BookingWhereUniqueInput>
    connect?: Enumerable<BookingWhereUniqueInput>
    update?: Enumerable<BookingUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<BookingUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<BookingScalarWhereInput>
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<PaymentTransactionCreateWithoutServiceInput>, Enumerable<PaymentTransactionUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<PaymentTransactionCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<PaymentTransactionUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: PaymentTransactionCreateManyServiceInputEnvelope
    set?: Enumerable<PaymentTransactionWhereUniqueInput>
    disconnect?: Enumerable<PaymentTransactionWhereUniqueInput>
    delete?: Enumerable<PaymentTransactionWhereUniqueInput>
    connect?: Enumerable<PaymentTransactionWhereUniqueInput>
    update?: Enumerable<PaymentTransactionUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<PaymentTransactionUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<PaymentTransactionScalarWhereInput>
  }

  export type BookingUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<BookingCreateWithoutServiceInput>, Enumerable<BookingUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<BookingCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<BookingUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: BookingCreateManyServiceInputEnvelope
    set?: Enumerable<BookingWhereUniqueInput>
    disconnect?: Enumerable<BookingWhereUniqueInput>
    delete?: Enumerable<BookingWhereUniqueInput>
    connect?: Enumerable<BookingWhereUniqueInput>
    update?: Enumerable<BookingUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<BookingUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<BookingScalarWhereInput>
  }

  export type ProviderCreateNestedOneWithoutBusinessesInput = {
    create?: XOR<ProviderCreateWithoutBusinessesInput, ProviderUncheckedCreateWithoutBusinessesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutBusinessesInput
    connect?: ProviderWhereUniqueInput
  }

  export type BusinessHourCreateNestedManyWithoutBusinessInput = {
    create?: XOR<Enumerable<BusinessHourCreateWithoutBusinessInput>, Enumerable<BusinessHourUncheckedCreateWithoutBusinessInput>>
    connectOrCreate?: Enumerable<BusinessHourCreateOrConnectWithoutBusinessInput>
    createMany?: BusinessHourCreateManyBusinessInputEnvelope
    connect?: Enumerable<BusinessHourWhereUniqueInput>
  }

  export type StaffCreateNestedManyWithoutBusinessInput = {
    create?: XOR<Enumerable<StaffCreateWithoutBusinessInput>, Enumerable<StaffUncheckedCreateWithoutBusinessInput>>
    connectOrCreate?: Enumerable<StaffCreateOrConnectWithoutBusinessInput>
    createMany?: StaffCreateManyBusinessInputEnvelope
    connect?: Enumerable<StaffWhereUniqueInput>
  }

  export type BusinessHourUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<Enumerable<BusinessHourCreateWithoutBusinessInput>, Enumerable<BusinessHourUncheckedCreateWithoutBusinessInput>>
    connectOrCreate?: Enumerable<BusinessHourCreateOrConnectWithoutBusinessInput>
    createMany?: BusinessHourCreateManyBusinessInputEnvelope
    connect?: Enumerable<BusinessHourWhereUniqueInput>
  }

  export type StaffUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<Enumerable<StaffCreateWithoutBusinessInput>, Enumerable<StaffUncheckedCreateWithoutBusinessInput>>
    connectOrCreate?: Enumerable<StaffCreateOrConnectWithoutBusinessInput>
    createMany?: StaffCreateManyBusinessInputEnvelope
    connect?: Enumerable<StaffWhereUniqueInput>
  }

  export type ProviderUpdateOneRequiredWithoutBusinessesNestedInput = {
    create?: XOR<ProviderCreateWithoutBusinessesInput, ProviderUncheckedCreateWithoutBusinessesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutBusinessesInput
    upsert?: ProviderUpsertWithoutBusinessesInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<ProviderUpdateWithoutBusinessesInput, ProviderUncheckedUpdateWithoutBusinessesInput>
  }

  export type BusinessHourUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<Enumerable<BusinessHourCreateWithoutBusinessInput>, Enumerable<BusinessHourUncheckedCreateWithoutBusinessInput>>
    connectOrCreate?: Enumerable<BusinessHourCreateOrConnectWithoutBusinessInput>
    upsert?: Enumerable<BusinessHourUpsertWithWhereUniqueWithoutBusinessInput>
    createMany?: BusinessHourCreateManyBusinessInputEnvelope
    set?: Enumerable<BusinessHourWhereUniqueInput>
    disconnect?: Enumerable<BusinessHourWhereUniqueInput>
    delete?: Enumerable<BusinessHourWhereUniqueInput>
    connect?: Enumerable<BusinessHourWhereUniqueInput>
    update?: Enumerable<BusinessHourUpdateWithWhereUniqueWithoutBusinessInput>
    updateMany?: Enumerable<BusinessHourUpdateManyWithWhereWithoutBusinessInput>
    deleteMany?: Enumerable<BusinessHourScalarWhereInput>
  }

  export type StaffUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<Enumerable<StaffCreateWithoutBusinessInput>, Enumerable<StaffUncheckedCreateWithoutBusinessInput>>
    connectOrCreate?: Enumerable<StaffCreateOrConnectWithoutBusinessInput>
    upsert?: Enumerable<StaffUpsertWithWhereUniqueWithoutBusinessInput>
    createMany?: StaffCreateManyBusinessInputEnvelope
    set?: Enumerable<StaffWhereUniqueInput>
    disconnect?: Enumerable<StaffWhereUniqueInput>
    delete?: Enumerable<StaffWhereUniqueInput>
    connect?: Enumerable<StaffWhereUniqueInput>
    update?: Enumerable<StaffUpdateWithWhereUniqueWithoutBusinessInput>
    updateMany?: Enumerable<StaffUpdateManyWithWhereWithoutBusinessInput>
    deleteMany?: Enumerable<StaffScalarWhereInput>
  }

  export type BusinessHourUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<Enumerable<BusinessHourCreateWithoutBusinessInput>, Enumerable<BusinessHourUncheckedCreateWithoutBusinessInput>>
    connectOrCreate?: Enumerable<BusinessHourCreateOrConnectWithoutBusinessInput>
    upsert?: Enumerable<BusinessHourUpsertWithWhereUniqueWithoutBusinessInput>
    createMany?: BusinessHourCreateManyBusinessInputEnvelope
    set?: Enumerable<BusinessHourWhereUniqueInput>
    disconnect?: Enumerable<BusinessHourWhereUniqueInput>
    delete?: Enumerable<BusinessHourWhereUniqueInput>
    connect?: Enumerable<BusinessHourWhereUniqueInput>
    update?: Enumerable<BusinessHourUpdateWithWhereUniqueWithoutBusinessInput>
    updateMany?: Enumerable<BusinessHourUpdateManyWithWhereWithoutBusinessInput>
    deleteMany?: Enumerable<BusinessHourScalarWhereInput>
  }

  export type StaffUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<Enumerable<StaffCreateWithoutBusinessInput>, Enumerable<StaffUncheckedCreateWithoutBusinessInput>>
    connectOrCreate?: Enumerable<StaffCreateOrConnectWithoutBusinessInput>
    upsert?: Enumerable<StaffUpsertWithWhereUniqueWithoutBusinessInput>
    createMany?: StaffCreateManyBusinessInputEnvelope
    set?: Enumerable<StaffWhereUniqueInput>
    disconnect?: Enumerable<StaffWhereUniqueInput>
    delete?: Enumerable<StaffWhereUniqueInput>
    connect?: Enumerable<StaffWhereUniqueInput>
    update?: Enumerable<StaffUpdateWithWhereUniqueWithoutBusinessInput>
    updateMany?: Enumerable<StaffUpdateManyWithWhereWithoutBusinessInput>
    deleteMany?: Enumerable<StaffScalarWhereInput>
  }

  export type BusinessCreateNestedOneWithoutHoursInput = {
    create?: XOR<BusinessCreateWithoutHoursInput, BusinessUncheckedCreateWithoutHoursInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutHoursInput
    connect?: BusinessWhereUniqueInput
  }

  export type BusinessUpdateOneRequiredWithoutHoursNestedInput = {
    create?: XOR<BusinessCreateWithoutHoursInput, BusinessUncheckedCreateWithoutHoursInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutHoursInput
    upsert?: BusinessUpsertWithoutHoursInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<BusinessUpdateWithoutHoursInput, BusinessUncheckedUpdateWithoutHoursInput>
  }

  export type BusinessCreateNestedOneWithoutStaffInput = {
    create?: XOR<BusinessCreateWithoutStaffInput, BusinessUncheckedCreateWithoutStaffInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutStaffInput
    connect?: BusinessWhereUniqueInput
  }

  export type StaffScheduleCreateNestedManyWithoutStaffInput = {
    create?: XOR<Enumerable<StaffScheduleCreateWithoutStaffInput>, Enumerable<StaffScheduleUncheckedCreateWithoutStaffInput>>
    connectOrCreate?: Enumerable<StaffScheduleCreateOrConnectWithoutStaffInput>
    createMany?: StaffScheduleCreateManyStaffInputEnvelope
    connect?: Enumerable<StaffScheduleWhereUniqueInput>
  }

  export type StaffScheduleUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<Enumerable<StaffScheduleCreateWithoutStaffInput>, Enumerable<StaffScheduleUncheckedCreateWithoutStaffInput>>
    connectOrCreate?: Enumerable<StaffScheduleCreateOrConnectWithoutStaffInput>
    createMany?: StaffScheduleCreateManyStaffInputEnvelope
    connect?: Enumerable<StaffScheduleWhereUniqueInput>
  }

  export type BusinessUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<BusinessCreateWithoutStaffInput, BusinessUncheckedCreateWithoutStaffInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutStaffInput
    upsert?: BusinessUpsertWithoutStaffInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<BusinessUpdateWithoutStaffInput, BusinessUncheckedUpdateWithoutStaffInput>
  }

  export type StaffScheduleUpdateManyWithoutStaffNestedInput = {
    create?: XOR<Enumerable<StaffScheduleCreateWithoutStaffInput>, Enumerable<StaffScheduleUncheckedCreateWithoutStaffInput>>
    connectOrCreate?: Enumerable<StaffScheduleCreateOrConnectWithoutStaffInput>
    upsert?: Enumerable<StaffScheduleUpsertWithWhereUniqueWithoutStaffInput>
    createMany?: StaffScheduleCreateManyStaffInputEnvelope
    set?: Enumerable<StaffScheduleWhereUniqueInput>
    disconnect?: Enumerable<StaffScheduleWhereUniqueInput>
    delete?: Enumerable<StaffScheduleWhereUniqueInput>
    connect?: Enumerable<StaffScheduleWhereUniqueInput>
    update?: Enumerable<StaffScheduleUpdateWithWhereUniqueWithoutStaffInput>
    updateMany?: Enumerable<StaffScheduleUpdateManyWithWhereWithoutStaffInput>
    deleteMany?: Enumerable<StaffScheduleScalarWhereInput>
  }

  export type StaffScheduleUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<Enumerable<StaffScheduleCreateWithoutStaffInput>, Enumerable<StaffScheduleUncheckedCreateWithoutStaffInput>>
    connectOrCreate?: Enumerable<StaffScheduleCreateOrConnectWithoutStaffInput>
    upsert?: Enumerable<StaffScheduleUpsertWithWhereUniqueWithoutStaffInput>
    createMany?: StaffScheduleCreateManyStaffInputEnvelope
    set?: Enumerable<StaffScheduleWhereUniqueInput>
    disconnect?: Enumerable<StaffScheduleWhereUniqueInput>
    delete?: Enumerable<StaffScheduleWhereUniqueInput>
    connect?: Enumerable<StaffScheduleWhereUniqueInput>
    update?: Enumerable<StaffScheduleUpdateWithWhereUniqueWithoutStaffInput>
    updateMany?: Enumerable<StaffScheduleUpdateManyWithWhereWithoutStaffInput>
    deleteMany?: Enumerable<StaffScheduleScalarWhereInput>
  }

  export type StaffCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<StaffCreateWithoutSchedulesInput, StaffUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: StaffCreateOrConnectWithoutSchedulesInput
    connect?: StaffWhereUniqueInput
  }

  export type AttendanceRecordCreateNestedManyWithoutScheduleInput = {
    create?: XOR<Enumerable<AttendanceRecordCreateWithoutScheduleInput>, Enumerable<AttendanceRecordUncheckedCreateWithoutScheduleInput>>
    connectOrCreate?: Enumerable<AttendanceRecordCreateOrConnectWithoutScheduleInput>
    createMany?: AttendanceRecordCreateManyScheduleInputEnvelope
    connect?: Enumerable<AttendanceRecordWhereUniqueInput>
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<Enumerable<AttendanceRecordCreateWithoutScheduleInput>, Enumerable<AttendanceRecordUncheckedCreateWithoutScheduleInput>>
    connectOrCreate?: Enumerable<AttendanceRecordCreateOrConnectWithoutScheduleInput>
    createMany?: AttendanceRecordCreateManyScheduleInputEnvelope
    connect?: Enumerable<AttendanceRecordWhereUniqueInput>
  }

  export type StaffUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<StaffCreateWithoutSchedulesInput, StaffUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: StaffCreateOrConnectWithoutSchedulesInput
    upsert?: StaffUpsertWithoutSchedulesInput
    connect?: StaffWhereUniqueInput
    update?: XOR<StaffUpdateWithoutSchedulesInput, StaffUncheckedUpdateWithoutSchedulesInput>
  }

  export type AttendanceRecordUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<Enumerable<AttendanceRecordCreateWithoutScheduleInput>, Enumerable<AttendanceRecordUncheckedCreateWithoutScheduleInput>>
    connectOrCreate?: Enumerable<AttendanceRecordCreateOrConnectWithoutScheduleInput>
    upsert?: Enumerable<AttendanceRecordUpsertWithWhereUniqueWithoutScheduleInput>
    createMany?: AttendanceRecordCreateManyScheduleInputEnvelope
    set?: Enumerable<AttendanceRecordWhereUniqueInput>
    disconnect?: Enumerable<AttendanceRecordWhereUniqueInput>
    delete?: Enumerable<AttendanceRecordWhereUniqueInput>
    connect?: Enumerable<AttendanceRecordWhereUniqueInput>
    update?: Enumerable<AttendanceRecordUpdateWithWhereUniqueWithoutScheduleInput>
    updateMany?: Enumerable<AttendanceRecordUpdateManyWithWhereWithoutScheduleInput>
    deleteMany?: Enumerable<AttendanceRecordScalarWhereInput>
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<Enumerable<AttendanceRecordCreateWithoutScheduleInput>, Enumerable<AttendanceRecordUncheckedCreateWithoutScheduleInput>>
    connectOrCreate?: Enumerable<AttendanceRecordCreateOrConnectWithoutScheduleInput>
    upsert?: Enumerable<AttendanceRecordUpsertWithWhereUniqueWithoutScheduleInput>
    createMany?: AttendanceRecordCreateManyScheduleInputEnvelope
    set?: Enumerable<AttendanceRecordWhereUniqueInput>
    disconnect?: Enumerable<AttendanceRecordWhereUniqueInput>
    delete?: Enumerable<AttendanceRecordWhereUniqueInput>
    connect?: Enumerable<AttendanceRecordWhereUniqueInput>
    update?: Enumerable<AttendanceRecordUpdateWithWhereUniqueWithoutScheduleInput>
    updateMany?: Enumerable<AttendanceRecordUpdateManyWithWhereWithoutScheduleInput>
    deleteMany?: Enumerable<AttendanceRecordScalarWhereInput>
  }

  export type StaffScheduleCreateNestedOneWithoutAttendanceRecordsInput = {
    create?: XOR<StaffScheduleCreateWithoutAttendanceRecordsInput, StaffScheduleUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: StaffScheduleCreateOrConnectWithoutAttendanceRecordsInput
    connect?: StaffScheduleWhereUniqueInput
  }

  export type StaffScheduleUpdateOneRequiredWithoutAttendanceRecordsNestedInput = {
    create?: XOR<StaffScheduleCreateWithoutAttendanceRecordsInput, StaffScheduleUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: StaffScheduleCreateOrConnectWithoutAttendanceRecordsInput
    upsert?: StaffScheduleUpsertWithoutAttendanceRecordsInput
    connect?: StaffScheduleWhereUniqueInput
    update?: XOR<StaffScheduleUpdateWithoutAttendanceRecordsInput, StaffScheduleUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type TrainingProgressCreateNestedManyWithoutModuleInput = {
    create?: XOR<Enumerable<TrainingProgressCreateWithoutModuleInput>, Enumerable<TrainingProgressUncheckedCreateWithoutModuleInput>>
    connectOrCreate?: Enumerable<TrainingProgressCreateOrConnectWithoutModuleInput>
    createMany?: TrainingProgressCreateManyModuleInputEnvelope
    connect?: Enumerable<TrainingProgressWhereUniqueInput>
  }

  export type TrainingProgressUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<Enumerable<TrainingProgressCreateWithoutModuleInput>, Enumerable<TrainingProgressUncheckedCreateWithoutModuleInput>>
    connectOrCreate?: Enumerable<TrainingProgressCreateOrConnectWithoutModuleInput>
    createMany?: TrainingProgressCreateManyModuleInputEnvelope
    connect?: Enumerable<TrainingProgressWhereUniqueInput>
  }

  export type TrainingProgressUpdateManyWithoutModuleNestedInput = {
    create?: XOR<Enumerable<TrainingProgressCreateWithoutModuleInput>, Enumerable<TrainingProgressUncheckedCreateWithoutModuleInput>>
    connectOrCreate?: Enumerable<TrainingProgressCreateOrConnectWithoutModuleInput>
    upsert?: Enumerable<TrainingProgressUpsertWithWhereUniqueWithoutModuleInput>
    createMany?: TrainingProgressCreateManyModuleInputEnvelope
    set?: Enumerable<TrainingProgressWhereUniqueInput>
    disconnect?: Enumerable<TrainingProgressWhereUniqueInput>
    delete?: Enumerable<TrainingProgressWhereUniqueInput>
    connect?: Enumerable<TrainingProgressWhereUniqueInput>
    update?: Enumerable<TrainingProgressUpdateWithWhereUniqueWithoutModuleInput>
    updateMany?: Enumerable<TrainingProgressUpdateManyWithWhereWithoutModuleInput>
    deleteMany?: Enumerable<TrainingProgressScalarWhereInput>
  }

  export type TrainingProgressUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<Enumerable<TrainingProgressCreateWithoutModuleInput>, Enumerable<TrainingProgressUncheckedCreateWithoutModuleInput>>
    connectOrCreate?: Enumerable<TrainingProgressCreateOrConnectWithoutModuleInput>
    upsert?: Enumerable<TrainingProgressUpsertWithWhereUniqueWithoutModuleInput>
    createMany?: TrainingProgressCreateManyModuleInputEnvelope
    set?: Enumerable<TrainingProgressWhereUniqueInput>
    disconnect?: Enumerable<TrainingProgressWhereUniqueInput>
    delete?: Enumerable<TrainingProgressWhereUniqueInput>
    connect?: Enumerable<TrainingProgressWhereUniqueInput>
    update?: Enumerable<TrainingProgressUpdateWithWhereUniqueWithoutModuleInput>
    updateMany?: Enumerable<TrainingProgressUpdateManyWithWhereWithoutModuleInput>
    deleteMany?: Enumerable<TrainingProgressScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutTrainingProgressInput = {
    create?: XOR<UserCreateWithoutTrainingProgressInput, UserUncheckedCreateWithoutTrainingProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainingProgressInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingModuleCreateNestedOneWithoutTrainingProgressInput = {
    create?: XOR<TrainingModuleCreateWithoutTrainingProgressInput, TrainingModuleUncheckedCreateWithoutTrainingProgressInput>
    connectOrCreate?: TrainingModuleCreateOrConnectWithoutTrainingProgressInput
    connect?: TrainingModuleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTrainingProgressNestedInput = {
    create?: XOR<UserCreateWithoutTrainingProgressInput, UserUncheckedCreateWithoutTrainingProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainingProgressInput
    upsert?: UserUpsertWithoutTrainingProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTrainingProgressInput, UserUncheckedUpdateWithoutTrainingProgressInput>
  }

  export type TrainingModuleUpdateOneRequiredWithoutTrainingProgressNestedInput = {
    create?: XOR<TrainingModuleCreateWithoutTrainingProgressInput, TrainingModuleUncheckedCreateWithoutTrainingProgressInput>
    connectOrCreate?: TrainingModuleCreateOrConnectWithoutTrainingProgressInput
    upsert?: TrainingModuleUpsertWithoutTrainingProgressInput
    connect?: TrainingModuleWhereUniqueInput
    update?: XOR<TrainingModuleUpdateWithoutTrainingProgressInput, TrainingModuleUncheckedUpdateWithoutTrainingProgressInput>
  }

  export type LoyaltyTransactionCreateNestedManyWithoutTierInput = {
    create?: XOR<Enumerable<LoyaltyTransactionCreateWithoutTierInput>, Enumerable<LoyaltyTransactionUncheckedCreateWithoutTierInput>>
    connectOrCreate?: Enumerable<LoyaltyTransactionCreateOrConnectWithoutTierInput>
    createMany?: LoyaltyTransactionCreateManyTierInputEnvelope
    connect?: Enumerable<LoyaltyTransactionWhereUniqueInput>
  }

  export type LoyaltyTransactionUncheckedCreateNestedManyWithoutTierInput = {
    create?: XOR<Enumerable<LoyaltyTransactionCreateWithoutTierInput>, Enumerable<LoyaltyTransactionUncheckedCreateWithoutTierInput>>
    connectOrCreate?: Enumerable<LoyaltyTransactionCreateOrConnectWithoutTierInput>
    createMany?: LoyaltyTransactionCreateManyTierInputEnvelope
    connect?: Enumerable<LoyaltyTransactionWhereUniqueInput>
  }

  export type LoyaltyTransactionUpdateManyWithoutTierNestedInput = {
    create?: XOR<Enumerable<LoyaltyTransactionCreateWithoutTierInput>, Enumerable<LoyaltyTransactionUncheckedCreateWithoutTierInput>>
    connectOrCreate?: Enumerable<LoyaltyTransactionCreateOrConnectWithoutTierInput>
    upsert?: Enumerable<LoyaltyTransactionUpsertWithWhereUniqueWithoutTierInput>
    createMany?: LoyaltyTransactionCreateManyTierInputEnvelope
    set?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    disconnect?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    delete?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    connect?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    update?: Enumerable<LoyaltyTransactionUpdateWithWhereUniqueWithoutTierInput>
    updateMany?: Enumerable<LoyaltyTransactionUpdateManyWithWhereWithoutTierInput>
    deleteMany?: Enumerable<LoyaltyTransactionScalarWhereInput>
  }

  export type LoyaltyTransactionUncheckedUpdateManyWithoutTierNestedInput = {
    create?: XOR<Enumerable<LoyaltyTransactionCreateWithoutTierInput>, Enumerable<LoyaltyTransactionUncheckedCreateWithoutTierInput>>
    connectOrCreate?: Enumerable<LoyaltyTransactionCreateOrConnectWithoutTierInput>
    upsert?: Enumerable<LoyaltyTransactionUpsertWithWhereUniqueWithoutTierInput>
    createMany?: LoyaltyTransactionCreateManyTierInputEnvelope
    set?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    disconnect?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    delete?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    connect?: Enumerable<LoyaltyTransactionWhereUniqueInput>
    update?: Enumerable<LoyaltyTransactionUpdateWithWhereUniqueWithoutTierInput>
    updateMany?: Enumerable<LoyaltyTransactionUpdateManyWithWhereWithoutTierInput>
    deleteMany?: Enumerable<LoyaltyTransactionScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type LoyaltyTierCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<LoyaltyTierCreateWithoutTransactionsInput, LoyaltyTierUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LoyaltyTierCreateOrConnectWithoutTransactionsInput
    connect?: LoyaltyTierWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: TransactionType
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type LoyaltyTierUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<LoyaltyTierCreateWithoutTransactionsInput, LoyaltyTierUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LoyaltyTierCreateOrConnectWithoutTransactionsInput
    upsert?: LoyaltyTierUpsertWithoutTransactionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: LoyaltyTierWhereUniqueInput
    update?: XOR<LoyaltyTierUpdateWithoutTransactionsInput, LoyaltyTierUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserCreateNestedOneWithoutAnalyticsEventsInput = {
    create?: XOR<UserCreateWithoutAnalyticsEventsInput, UserUncheckedCreateWithoutAnalyticsEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsEventsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAnalyticsEventsNestedInput = {
    create?: XOR<UserCreateWithoutAnalyticsEventsInput, UserUncheckedCreateWithoutAnalyticsEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsEventsInput
    upsert?: UserUpsertWithoutAnalyticsEventsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAnalyticsEventsInput, UserUncheckedUpdateWithoutAnalyticsEventsInput>
  }

  export type UserCreateNestedOneWithoutPaymentTransactionsInput = {
    create?: XOR<UserCreateWithoutPaymentTransactionsInput, UserUncheckedCreateWithoutPaymentTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutPaymentTransactionsInput = {
    create?: XOR<ServiceCreateWithoutPaymentTransactionsInput, ServiceUncheckedCreateWithoutPaymentTransactionsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPaymentTransactionsInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPaymentTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentTransactionsInput, UserUncheckedCreateWithoutPaymentTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentTransactionsInput
    upsert?: UserUpsertWithoutPaymentTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPaymentTransactionsInput, UserUncheckedUpdateWithoutPaymentTransactionsInput>
  }

  export type ServiceUpdateOneWithoutPaymentTransactionsNestedInput = {
    create?: XOR<ServiceCreateWithoutPaymentTransactionsInput, ServiceUncheckedCreateWithoutPaymentTransactionsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPaymentTransactionsInput
    upsert?: ServiceUpsertWithoutPaymentTransactionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<ServiceUpdateWithoutPaymentTransactionsInput, ServiceUncheckedUpdateWithoutPaymentTransactionsInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserCreateNestedOneWithoutGoogleCalendarTokenInput = {
    create?: XOR<UserCreateWithoutGoogleCalendarTokenInput, UserUncheckedCreateWithoutGoogleCalendarTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutGoogleCalendarTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGoogleCalendarTokenNestedInput = {
    create?: XOR<UserCreateWithoutGoogleCalendarTokenInput, UserUncheckedCreateWithoutGoogleCalendarTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutGoogleCalendarTokenInput
    upsert?: UserUpsertWithoutGoogleCalendarTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutGoogleCalendarTokenInput, UserUncheckedUpdateWithoutGoogleCalendarTokenInput>
  }

  export type UserCreateNestedOneWithoutOutlookCalendarTokenInput = {
    create?: XOR<UserCreateWithoutOutlookCalendarTokenInput, UserUncheckedCreateWithoutOutlookCalendarTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutOutlookCalendarTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOutlookCalendarTokenNestedInput = {
    create?: XOR<UserCreateWithoutOutlookCalendarTokenInput, UserUncheckedCreateWithoutOutlookCalendarTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutOutlookCalendarTokenInput
    upsert?: UserUpsertWithoutOutlookCalendarTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOutlookCalendarTokenInput, UserUncheckedUpdateWithoutOutlookCalendarTokenInput>
  }

  export type FormSubmissionCreateNestedManyWithoutDefinitionInput = {
    create?: XOR<Enumerable<FormSubmissionCreateWithoutDefinitionInput>, Enumerable<FormSubmissionUncheckedCreateWithoutDefinitionInput>>
    connectOrCreate?: Enumerable<FormSubmissionCreateOrConnectWithoutDefinitionInput>
    createMany?: FormSubmissionCreateManyDefinitionInputEnvelope
    connect?: Enumerable<FormSubmissionWhereUniqueInput>
  }

  export type FormSubmissionUncheckedCreateNestedManyWithoutDefinitionInput = {
    create?: XOR<Enumerable<FormSubmissionCreateWithoutDefinitionInput>, Enumerable<FormSubmissionUncheckedCreateWithoutDefinitionInput>>
    connectOrCreate?: Enumerable<FormSubmissionCreateOrConnectWithoutDefinitionInput>
    createMany?: FormSubmissionCreateManyDefinitionInputEnvelope
    connect?: Enumerable<FormSubmissionWhereUniqueInput>
  }

  export type FormSubmissionUpdateManyWithoutDefinitionNestedInput = {
    create?: XOR<Enumerable<FormSubmissionCreateWithoutDefinitionInput>, Enumerable<FormSubmissionUncheckedCreateWithoutDefinitionInput>>
    connectOrCreate?: Enumerable<FormSubmissionCreateOrConnectWithoutDefinitionInput>
    upsert?: Enumerable<FormSubmissionUpsertWithWhereUniqueWithoutDefinitionInput>
    createMany?: FormSubmissionCreateManyDefinitionInputEnvelope
    set?: Enumerable<FormSubmissionWhereUniqueInput>
    disconnect?: Enumerable<FormSubmissionWhereUniqueInput>
    delete?: Enumerable<FormSubmissionWhereUniqueInput>
    connect?: Enumerable<FormSubmissionWhereUniqueInput>
    update?: Enumerable<FormSubmissionUpdateWithWhereUniqueWithoutDefinitionInput>
    updateMany?: Enumerable<FormSubmissionUpdateManyWithWhereWithoutDefinitionInput>
    deleteMany?: Enumerable<FormSubmissionScalarWhereInput>
  }

  export type FormSubmissionUncheckedUpdateManyWithoutDefinitionNestedInput = {
    create?: XOR<Enumerable<FormSubmissionCreateWithoutDefinitionInput>, Enumerable<FormSubmissionUncheckedCreateWithoutDefinitionInput>>
    connectOrCreate?: Enumerable<FormSubmissionCreateOrConnectWithoutDefinitionInput>
    upsert?: Enumerable<FormSubmissionUpsertWithWhereUniqueWithoutDefinitionInput>
    createMany?: FormSubmissionCreateManyDefinitionInputEnvelope
    set?: Enumerable<FormSubmissionWhereUniqueInput>
    disconnect?: Enumerable<FormSubmissionWhereUniqueInput>
    delete?: Enumerable<FormSubmissionWhereUniqueInput>
    connect?: Enumerable<FormSubmissionWhereUniqueInput>
    update?: Enumerable<FormSubmissionUpdateWithWhereUniqueWithoutDefinitionInput>
    updateMany?: Enumerable<FormSubmissionUpdateManyWithWhereWithoutDefinitionInput>
    deleteMany?: Enumerable<FormSubmissionScalarWhereInput>
  }

  export type FormDefinitionCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<FormDefinitionCreateWithoutSubmissionsInput, FormDefinitionUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: FormDefinitionCreateOrConnectWithoutSubmissionsInput
    connect?: FormDefinitionWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutSubmissionInput>, Enumerable<DocumentUncheckedCreateWithoutSubmissionInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutSubmissionInput>
    createMany?: DocumentCreateManySubmissionInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutSubmissionInput>, Enumerable<DocumentUncheckedCreateWithoutSubmissionInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutSubmissionInput>
    createMany?: DocumentCreateManySubmissionInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type FormDefinitionUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<FormDefinitionCreateWithoutSubmissionsInput, FormDefinitionUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: FormDefinitionCreateOrConnectWithoutSubmissionsInput
    upsert?: FormDefinitionUpsertWithoutSubmissionsInput
    connect?: FormDefinitionWhereUniqueInput
    update?: XOR<FormDefinitionUpdateWithoutSubmissionsInput, FormDefinitionUncheckedUpdateWithoutSubmissionsInput>
  }

  export type DocumentUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutSubmissionInput>, Enumerable<DocumentUncheckedCreateWithoutSubmissionInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutSubmissionInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutSubmissionInput>
    createMany?: DocumentCreateManySubmissionInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutSubmissionInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutSubmissionInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutSubmissionInput>, Enumerable<DocumentUncheckedCreateWithoutSubmissionInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutSubmissionInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutSubmissionInput>
    createMany?: DocumentCreateManySubmissionInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutSubmissionInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutSubmissionInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type FormSubmissionCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<FormSubmissionCreateWithoutDocumentsInput, FormSubmissionUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutDocumentsInput
    connect?: FormSubmissionWhereUniqueInput
  }

  export type FormSubmissionUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutDocumentsInput, FormSubmissionUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutDocumentsInput
    upsert?: FormSubmissionUpsertWithoutDocumentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: FormSubmissionWhereUniqueInput
    update?: XOR<FormSubmissionUpdateWithoutDocumentsInput, FormSubmissionUncheckedUpdateWithoutDocumentsInput>
  }

  export type EquipmentAssignmentCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<Enumerable<EquipmentAssignmentCreateWithoutEquipmentInput>, Enumerable<EquipmentAssignmentUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<EquipmentAssignmentCreateOrConnectWithoutEquipmentInput>
    createMany?: EquipmentAssignmentCreateManyEquipmentInputEnvelope
    connect?: Enumerable<EquipmentAssignmentWhereUniqueInput>
  }

  export type EquipmentAssignmentUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<Enumerable<EquipmentAssignmentCreateWithoutEquipmentInput>, Enumerable<EquipmentAssignmentUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<EquipmentAssignmentCreateOrConnectWithoutEquipmentInput>
    createMany?: EquipmentAssignmentCreateManyEquipmentInputEnvelope
    connect?: Enumerable<EquipmentAssignmentWhereUniqueInput>
  }

  export type EquipmentAssignmentUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<Enumerable<EquipmentAssignmentCreateWithoutEquipmentInput>, Enumerable<EquipmentAssignmentUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<EquipmentAssignmentCreateOrConnectWithoutEquipmentInput>
    upsert?: Enumerable<EquipmentAssignmentUpsertWithWhereUniqueWithoutEquipmentInput>
    createMany?: EquipmentAssignmentCreateManyEquipmentInputEnvelope
    set?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    disconnect?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    delete?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    connect?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    update?: Enumerable<EquipmentAssignmentUpdateWithWhereUniqueWithoutEquipmentInput>
    updateMany?: Enumerable<EquipmentAssignmentUpdateManyWithWhereWithoutEquipmentInput>
    deleteMany?: Enumerable<EquipmentAssignmentScalarWhereInput>
  }

  export type EquipmentAssignmentUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<Enumerable<EquipmentAssignmentCreateWithoutEquipmentInput>, Enumerable<EquipmentAssignmentUncheckedCreateWithoutEquipmentInput>>
    connectOrCreate?: Enumerable<EquipmentAssignmentCreateOrConnectWithoutEquipmentInput>
    upsert?: Enumerable<EquipmentAssignmentUpsertWithWhereUniqueWithoutEquipmentInput>
    createMany?: EquipmentAssignmentCreateManyEquipmentInputEnvelope
    set?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    disconnect?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    delete?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    connect?: Enumerable<EquipmentAssignmentWhereUniqueInput>
    update?: Enumerable<EquipmentAssignmentUpdateWithWhereUniqueWithoutEquipmentInput>
    updateMany?: Enumerable<EquipmentAssignmentUpdateManyWithWhereWithoutEquipmentInput>
    deleteMany?: Enumerable<EquipmentAssignmentScalarWhereInput>
  }

  export type EquipmentItemCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<EquipmentItemCreateWithoutAssignmentsInput, EquipmentItemUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: EquipmentItemCreateOrConnectWithoutAssignmentsInput
    connect?: EquipmentItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<UserCreateWithoutAssignmentsInput, UserUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type EquipmentItemUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<EquipmentItemCreateWithoutAssignmentsInput, EquipmentItemUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: EquipmentItemCreateOrConnectWithoutAssignmentsInput
    upsert?: EquipmentItemUpsertWithoutAssignmentsInput
    connect?: EquipmentItemWhereUniqueInput
    update?: XOR<EquipmentItemUpdateWithoutAssignmentsInput, EquipmentItemUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutAssignmentsInput, UserUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentsInput
    upsert?: UserUpsertWithoutAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAssignmentsInput, UserUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<CommentCreateWithoutPostInput>, Enumerable<CommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutPostInput>
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<CommentCreateWithoutPostInput>, Enumerable<CommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutPostInput>
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutPostInput>, Enumerable<CommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutPostInput>
    createMany?: CommentCreateManyPostInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutPostInput>, Enumerable<CommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutPostInput>
    createMany?: CommentCreateManyPostInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserCreateNestedOneWithoutSocialPostsInput = {
    create?: XOR<UserCreateWithoutSocialPostsInput, UserUncheckedCreateWithoutSocialPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialPostsInput
    connect?: UserWhereUniqueInput
  }

  export type PostCommentCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutPostInput>, Enumerable<PostCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutPostInput>
    createMany?: PostCommentCreateManyPostInputEnvelope
    connect?: Enumerable<PostCommentWhereUniqueInput>
  }

  export type PostCommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutPostInput>, Enumerable<PostCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutPostInput>
    createMany?: PostCommentCreateManyPostInputEnvelope
    connect?: Enumerable<PostCommentWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutSocialPostsNestedInput = {
    create?: XOR<UserCreateWithoutSocialPostsInput, UserUncheckedCreateWithoutSocialPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialPostsInput
    upsert?: UserUpsertWithoutSocialPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSocialPostsInput, UserUncheckedUpdateWithoutSocialPostsInput>
  }

  export type PostCommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutPostInput>, Enumerable<PostCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<PostCommentUpsertWithWhereUniqueWithoutPostInput>
    createMany?: PostCommentCreateManyPostInputEnvelope
    set?: Enumerable<PostCommentWhereUniqueInput>
    disconnect?: Enumerable<PostCommentWhereUniqueInput>
    delete?: Enumerable<PostCommentWhereUniqueInput>
    connect?: Enumerable<PostCommentWhereUniqueInput>
    update?: Enumerable<PostCommentUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<PostCommentUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<PostCommentScalarWhereInput>
  }

  export type PostCommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutPostInput>, Enumerable<PostCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<PostCommentUpsertWithWhereUniqueWithoutPostInput>
    createMany?: PostCommentCreateManyPostInputEnvelope
    set?: Enumerable<PostCommentWhereUniqueInput>
    disconnect?: Enumerable<PostCommentWhereUniqueInput>
    delete?: Enumerable<PostCommentWhereUniqueInput>
    connect?: Enumerable<PostCommentWhereUniqueInput>
    update?: Enumerable<PostCommentUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<PostCommentUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<PostCommentScalarWhereInput>
  }

  export type SocialPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<SocialPostCreateWithoutCommentsInput, SocialPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: SocialPostCreateOrConnectWithoutCommentsInput
    connect?: SocialPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPostCommentsInput = {
    create?: XOR<UserCreateWithoutPostCommentsInput, UserUncheckedCreateWithoutPostCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type SocialPostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<SocialPostCreateWithoutCommentsInput, SocialPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: SocialPostCreateOrConnectWithoutCommentsInput
    upsert?: SocialPostUpsertWithoutCommentsInput
    connect?: SocialPostWhereUniqueInput
    update?: XOR<SocialPostUpdateWithoutCommentsInput, SocialPostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutPostCommentsNestedInput = {
    create?: XOR<UserCreateWithoutPostCommentsInput, UserUncheckedCreateWithoutPostCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostCommentsInput
    upsert?: UserUpsertWithoutPostCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPostCommentsInput, UserUncheckedUpdateWithoutPostCommentsInput>
  }

  export type EventRegistrationCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<EventRegistrationCreateWithoutEventInput>, Enumerable<EventRegistrationUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<EventRegistrationCreateOrConnectWithoutEventInput>
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    connect?: Enumerable<EventRegistrationWhereUniqueInput>
  }

  export type EventRegistrationUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<EventRegistrationCreateWithoutEventInput>, Enumerable<EventRegistrationUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<EventRegistrationCreateOrConnectWithoutEventInput>
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    connect?: Enumerable<EventRegistrationWhereUniqueInput>
  }

  export type EventRegistrationUpdateManyWithoutEventNestedInput = {
    create?: XOR<Enumerable<EventRegistrationCreateWithoutEventInput>, Enumerable<EventRegistrationUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<EventRegistrationCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<EventRegistrationUpsertWithWhereUniqueWithoutEventInput>
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    set?: Enumerable<EventRegistrationWhereUniqueInput>
    disconnect?: Enumerable<EventRegistrationWhereUniqueInput>
    delete?: Enumerable<EventRegistrationWhereUniqueInput>
    connect?: Enumerable<EventRegistrationWhereUniqueInput>
    update?: Enumerable<EventRegistrationUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<EventRegistrationUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<EventRegistrationScalarWhereInput>
  }

  export type EventRegistrationUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<Enumerable<EventRegistrationCreateWithoutEventInput>, Enumerable<EventRegistrationUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<EventRegistrationCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<EventRegistrationUpsertWithWhereUniqueWithoutEventInput>
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    set?: Enumerable<EventRegistrationWhereUniqueInput>
    disconnect?: Enumerable<EventRegistrationWhereUniqueInput>
    delete?: Enumerable<EventRegistrationWhereUniqueInput>
    connect?: Enumerable<EventRegistrationWhereUniqueInput>
    update?: Enumerable<EventRegistrationUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<EventRegistrationUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<EventRegistrationScalarWhereInput>
  }

  export type EventCreateNestedOneWithoutRegistrationsInput = {
    create?: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: EventCreateOrConnectWithoutRegistrationsInput
    connect?: EventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventRegistrationsInput = {
    create?: XOR<UserCreateWithoutEventRegistrationsInput, UserUncheckedCreateWithoutEventRegistrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventRegistrationsInput
    connect?: UserWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutRegistrationsNestedInput = {
    create?: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: EventCreateOrConnectWithoutRegistrationsInput
    upsert?: EventUpsertWithoutRegistrationsInput
    connect?: EventWhereUniqueInput
    update?: XOR<EventUpdateWithoutRegistrationsInput, EventUncheckedUpdateWithoutRegistrationsInput>
  }

  export type UserUpdateOneRequiredWithoutEventRegistrationsNestedInput = {
    create?: XOR<UserCreateWithoutEventRegistrationsInput, UserUncheckedCreateWithoutEventRegistrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventRegistrationsInput
    upsert?: UserUpsertWithoutEventRegistrationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutEventRegistrationsInput, UserUncheckedUpdateWithoutEventRegistrationsInput>
  }

  export type UserCreateNestedOneWithoutForumThreadsInput = {
    create?: XOR<UserCreateWithoutForumThreadsInput, UserUncheckedCreateWithoutForumThreadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumThreadsInput
    connect?: UserWhereUniqueInput
  }

  export type ForumPostCreateNestedManyWithoutThreadInput = {
    create?: XOR<Enumerable<ForumPostCreateWithoutThreadInput>, Enumerable<ForumPostUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<ForumPostCreateOrConnectWithoutThreadInput>
    createMany?: ForumPostCreateManyThreadInputEnvelope
    connect?: Enumerable<ForumPostWhereUniqueInput>
  }

  export type ForumPostUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<Enumerable<ForumPostCreateWithoutThreadInput>, Enumerable<ForumPostUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<ForumPostCreateOrConnectWithoutThreadInput>
    createMany?: ForumPostCreateManyThreadInputEnvelope
    connect?: Enumerable<ForumPostWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutForumThreadsNestedInput = {
    create?: XOR<UserCreateWithoutForumThreadsInput, UserUncheckedCreateWithoutForumThreadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumThreadsInput
    upsert?: UserUpsertWithoutForumThreadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutForumThreadsInput, UserUncheckedUpdateWithoutForumThreadsInput>
  }

  export type ForumPostUpdateManyWithoutThreadNestedInput = {
    create?: XOR<Enumerable<ForumPostCreateWithoutThreadInput>, Enumerable<ForumPostUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<ForumPostCreateOrConnectWithoutThreadInput>
    upsert?: Enumerable<ForumPostUpsertWithWhereUniqueWithoutThreadInput>
    createMany?: ForumPostCreateManyThreadInputEnvelope
    set?: Enumerable<ForumPostWhereUniqueInput>
    disconnect?: Enumerable<ForumPostWhereUniqueInput>
    delete?: Enumerable<ForumPostWhereUniqueInput>
    connect?: Enumerable<ForumPostWhereUniqueInput>
    update?: Enumerable<ForumPostUpdateWithWhereUniqueWithoutThreadInput>
    updateMany?: Enumerable<ForumPostUpdateManyWithWhereWithoutThreadInput>
    deleteMany?: Enumerable<ForumPostScalarWhereInput>
  }

  export type ForumPostUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<Enumerable<ForumPostCreateWithoutThreadInput>, Enumerable<ForumPostUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<ForumPostCreateOrConnectWithoutThreadInput>
    upsert?: Enumerable<ForumPostUpsertWithWhereUniqueWithoutThreadInput>
    createMany?: ForumPostCreateManyThreadInputEnvelope
    set?: Enumerable<ForumPostWhereUniqueInput>
    disconnect?: Enumerable<ForumPostWhereUniqueInput>
    delete?: Enumerable<ForumPostWhereUniqueInput>
    connect?: Enumerable<ForumPostWhereUniqueInput>
    update?: Enumerable<ForumPostUpdateWithWhereUniqueWithoutThreadInput>
    updateMany?: Enumerable<ForumPostUpdateManyWithWhereWithoutThreadInput>
    deleteMany?: Enumerable<ForumPostScalarWhereInput>
  }

  export type ForumThreadCreateNestedOneWithoutPostsInput = {
    create?: XOR<ForumThreadCreateWithoutPostsInput, ForumThreadUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ForumThreadCreateOrConnectWithoutPostsInput
    connect?: ForumThreadWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutForumPostsInput = {
    create?: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumPostsInput
    connect?: UserWhereUniqueInput
  }

  export type ForumThreadUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<ForumThreadCreateWithoutPostsInput, ForumThreadUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ForumThreadCreateOrConnectWithoutPostsInput
    upsert?: ForumThreadUpsertWithoutPostsInput
    connect?: ForumThreadWhereUniqueInput
    update?: XOR<ForumThreadUpdateWithoutPostsInput, ForumThreadUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateOneRequiredWithoutForumPostsNestedInput = {
    create?: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumPostsInput
    upsert?: UserUpsertWithoutForumPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutForumPostsInput, UserUncheckedUpdateWithoutForumPostsInput>
  }

  export type UserCreateNestedOneWithoutBenefitClaimsInput = {
    create?: XOR<UserCreateWithoutBenefitClaimsInput, UserUncheckedCreateWithoutBenefitClaimsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBenefitClaimsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutBenefitClaimsNestedInput = {
    create?: XOR<UserCreateWithoutBenefitClaimsInput, UserUncheckedCreateWithoutBenefitClaimsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBenefitClaimsInput
    upsert?: UserUpsertWithoutBenefitClaimsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBenefitClaimsInput, UserUncheckedUpdateWithoutBenefitClaimsInput>
  }

  export type UserCreateNestedOneWithoutPayrollRecordsInput = {
    create?: XOR<UserCreateWithoutPayrollRecordsInput, UserUncheckedCreateWithoutPayrollRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPayrollRecordsNestedInput = {
    create?: XOR<UserCreateWithoutPayrollRecordsInput, UserUncheckedCreateWithoutPayrollRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollRecordsInput
    upsert?: UserUpsertWithoutPayrollRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPayrollRecordsInput, UserUncheckedUpdateWithoutPayrollRecordsInput>
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    upsert?: ServiceUpsertWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type UserCreateNestedOneWithoutTwoFactorAuthInput = {
    create?: XOR<UserCreateWithoutTwoFactorAuthInput, UserUncheckedCreateWithoutTwoFactorAuthInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFactorAuthInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTwoFactorAuthNestedInput = {
    create?: XOR<UserCreateWithoutTwoFactorAuthInput, UserUncheckedCreateWithoutTwoFactorAuthInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFactorAuthInput
    upsert?: UserUpsertWithoutTwoFactorAuthInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTwoFactorAuthInput, UserUncheckedUpdateWithoutTwoFactorAuthInput>
  }

  export type WebAuthnCredentialCreatetransportsInput = {
    set: Enumerable<string>
  }

  export type UserCreateNestedOneWithoutWebAuthnCredentialsInput = {
    create?: XOR<UserCreateWithoutWebAuthnCredentialsInput, UserUncheckedCreateWithoutWebAuthnCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWebAuthnCredentialsInput
    connect?: UserWhereUniqueInput
  }

  export type WebAuthnCredentialUpdatetransportsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type UserUpdateOneRequiredWithoutWebAuthnCredentialsNestedInput = {
    create?: XOR<UserCreateWithoutWebAuthnCredentialsInput, UserUncheckedCreateWithoutWebAuthnCredentialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWebAuthnCredentialsInput
    upsert?: UserUpsertWithoutWebAuthnCredentialsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutWebAuthnCredentialsInput, UserUncheckedUpdateWithoutWebAuthnCredentialsInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedEnumTransactionTypeFilter = {
    equals?: TransactionType
    in?: Enumerable<TransactionType>
    notIn?: Enumerable<TransactionType>
    not?: NestedEnumTransactionTypeFilter | TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter = {
    equals?: TransactionType
    in?: Enumerable<TransactionType>
    notIn?: Enumerable<TransactionType>
    not?: NestedEnumTransactionTypeWithAggregatesFilter | TransactionType
    _count?: NestedIntFilter
    _min?: NestedEnumTransactionTypeFilter
    _max?: NestedEnumTransactionTypeFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type LoyaltyTransactionCreateWithoutUserInput = {
    id?: string
    points: number
    type: TransactionType
    createdAt?: Date | string
    tier?: LoyaltyTierCreateNestedOneWithoutTransactionsInput
  }

  export type LoyaltyTransactionUncheckedCreateWithoutUserInput = {
    id?: string
    tierId?: string | null
    points: number
    type: TransactionType
    createdAt?: Date | string
  }

  export type LoyaltyTransactionCreateOrConnectWithoutUserInput = {
    where: LoyaltyTransactionWhereUniqueInput
    create: XOR<LoyaltyTransactionCreateWithoutUserInput, LoyaltyTransactionUncheckedCreateWithoutUserInput>
  }

  export type LoyaltyTransactionCreateManyUserInputEnvelope = {
    data: Enumerable<LoyaltyTransactionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    stripeSubscriptionId: string
    priceId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    stripeSubscriptionId: string
    priceId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateManyUserInputEnvelope = {
    data: Enumerable<SubscriptionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutReferralsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
  }

  export type UserCreateWithoutReferredByInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferredByInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferredByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
  }

  export type UserCreateManyReferredByInputEnvelope = {
    data: Enumerable<UserCreateManyReferredByInput>
    skipDuplicates?: boolean
  }

  export type AnalyticsEventCreateWithoutUserInput = {
    id?: string
    event: string
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsEventUncheckedCreateWithoutUserInput = {
    id?: string
    event: string
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsEventCreateOrConnectWithoutUserInput = {
    where: AnalyticsEventWhereUniqueInput
    create: XOR<AnalyticsEventCreateWithoutUserInput, AnalyticsEventUncheckedCreateWithoutUserInput>
  }

  export type AnalyticsEventCreateManyUserInputEnvelope = {
    data: Enumerable<AnalyticsEventCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type PaymentTransactionCreateWithoutUserInput = {
    id?: string
    amount: number
    currency: string
    mode: string
    createdAt?: Date | string
    service?: ServiceCreateNestedOneWithoutPaymentTransactionsInput
  }

  export type PaymentTransactionUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    currency: string
    mode: string
    createdAt?: Date | string
    serviceId?: string | null
  }

  export type PaymentTransactionCreateOrConnectWithoutUserInput = {
    where: PaymentTransactionWhereUniqueInput
    create: XOR<PaymentTransactionCreateWithoutUserInput, PaymentTransactionUncheckedCreateWithoutUserInput>
  }

  export type PaymentTransactionCreateManyUserInputEnvelope = {
    data: Enumerable<PaymentTransactionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type TrainingProgressCreateWithoutUserInput = {
    id?: string
    completedAt?: Date | string
    module: TrainingModuleCreateNestedOneWithoutTrainingProgressInput
  }

  export type TrainingProgressUncheckedCreateWithoutUserInput = {
    id?: string
    moduleId: string
    completedAt?: Date | string
  }

  export type TrainingProgressCreateOrConnectWithoutUserInput = {
    where: TrainingProgressWhereUniqueInput
    create: XOR<TrainingProgressCreateWithoutUserInput, TrainingProgressUncheckedCreateWithoutUserInput>
  }

  export type TrainingProgressCreateManyUserInputEnvelope = {
    data: Enumerable<TrainingProgressCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type GoogleCalendarTokenCreateWithoutUserInput = {
    id?: string
    accessToken: string
    refreshToken: string
    scope?: string | null
    tokenType?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoogleCalendarTokenUncheckedCreateWithoutUserInput = {
    id?: string
    accessToken: string
    refreshToken: string
    scope?: string | null
    tokenType?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoogleCalendarTokenCreateOrConnectWithoutUserInput = {
    where: GoogleCalendarTokenWhereUniqueInput
    create: XOR<GoogleCalendarTokenCreateWithoutUserInput, GoogleCalendarTokenUncheckedCreateWithoutUserInput>
  }

  export type OutlookCalendarTokenCreateWithoutUserInput = {
    id?: string
    accessToken: string
    refreshToken: string
    scope?: string | null
    tokenType?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutlookCalendarTokenUncheckedCreateWithoutUserInput = {
    id?: string
    accessToken: string
    refreshToken: string
    scope?: string | null
    tokenType?: string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutlookCalendarTokenCreateOrConnectWithoutUserInput = {
    where: OutlookCalendarTokenWhereUniqueInput
    create: XOR<OutlookCalendarTokenCreateWithoutUserInput, OutlookCalendarTokenUncheckedCreateWithoutUserInput>
  }

  export type EquipmentAssignmentCreateWithoutAssignedToUserInput = {
    id?: string
    assignedAt?: Date | string
    returnedAt?: Date | string | null
    equipment: EquipmentItemCreateNestedOneWithoutAssignmentsInput
  }

  export type EquipmentAssignmentUncheckedCreateWithoutAssignedToUserInput = {
    id?: string
    equipmentId: string
    assignedAt?: Date | string
    returnedAt?: Date | string | null
  }

  export type EquipmentAssignmentCreateOrConnectWithoutAssignedToUserInput = {
    where: EquipmentAssignmentWhereUniqueInput
    create: XOR<EquipmentAssignmentCreateWithoutAssignedToUserInput, EquipmentAssignmentUncheckedCreateWithoutAssignedToUserInput>
  }

  export type EquipmentAssignmentCreateManyAssignedToUserInputEnvelope = {
    data: Enumerable<EquipmentAssignmentCreateManyAssignedToUserInput>
    skipDuplicates?: boolean
  }

  export type SocialPostCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: PostCommentCreateNestedManyWithoutPostInput
  }

  export type SocialPostUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: PostCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type SocialPostCreateOrConnectWithoutAuthorInput = {
    where: SocialPostWhereUniqueInput
    create: XOR<SocialPostCreateWithoutAuthorInput, SocialPostUncheckedCreateWithoutAuthorInput>
  }

  export type SocialPostCreateManyAuthorInputEnvelope = {
    data: Enumerable<SocialPostCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type PostCommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    post: SocialPostCreateNestedOneWithoutCommentsInput
  }

  export type PostCommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    postId: string
    content: string
    createdAt?: Date | string
  }

  export type PostCommentCreateOrConnectWithoutAuthorInput = {
    where: PostCommentWhereUniqueInput
    create: XOR<PostCommentCreateWithoutAuthorInput, PostCommentUncheckedCreateWithoutAuthorInput>
  }

  export type PostCommentCreateManyAuthorInputEnvelope = {
    data: Enumerable<PostCommentCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type EventRegistrationCreateWithoutUserInput = {
    id?: string
    registeredAt?: Date | string
    event: EventCreateNestedOneWithoutRegistrationsInput
  }

  export type EventRegistrationUncheckedCreateWithoutUserInput = {
    id?: string
    eventId: string
    registeredAt?: Date | string
  }

  export type EventRegistrationCreateOrConnectWithoutUserInput = {
    where: EventRegistrationWhereUniqueInput
    create: XOR<EventRegistrationCreateWithoutUserInput, EventRegistrationUncheckedCreateWithoutUserInput>
  }

  export type EventRegistrationCreateManyUserInputEnvelope = {
    data: Enumerable<EventRegistrationCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ForumThreadCreateWithoutAuthorInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: ForumPostCreateNestedManyWithoutThreadInput
  }

  export type ForumThreadUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: ForumPostUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ForumThreadCreateOrConnectWithoutAuthorInput = {
    where: ForumThreadWhereUniqueInput
    create: XOR<ForumThreadCreateWithoutAuthorInput, ForumThreadUncheckedCreateWithoutAuthorInput>
  }

  export type ForumThreadCreateManyAuthorInputEnvelope = {
    data: Enumerable<ForumThreadCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type ForumPostCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    thread: ForumThreadCreateNestedOneWithoutPostsInput
  }

  export type ForumPostUncheckedCreateWithoutAuthorInput = {
    id?: string
    threadId: string
    content: string
    createdAt?: Date | string
  }

  export type ForumPostCreateOrConnectWithoutAuthorInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutAuthorInput, ForumPostUncheckedCreateWithoutAuthorInput>
  }

  export type ForumPostCreateManyAuthorInputEnvelope = {
    data: Enumerable<ForumPostCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type BenefitClaimCreateWithoutUserInput = {
    id?: string
    type: string
    status: string
    amount?: number | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type BenefitClaimUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    status: string
    amount?: number | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type BenefitClaimCreateOrConnectWithoutUserInput = {
    where: BenefitClaimWhereUniqueInput
    create: XOR<BenefitClaimCreateWithoutUserInput, BenefitClaimUncheckedCreateWithoutUserInput>
  }

  export type BenefitClaimCreateManyUserInputEnvelope = {
    data: Enumerable<BenefitClaimCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type PayrollRecordCreateWithoutUserInput = {
    id?: string
    salary: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollRecordUncheckedCreateWithoutUserInput = {
    id?: string
    salary: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollRecordCreateOrConnectWithoutUserInput = {
    where: PayrollRecordWhereUniqueInput
    create: XOR<PayrollRecordCreateWithoutUserInput, PayrollRecordUncheckedCreateWithoutUserInput>
  }

  export type PayrollRecordCreateManyUserInputEnvelope = {
    data: Enumerable<PayrollRecordCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutUserInput = {
    id?: string
    appointmentDate: Date | string
    duration: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    googleEventId?: string | null
    outlookEventId?: string | null
    service: ServiceCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutUserInput = {
    id?: string
    serviceId: string
    appointmentDate: Date | string
    duration: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    googleEventId?: string | null
    outlookEventId?: string | null
  }

  export type BookingCreateOrConnectWithoutUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateManyUserInputEnvelope = {
    data: Enumerable<BookingCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: Enumerable<PostCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    postId: string
    content: string
    createdAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: Enumerable<CommentCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type TwoFactorAuthCreateWithoutUserInput = {
    id?: string
    secret: string
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAuthUncheckedCreateWithoutUserInput = {
    id?: string
    secret: string
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAuthCreateOrConnectWithoutUserInput = {
    where: TwoFactorAuthWhereUniqueInput
    create: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput>
  }

  export type WebAuthnCredentialCreateWithoutUserInput = {
    id?: string
    credentialId: string
    publicKey: string
    counter: number
    transports?: WebAuthnCredentialCreatetransportsInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebAuthnCredentialUncheckedCreateWithoutUserInput = {
    id?: string
    credentialId: string
    publicKey: string
    counter: number
    transports?: WebAuthnCredentialCreatetransportsInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebAuthnCredentialCreateOrConnectWithoutUserInput = {
    where: WebAuthnCredentialWhereUniqueInput
    create: XOR<WebAuthnCredentialCreateWithoutUserInput, WebAuthnCredentialUncheckedCreateWithoutUserInput>
  }

  export type WebAuthnCredentialCreateManyUserInputEnvelope = {
    data: Enumerable<WebAuthnCredentialCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type LoyaltyTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: LoyaltyTransactionWhereUniqueInput
    update: XOR<LoyaltyTransactionUpdateWithoutUserInput, LoyaltyTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<LoyaltyTransactionCreateWithoutUserInput, LoyaltyTransactionUncheckedCreateWithoutUserInput>
  }

  export type LoyaltyTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: LoyaltyTransactionWhereUniqueInput
    data: XOR<LoyaltyTransactionUpdateWithoutUserInput, LoyaltyTransactionUncheckedUpdateWithoutUserInput>
  }

  export type LoyaltyTransactionUpdateManyWithWhereWithoutUserInput = {
    where: LoyaltyTransactionScalarWhereInput
    data: XOR<LoyaltyTransactionUpdateManyMutationInput, LoyaltyTransactionUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type LoyaltyTransactionScalarWhereInput = {
    AND?: Enumerable<LoyaltyTransactionScalarWhereInput>
    OR?: Enumerable<LoyaltyTransactionScalarWhereInput>
    NOT?: Enumerable<LoyaltyTransactionScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    tierId?: StringNullableFilter | string | null
    points?: IntFilter | number
    type?: EnumTransactionTypeFilter | TransactionType
    createdAt?: DateTimeFilter | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutSubscriptionsInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: Enumerable<SubscriptionScalarWhereInput>
    OR?: Enumerable<SubscriptionScalarWhereInput>
    NOT?: Enumerable<SubscriptionScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    stripeSubscriptionId?: StringFilter | string
    priceId?: StringFilter | string
    status?: StringFilter | string
    currentPeriodStart?: DateTimeFilter | Date | string
    currentPeriodEnd?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserUpsertWithoutReferralsInput = {
    update: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
  }

  export type UserUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutReferredByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutReferredByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
  }

  export type UserUpdateManyWithWhereWithoutReferredByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutReferralsInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    auth0Id?: StringNullableFilter | string | null
    email?: StringFilter | string
    name?: StringNullableFilter | string | null
    avatar?: StringNullableFilter | string | null
    role?: EnumRoleFilter | Role
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    pushTokens?: JsonFilter
    notificationSettings?: JsonFilter
    referralCode?: StringFilter | string
    referredById?: StringNullableFilter | string | null
  }

  export type AnalyticsEventUpsertWithWhereUniqueWithoutUserInput = {
    where: AnalyticsEventWhereUniqueInput
    update: XOR<AnalyticsEventUpdateWithoutUserInput, AnalyticsEventUncheckedUpdateWithoutUserInput>
    create: XOR<AnalyticsEventCreateWithoutUserInput, AnalyticsEventUncheckedCreateWithoutUserInput>
  }

  export type AnalyticsEventUpdateWithWhereUniqueWithoutUserInput = {
    where: AnalyticsEventWhereUniqueInput
    data: XOR<AnalyticsEventUpdateWithoutUserInput, AnalyticsEventUncheckedUpdateWithoutUserInput>
  }

  export type AnalyticsEventUpdateManyWithWhereWithoutUserInput = {
    where: AnalyticsEventScalarWhereInput
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyWithoutAnalyticsEventsInput>
  }

  export type AnalyticsEventScalarWhereInput = {
    AND?: Enumerable<AnalyticsEventScalarWhereInput>
    OR?: Enumerable<AnalyticsEventScalarWhereInput>
    NOT?: Enumerable<AnalyticsEventScalarWhereInput>
    id?: StringFilter | string
    userId?: StringNullableFilter | string | null
    event?: StringFilter | string
    properties?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
  }

  export type PaymentTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentTransactionWhereUniqueInput
    update: XOR<PaymentTransactionUpdateWithoutUserInput, PaymentTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentTransactionCreateWithoutUserInput, PaymentTransactionUncheckedCreateWithoutUserInput>
  }

  export type PaymentTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentTransactionWhereUniqueInput
    data: XOR<PaymentTransactionUpdateWithoutUserInput, PaymentTransactionUncheckedUpdateWithoutUserInput>
  }

  export type PaymentTransactionUpdateManyWithWhereWithoutUserInput = {
    where: PaymentTransactionScalarWhereInput
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyWithoutPaymentTransactionsInput>
  }

  export type PaymentTransactionScalarWhereInput = {
    AND?: Enumerable<PaymentTransactionScalarWhereInput>
    OR?: Enumerable<PaymentTransactionScalarWhereInput>
    NOT?: Enumerable<PaymentTransactionScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    amount?: IntFilter | number
    currency?: StringFilter | string
    mode?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    serviceId?: StringNullableFilter | string | null
  }

  export type TrainingProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: TrainingProgressWhereUniqueInput
    update: XOR<TrainingProgressUpdateWithoutUserInput, TrainingProgressUncheckedUpdateWithoutUserInput>
    create: XOR<TrainingProgressCreateWithoutUserInput, TrainingProgressUncheckedCreateWithoutUserInput>
  }

  export type TrainingProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: TrainingProgressWhereUniqueInput
    data: XOR<TrainingProgressUpdateWithoutUserInput, TrainingProgressUncheckedUpdateWithoutUserInput>
  }

  export type TrainingProgressUpdateManyWithWhereWithoutUserInput = {
    where: TrainingProgressScalarWhereInput
    data: XOR<TrainingProgressUpdateManyMutationInput, TrainingProgressUncheckedUpdateManyWithoutTrainingProgressInput>
  }

  export type TrainingProgressScalarWhereInput = {
    AND?: Enumerable<TrainingProgressScalarWhereInput>
    OR?: Enumerable<TrainingProgressScalarWhereInput>
    NOT?: Enumerable<TrainingProgressScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    moduleId?: StringFilter | string
    completedAt?: DateTimeFilter | Date | string
  }

  export type GoogleCalendarTokenUpsertWithoutUserInput = {
    update: XOR<GoogleCalendarTokenUpdateWithoutUserInput, GoogleCalendarTokenUncheckedUpdateWithoutUserInput>
    create: XOR<GoogleCalendarTokenCreateWithoutUserInput, GoogleCalendarTokenUncheckedCreateWithoutUserInput>
  }

  export type GoogleCalendarTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoogleCalendarTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutlookCalendarTokenUpsertWithoutUserInput = {
    update: XOR<OutlookCalendarTokenUpdateWithoutUserInput, OutlookCalendarTokenUncheckedUpdateWithoutUserInput>
    create: XOR<OutlookCalendarTokenCreateWithoutUserInput, OutlookCalendarTokenUncheckedCreateWithoutUserInput>
  }

  export type OutlookCalendarTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutlookCalendarTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentAssignmentUpsertWithWhereUniqueWithoutAssignedToUserInput = {
    where: EquipmentAssignmentWhereUniqueInput
    update: XOR<EquipmentAssignmentUpdateWithoutAssignedToUserInput, EquipmentAssignmentUncheckedUpdateWithoutAssignedToUserInput>
    create: XOR<EquipmentAssignmentCreateWithoutAssignedToUserInput, EquipmentAssignmentUncheckedCreateWithoutAssignedToUserInput>
  }

  export type EquipmentAssignmentUpdateWithWhereUniqueWithoutAssignedToUserInput = {
    where: EquipmentAssignmentWhereUniqueInput
    data: XOR<EquipmentAssignmentUpdateWithoutAssignedToUserInput, EquipmentAssignmentUncheckedUpdateWithoutAssignedToUserInput>
  }

  export type EquipmentAssignmentUpdateManyWithWhereWithoutAssignedToUserInput = {
    where: EquipmentAssignmentScalarWhereInput
    data: XOR<EquipmentAssignmentUpdateManyMutationInput, EquipmentAssignmentUncheckedUpdateManyWithoutAssignmentsInput>
  }

  export type EquipmentAssignmentScalarWhereInput = {
    AND?: Enumerable<EquipmentAssignmentScalarWhereInput>
    OR?: Enumerable<EquipmentAssignmentScalarWhereInput>
    NOT?: Enumerable<EquipmentAssignmentScalarWhereInput>
    id?: StringFilter | string
    equipmentId?: StringFilter | string
    assignedTo?: StringFilter | string
    assignedAt?: DateTimeFilter | Date | string
    returnedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type SocialPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: SocialPostWhereUniqueInput
    update: XOR<SocialPostUpdateWithoutAuthorInput, SocialPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<SocialPostCreateWithoutAuthorInput, SocialPostUncheckedCreateWithoutAuthorInput>
  }

  export type SocialPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: SocialPostWhereUniqueInput
    data: XOR<SocialPostUpdateWithoutAuthorInput, SocialPostUncheckedUpdateWithoutAuthorInput>
  }

  export type SocialPostUpdateManyWithWhereWithoutAuthorInput = {
    where: SocialPostScalarWhereInput
    data: XOR<SocialPostUpdateManyMutationInput, SocialPostUncheckedUpdateManyWithoutSocialPostsInput>
  }

  export type SocialPostScalarWhereInput = {
    AND?: Enumerable<SocialPostScalarWhereInput>
    OR?: Enumerable<SocialPostScalarWhereInput>
    NOT?: Enumerable<SocialPostScalarWhereInput>
    id?: StringFilter | string
    authorId?: StringFilter | string
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PostCommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostCommentWhereUniqueInput
    update: XOR<PostCommentUpdateWithoutAuthorInput, PostCommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCommentCreateWithoutAuthorInput, PostCommentUncheckedCreateWithoutAuthorInput>
  }

  export type PostCommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostCommentWhereUniqueInput
    data: XOR<PostCommentUpdateWithoutAuthorInput, PostCommentUncheckedUpdateWithoutAuthorInput>
  }

  export type PostCommentUpdateManyWithWhereWithoutAuthorInput = {
    where: PostCommentScalarWhereInput
    data: XOR<PostCommentUpdateManyMutationInput, PostCommentUncheckedUpdateManyWithoutPostCommentsInput>
  }

  export type PostCommentScalarWhereInput = {
    AND?: Enumerable<PostCommentScalarWhereInput>
    OR?: Enumerable<PostCommentScalarWhereInput>
    NOT?: Enumerable<PostCommentScalarWhereInput>
    id?: StringFilter | string
    postId?: StringFilter | string
    authorId?: StringFilter | string
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type EventRegistrationUpsertWithWhereUniqueWithoutUserInput = {
    where: EventRegistrationWhereUniqueInput
    update: XOR<EventRegistrationUpdateWithoutUserInput, EventRegistrationUncheckedUpdateWithoutUserInput>
    create: XOR<EventRegistrationCreateWithoutUserInput, EventRegistrationUncheckedCreateWithoutUserInput>
  }

  export type EventRegistrationUpdateWithWhereUniqueWithoutUserInput = {
    where: EventRegistrationWhereUniqueInput
    data: XOR<EventRegistrationUpdateWithoutUserInput, EventRegistrationUncheckedUpdateWithoutUserInput>
  }

  export type EventRegistrationUpdateManyWithWhereWithoutUserInput = {
    where: EventRegistrationScalarWhereInput
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyWithoutEventRegistrationsInput>
  }

  export type EventRegistrationScalarWhereInput = {
    AND?: Enumerable<EventRegistrationScalarWhereInput>
    OR?: Enumerable<EventRegistrationScalarWhereInput>
    NOT?: Enumerable<EventRegistrationScalarWhereInput>
    id?: StringFilter | string
    eventId?: StringFilter | string
    userId?: StringFilter | string
    registeredAt?: DateTimeFilter | Date | string
  }

  export type ForumThreadUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ForumThreadWhereUniqueInput
    update: XOR<ForumThreadUpdateWithoutAuthorInput, ForumThreadUncheckedUpdateWithoutAuthorInput>
    create: XOR<ForumThreadCreateWithoutAuthorInput, ForumThreadUncheckedCreateWithoutAuthorInput>
  }

  export type ForumThreadUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ForumThreadWhereUniqueInput
    data: XOR<ForumThreadUpdateWithoutAuthorInput, ForumThreadUncheckedUpdateWithoutAuthorInput>
  }

  export type ForumThreadUpdateManyWithWhereWithoutAuthorInput = {
    where: ForumThreadScalarWhereInput
    data: XOR<ForumThreadUpdateManyMutationInput, ForumThreadUncheckedUpdateManyWithoutForumThreadsInput>
  }

  export type ForumThreadScalarWhereInput = {
    AND?: Enumerable<ForumThreadScalarWhereInput>
    OR?: Enumerable<ForumThreadScalarWhereInput>
    NOT?: Enumerable<ForumThreadScalarWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    authorId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ForumPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ForumPostWhereUniqueInput
    update: XOR<ForumPostUpdateWithoutAuthorInput, ForumPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<ForumPostCreateWithoutAuthorInput, ForumPostUncheckedCreateWithoutAuthorInput>
  }

  export type ForumPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ForumPostWhereUniqueInput
    data: XOR<ForumPostUpdateWithoutAuthorInput, ForumPostUncheckedUpdateWithoutAuthorInput>
  }

  export type ForumPostUpdateManyWithWhereWithoutAuthorInput = {
    where: ForumPostScalarWhereInput
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyWithoutForumPostsInput>
  }

  export type ForumPostScalarWhereInput = {
    AND?: Enumerable<ForumPostScalarWhereInput>
    OR?: Enumerable<ForumPostScalarWhereInput>
    NOT?: Enumerable<ForumPostScalarWhereInput>
    id?: StringFilter | string
    threadId?: StringFilter | string
    authorId?: StringFilter | string
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type BenefitClaimUpsertWithWhereUniqueWithoutUserInput = {
    where: BenefitClaimWhereUniqueInput
    update: XOR<BenefitClaimUpdateWithoutUserInput, BenefitClaimUncheckedUpdateWithoutUserInput>
    create: XOR<BenefitClaimCreateWithoutUserInput, BenefitClaimUncheckedCreateWithoutUserInput>
  }

  export type BenefitClaimUpdateWithWhereUniqueWithoutUserInput = {
    where: BenefitClaimWhereUniqueInput
    data: XOR<BenefitClaimUpdateWithoutUserInput, BenefitClaimUncheckedUpdateWithoutUserInput>
  }

  export type BenefitClaimUpdateManyWithWhereWithoutUserInput = {
    where: BenefitClaimScalarWhereInput
    data: XOR<BenefitClaimUpdateManyMutationInput, BenefitClaimUncheckedUpdateManyWithoutBenefitClaimsInput>
  }

  export type BenefitClaimScalarWhereInput = {
    AND?: Enumerable<BenefitClaimScalarWhereInput>
    OR?: Enumerable<BenefitClaimScalarWhereInput>
    NOT?: Enumerable<BenefitClaimScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    type?: StringFilter | string
    status?: StringFilter | string
    amount?: FloatNullableFilter | number | null
    requestedAt?: DateTimeFilter | Date | string
    processedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type PayrollRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: PayrollRecordWhereUniqueInput
    update: XOR<PayrollRecordUpdateWithoutUserInput, PayrollRecordUncheckedUpdateWithoutUserInput>
    create: XOR<PayrollRecordCreateWithoutUserInput, PayrollRecordUncheckedCreateWithoutUserInput>
  }

  export type PayrollRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: PayrollRecordWhereUniqueInput
    data: XOR<PayrollRecordUpdateWithoutUserInput, PayrollRecordUncheckedUpdateWithoutUserInput>
  }

  export type PayrollRecordUpdateManyWithWhereWithoutUserInput = {
    where: PayrollRecordScalarWhereInput
    data: XOR<PayrollRecordUpdateManyMutationInput, PayrollRecordUncheckedUpdateManyWithoutPayrollRecordsInput>
  }

  export type PayrollRecordScalarWhereInput = {
    AND?: Enumerable<PayrollRecordScalarWhereInput>
    OR?: Enumerable<PayrollRecordScalarWhereInput>
    NOT?: Enumerable<PayrollRecordScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    salary?: FloatFilter | number
    periodStart?: DateTimeFilter | Date | string
    periodEnd?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutBookingsInput>
  }

  export type BookingScalarWhereInput = {
    AND?: Enumerable<BookingScalarWhereInput>
    OR?: Enumerable<BookingScalarWhereInput>
    NOT?: Enumerable<BookingScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    serviceId?: StringFilter | string
    appointmentDate?: DateTimeFilter | Date | string
    duration?: IntFilter | number
    specialRequests?: StringNullableFilter | string | null
    status?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    googleEventId?: StringNullableFilter | string | null
    outlookEventId?: StringNullableFilter | string | null
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutPostsInput>
  }

  export type PostScalarWhereInput = {
    AND?: Enumerable<PostScalarWhereInput>
    OR?: Enumerable<PostScalarWhereInput>
    NOT?: Enumerable<PostScalarWhereInput>
    id?: StringFilter | string
    authorId?: StringFilter | string
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type CommentScalarWhereInput = {
    AND?: Enumerable<CommentScalarWhereInput>
    OR?: Enumerable<CommentScalarWhereInput>
    NOT?: Enumerable<CommentScalarWhereInput>
    id?: StringFilter | string
    postId?: StringFilter | string
    authorId?: StringFilter | string
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type TwoFactorAuthUpsertWithoutUserInput = {
    update: XOR<TwoFactorAuthUpdateWithoutUserInput, TwoFactorAuthUncheckedUpdateWithoutUserInput>
    create: XOR<TwoFactorAuthCreateWithoutUserInput, TwoFactorAuthUncheckedCreateWithoutUserInput>
  }

  export type TwoFactorAuthUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAuthUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebAuthnCredentialUpsertWithWhereUniqueWithoutUserInput = {
    where: WebAuthnCredentialWhereUniqueInput
    update: XOR<WebAuthnCredentialUpdateWithoutUserInput, WebAuthnCredentialUncheckedUpdateWithoutUserInput>
    create: XOR<WebAuthnCredentialCreateWithoutUserInput, WebAuthnCredentialUncheckedCreateWithoutUserInput>
  }

  export type WebAuthnCredentialUpdateWithWhereUniqueWithoutUserInput = {
    where: WebAuthnCredentialWhereUniqueInput
    data: XOR<WebAuthnCredentialUpdateWithoutUserInput, WebAuthnCredentialUncheckedUpdateWithoutUserInput>
  }

  export type WebAuthnCredentialUpdateManyWithWhereWithoutUserInput = {
    where: WebAuthnCredentialScalarWhereInput
    data: XOR<WebAuthnCredentialUpdateManyMutationInput, WebAuthnCredentialUncheckedUpdateManyWithoutWebAuthnCredentialsInput>
  }

  export type WebAuthnCredentialScalarWhereInput = {
    AND?: Enumerable<WebAuthnCredentialScalarWhereInput>
    OR?: Enumerable<WebAuthnCredentialScalarWhereInput>
    NOT?: Enumerable<WebAuthnCredentialScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    credentialId?: StringFilter | string
    publicKey?: StringFilter | string
    counter?: IntFilter | number
    transports?: StringNullableListFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ServiceCreateWithoutProviderInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutServiceInput
    bookings?: BookingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutProviderInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutServiceInput
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutProviderInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutProviderInput, ServiceUncheckedCreateWithoutProviderInput>
  }

  export type ServiceCreateManyProviderInputEnvelope = {
    data: Enumerable<ServiceCreateManyProviderInput>
    skipDuplicates?: boolean
  }

  export type BusinessCreateWithoutProviderInput = {
    id?: string
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hours?: BusinessHourCreateNestedManyWithoutBusinessInput
    staff?: StaffCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutProviderInput = {
    id?: string
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hours?: BusinessHourUncheckedCreateNestedManyWithoutBusinessInput
    staff?: StaffUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutProviderInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutProviderInput, BusinessUncheckedCreateWithoutProviderInput>
  }

  export type BusinessCreateManyProviderInputEnvelope = {
    data: Enumerable<BusinessCreateManyProviderInput>
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutProviderInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutProviderInput, ServiceUncheckedUpdateWithoutProviderInput>
    create: XOR<ServiceCreateWithoutProviderInput, ServiceUncheckedCreateWithoutProviderInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutProviderInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutProviderInput, ServiceUncheckedUpdateWithoutProviderInput>
  }

  export type ServiceUpdateManyWithWhereWithoutProviderInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutServicesInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: Enumerable<ServiceScalarWhereInput>
    OR?: Enumerable<ServiceScalarWhereInput>
    NOT?: Enumerable<ServiceScalarWhereInput>
    id?: StringFilter | string
    providerId?: StringFilter | string
    name?: StringFilter | string
    price?: FloatFilter | number
    duration?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BusinessUpsertWithWhereUniqueWithoutProviderInput = {
    where: BusinessWhereUniqueInput
    update: XOR<BusinessUpdateWithoutProviderInput, BusinessUncheckedUpdateWithoutProviderInput>
    create: XOR<BusinessCreateWithoutProviderInput, BusinessUncheckedCreateWithoutProviderInput>
  }

  export type BusinessUpdateWithWhereUniqueWithoutProviderInput = {
    where: BusinessWhereUniqueInput
    data: XOR<BusinessUpdateWithoutProviderInput, BusinessUncheckedUpdateWithoutProviderInput>
  }

  export type BusinessUpdateManyWithWhereWithoutProviderInput = {
    where: BusinessScalarWhereInput
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyWithoutBusinessesInput>
  }

  export type BusinessScalarWhereInput = {
    AND?: Enumerable<BusinessScalarWhereInput>
    OR?: Enumerable<BusinessScalarWhereInput>
    NOT?: Enumerable<BusinessScalarWhereInput>
    id?: StringFilter | string
    providerId?: StringFilter | string
    name?: StringFilter | string
    address?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProviderCreateWithoutServicesInput = {
    id?: string
    name: string
    description?: string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businesses?: BusinessCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    description?: string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businesses?: BusinessUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutServicesInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutServicesInput, ProviderUncheckedCreateWithoutServicesInput>
  }

  export type PaymentTransactionCreateWithoutServiceInput = {
    id?: string
    amount: number
    currency: string
    mode: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentTransactionsInput
  }

  export type PaymentTransactionUncheckedCreateWithoutServiceInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    mode: string
    createdAt?: Date | string
  }

  export type PaymentTransactionCreateOrConnectWithoutServiceInput = {
    where: PaymentTransactionWhereUniqueInput
    create: XOR<PaymentTransactionCreateWithoutServiceInput, PaymentTransactionUncheckedCreateWithoutServiceInput>
  }

  export type PaymentTransactionCreateManyServiceInputEnvelope = {
    data: Enumerable<PaymentTransactionCreateManyServiceInput>
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutServiceInput = {
    id?: string
    appointmentDate: Date | string
    duration: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    googleEventId?: string | null
    outlookEventId?: string | null
    user: UserCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutServiceInput = {
    id?: string
    userId: string
    appointmentDate: Date | string
    duration: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    googleEventId?: string | null
    outlookEventId?: string | null
  }

  export type BookingCreateOrConnectWithoutServiceInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput>
  }

  export type BookingCreateManyServiceInputEnvelope = {
    data: Enumerable<BookingCreateManyServiceInput>
    skipDuplicates?: boolean
  }

  export type ProviderUpsertWithoutServicesInput = {
    update: XOR<ProviderUpdateWithoutServicesInput, ProviderUncheckedUpdateWithoutServicesInput>
    create: XOR<ProviderCreateWithoutServicesInput, ProviderUncheckedCreateWithoutServicesInput>
  }

  export type ProviderUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businesses?: BusinessUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businesses?: BusinessUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type PaymentTransactionUpsertWithWhereUniqueWithoutServiceInput = {
    where: PaymentTransactionWhereUniqueInput
    update: XOR<PaymentTransactionUpdateWithoutServiceInput, PaymentTransactionUncheckedUpdateWithoutServiceInput>
    create: XOR<PaymentTransactionCreateWithoutServiceInput, PaymentTransactionUncheckedCreateWithoutServiceInput>
  }

  export type PaymentTransactionUpdateWithWhereUniqueWithoutServiceInput = {
    where: PaymentTransactionWhereUniqueInput
    data: XOR<PaymentTransactionUpdateWithoutServiceInput, PaymentTransactionUncheckedUpdateWithoutServiceInput>
  }

  export type PaymentTransactionUpdateManyWithWhereWithoutServiceInput = {
    where: PaymentTransactionScalarWhereInput
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyWithoutPaymentTransactionsInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutServiceInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutServiceInput, BookingUncheckedUpdateWithoutServiceInput>
    create: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutServiceInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutServiceInput, BookingUncheckedUpdateWithoutServiceInput>
  }

  export type BookingUpdateManyWithWhereWithoutServiceInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutBookingsInput>
  }

  export type ProviderCreateWithoutBusinessesInput = {
    id?: string
    name: string
    description?: string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutBusinessesInput = {
    id?: string
    name: string
    description?: string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutBusinessesInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutBusinessesInput, ProviderUncheckedCreateWithoutBusinessesInput>
  }

  export type BusinessHourCreateWithoutBusinessInput = {
    id?: string
    dayOfWeek: number
    openTime: string
    closeTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessHourUncheckedCreateWithoutBusinessInput = {
    id?: string
    dayOfWeek: number
    openTime: string
    closeTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessHourCreateOrConnectWithoutBusinessInput = {
    where: BusinessHourWhereUniqueInput
    create: XOR<BusinessHourCreateWithoutBusinessInput, BusinessHourUncheckedCreateWithoutBusinessInput>
  }

  export type BusinessHourCreateManyBusinessInputEnvelope = {
    data: Enumerable<BusinessHourCreateManyBusinessInput>
    skipDuplicates?: boolean
  }

  export type StaffCreateWithoutBusinessInput = {
    id?: string
    name: string
    role: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: StaffScheduleCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutBusinessInput = {
    id?: string
    name: string
    role: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: StaffScheduleUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutBusinessInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutBusinessInput, StaffUncheckedCreateWithoutBusinessInput>
  }

  export type StaffCreateManyBusinessInputEnvelope = {
    data: Enumerable<StaffCreateManyBusinessInput>
    skipDuplicates?: boolean
  }

  export type ProviderUpsertWithoutBusinessesInput = {
    update: XOR<ProviderUpdateWithoutBusinessesInput, ProviderUncheckedUpdateWithoutBusinessesInput>
    create: XOR<ProviderCreateWithoutBusinessesInput, ProviderUncheckedCreateWithoutBusinessesInput>
  }

  export type ProviderUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type BusinessHourUpsertWithWhereUniqueWithoutBusinessInput = {
    where: BusinessHourWhereUniqueInput
    update: XOR<BusinessHourUpdateWithoutBusinessInput, BusinessHourUncheckedUpdateWithoutBusinessInput>
    create: XOR<BusinessHourCreateWithoutBusinessInput, BusinessHourUncheckedCreateWithoutBusinessInput>
  }

  export type BusinessHourUpdateWithWhereUniqueWithoutBusinessInput = {
    where: BusinessHourWhereUniqueInput
    data: XOR<BusinessHourUpdateWithoutBusinessInput, BusinessHourUncheckedUpdateWithoutBusinessInput>
  }

  export type BusinessHourUpdateManyWithWhereWithoutBusinessInput = {
    where: BusinessHourScalarWhereInput
    data: XOR<BusinessHourUpdateManyMutationInput, BusinessHourUncheckedUpdateManyWithoutHoursInput>
  }

  export type BusinessHourScalarWhereInput = {
    AND?: Enumerable<BusinessHourScalarWhereInput>
    OR?: Enumerable<BusinessHourScalarWhereInput>
    NOT?: Enumerable<BusinessHourScalarWhereInput>
    id?: StringFilter | string
    businessId?: StringFilter | string
    dayOfWeek?: IntFilter | number
    openTime?: StringFilter | string
    closeTime?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type StaffUpsertWithWhereUniqueWithoutBusinessInput = {
    where: StaffWhereUniqueInput
    update: XOR<StaffUpdateWithoutBusinessInput, StaffUncheckedUpdateWithoutBusinessInput>
    create: XOR<StaffCreateWithoutBusinessInput, StaffUncheckedCreateWithoutBusinessInput>
  }

  export type StaffUpdateWithWhereUniqueWithoutBusinessInput = {
    where: StaffWhereUniqueInput
    data: XOR<StaffUpdateWithoutBusinessInput, StaffUncheckedUpdateWithoutBusinessInput>
  }

  export type StaffUpdateManyWithWhereWithoutBusinessInput = {
    where: StaffScalarWhereInput
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyWithoutStaffInput>
  }

  export type StaffScalarWhereInput = {
    AND?: Enumerable<StaffScalarWhereInput>
    OR?: Enumerable<StaffScalarWhereInput>
    NOT?: Enumerable<StaffScalarWhereInput>
    id?: StringFilter | string
    businessId?: StringFilter | string
    name?: StringFilter | string
    role?: StringFilter | string
    email?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BusinessCreateWithoutHoursInput = {
    id?: string
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutBusinessesInput
    staff?: StaffCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutHoursInput = {
    id?: string
    providerId: string
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutHoursInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutHoursInput, BusinessUncheckedCreateWithoutHoursInput>
  }

  export type BusinessUpsertWithoutHoursInput = {
    update: XOR<BusinessUpdateWithoutHoursInput, BusinessUncheckedUpdateWithoutHoursInput>
    create: XOR<BusinessCreateWithoutHoursInput, BusinessUncheckedCreateWithoutHoursInput>
  }

  export type BusinessUpdateWithoutHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutBusinessesNestedInput
    staff?: StaffUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateWithoutStaffInput = {
    id?: string
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutBusinessesInput
    hours?: BusinessHourCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutStaffInput = {
    id?: string
    providerId: string
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hours?: BusinessHourUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutStaffInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutStaffInput, BusinessUncheckedCreateWithoutStaffInput>
  }

  export type StaffScheduleCreateWithoutStaffInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutScheduleInput
  }

  export type StaffScheduleUncheckedCreateWithoutStaffInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type StaffScheduleCreateOrConnectWithoutStaffInput = {
    where: StaffScheduleWhereUniqueInput
    create: XOR<StaffScheduleCreateWithoutStaffInput, StaffScheduleUncheckedCreateWithoutStaffInput>
  }

  export type StaffScheduleCreateManyStaffInputEnvelope = {
    data: Enumerable<StaffScheduleCreateManyStaffInput>
    skipDuplicates?: boolean
  }

  export type BusinessUpsertWithoutStaffInput = {
    update: XOR<BusinessUpdateWithoutStaffInput, BusinessUncheckedUpdateWithoutStaffInput>
    create: XOR<BusinessCreateWithoutStaffInput, BusinessUncheckedCreateWithoutStaffInput>
  }

  export type BusinessUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutBusinessesNestedInput
    hours?: BusinessHourUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: BusinessHourUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type StaffScheduleUpsertWithWhereUniqueWithoutStaffInput = {
    where: StaffScheduleWhereUniqueInput
    update: XOR<StaffScheduleUpdateWithoutStaffInput, StaffScheduleUncheckedUpdateWithoutStaffInput>
    create: XOR<StaffScheduleCreateWithoutStaffInput, StaffScheduleUncheckedCreateWithoutStaffInput>
  }

  export type StaffScheduleUpdateWithWhereUniqueWithoutStaffInput = {
    where: StaffScheduleWhereUniqueInput
    data: XOR<StaffScheduleUpdateWithoutStaffInput, StaffScheduleUncheckedUpdateWithoutStaffInput>
  }

  export type StaffScheduleUpdateManyWithWhereWithoutStaffInput = {
    where: StaffScheduleScalarWhereInput
    data: XOR<StaffScheduleUpdateManyMutationInput, StaffScheduleUncheckedUpdateManyWithoutSchedulesInput>
  }

  export type StaffScheduleScalarWhereInput = {
    AND?: Enumerable<StaffScheduleScalarWhereInput>
    OR?: Enumerable<StaffScheduleScalarWhereInput>
    NOT?: Enumerable<StaffScheduleScalarWhereInput>
    id?: StringFilter | string
    staffId?: StringFilter | string
    date?: DateTimeFilter | Date | string
    startTime?: DateTimeFilter | Date | string
    endTime?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type StaffCreateWithoutSchedulesInput = {
    id?: string
    name: string
    role: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutSchedulesInput = {
    id?: string
    businessId: string
    name: string
    role: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffCreateOrConnectWithoutSchedulesInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutSchedulesInput, StaffUncheckedCreateWithoutSchedulesInput>
  }

  export type AttendanceRecordCreateWithoutScheduleInput = {
    id?: string
    status: string
    timestamp?: Date | string
  }

  export type AttendanceRecordUncheckedCreateWithoutScheduleInput = {
    id?: string
    status: string
    timestamp?: Date | string
  }

  export type AttendanceRecordCreateOrConnectWithoutScheduleInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutScheduleInput, AttendanceRecordUncheckedCreateWithoutScheduleInput>
  }

  export type AttendanceRecordCreateManyScheduleInputEnvelope = {
    data: Enumerable<AttendanceRecordCreateManyScheduleInput>
    skipDuplicates?: boolean
  }

  export type StaffUpsertWithoutSchedulesInput = {
    update: XOR<StaffUpdateWithoutSchedulesInput, StaffUncheckedUpdateWithoutSchedulesInput>
    create: XOR<StaffCreateWithoutSchedulesInput, StaffUncheckedCreateWithoutSchedulesInput>
  }

  export type StaffUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutScheduleInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutScheduleInput, AttendanceRecordUncheckedUpdateWithoutScheduleInput>
    create: XOR<AttendanceRecordCreateWithoutScheduleInput, AttendanceRecordUncheckedCreateWithoutScheduleInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutScheduleInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutScheduleInput, AttendanceRecordUncheckedUpdateWithoutScheduleInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutScheduleInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutAttendanceRecordsInput>
  }

  export type AttendanceRecordScalarWhereInput = {
    AND?: Enumerable<AttendanceRecordScalarWhereInput>
    OR?: Enumerable<AttendanceRecordScalarWhereInput>
    NOT?: Enumerable<AttendanceRecordScalarWhereInput>
    id?: StringFilter | string
    scheduleId?: StringFilter | string
    status?: StringFilter | string
    timestamp?: DateTimeFilter | Date | string
  }

  export type StaffScheduleCreateWithoutAttendanceRecordsInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffCreateNestedOneWithoutSchedulesInput
  }

  export type StaffScheduleUncheckedCreateWithoutAttendanceRecordsInput = {
    id?: string
    staffId: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffScheduleCreateOrConnectWithoutAttendanceRecordsInput = {
    where: StaffScheduleWhereUniqueInput
    create: XOR<StaffScheduleCreateWithoutAttendanceRecordsInput, StaffScheduleUncheckedCreateWithoutAttendanceRecordsInput>
  }

  export type StaffScheduleUpsertWithoutAttendanceRecordsInput = {
    update: XOR<StaffScheduleUpdateWithoutAttendanceRecordsInput, StaffScheduleUncheckedUpdateWithoutAttendanceRecordsInput>
    create: XOR<StaffScheduleCreateWithoutAttendanceRecordsInput, StaffScheduleUncheckedCreateWithoutAttendanceRecordsInput>
  }

  export type StaffScheduleUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type StaffScheduleUncheckedUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingProgressCreateWithoutModuleInput = {
    id?: string
    completedAt?: Date | string
    user: UserCreateNestedOneWithoutTrainingProgressInput
  }

  export type TrainingProgressUncheckedCreateWithoutModuleInput = {
    id?: string
    userId: string
    completedAt?: Date | string
  }

  export type TrainingProgressCreateOrConnectWithoutModuleInput = {
    where: TrainingProgressWhereUniqueInput
    create: XOR<TrainingProgressCreateWithoutModuleInput, TrainingProgressUncheckedCreateWithoutModuleInput>
  }

  export type TrainingProgressCreateManyModuleInputEnvelope = {
    data: Enumerable<TrainingProgressCreateManyModuleInput>
    skipDuplicates?: boolean
  }

  export type TrainingProgressUpsertWithWhereUniqueWithoutModuleInput = {
    where: TrainingProgressWhereUniqueInput
    update: XOR<TrainingProgressUpdateWithoutModuleInput, TrainingProgressUncheckedUpdateWithoutModuleInput>
    create: XOR<TrainingProgressCreateWithoutModuleInput, TrainingProgressUncheckedCreateWithoutModuleInput>
  }

  export type TrainingProgressUpdateWithWhereUniqueWithoutModuleInput = {
    where: TrainingProgressWhereUniqueInput
    data: XOR<TrainingProgressUpdateWithoutModuleInput, TrainingProgressUncheckedUpdateWithoutModuleInput>
  }

  export type TrainingProgressUpdateManyWithWhereWithoutModuleInput = {
    where: TrainingProgressScalarWhereInput
    data: XOR<TrainingProgressUpdateManyMutationInput, TrainingProgressUncheckedUpdateManyWithoutTrainingProgressInput>
  }

  export type UserCreateWithoutTrainingProgressInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTrainingProgressInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTrainingProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrainingProgressInput, UserUncheckedCreateWithoutTrainingProgressInput>
  }

  export type TrainingModuleCreateWithoutTrainingProgressInput = {
    id?: string
    title: string
    description?: string | null
    contentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingModuleUncheckedCreateWithoutTrainingProgressInput = {
    id?: string
    title: string
    description?: string | null
    contentUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingModuleCreateOrConnectWithoutTrainingProgressInput = {
    where: TrainingModuleWhereUniqueInput
    create: XOR<TrainingModuleCreateWithoutTrainingProgressInput, TrainingModuleUncheckedCreateWithoutTrainingProgressInput>
  }

  export type UserUpsertWithoutTrainingProgressInput = {
    update: XOR<UserUpdateWithoutTrainingProgressInput, UserUncheckedUpdateWithoutTrainingProgressInput>
    create: XOR<UserCreateWithoutTrainingProgressInput, UserUncheckedCreateWithoutTrainingProgressInput>
  }

  export type UserUpdateWithoutTrainingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTrainingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TrainingModuleUpsertWithoutTrainingProgressInput = {
    update: XOR<TrainingModuleUpdateWithoutTrainingProgressInput, TrainingModuleUncheckedUpdateWithoutTrainingProgressInput>
    create: XOR<TrainingModuleCreateWithoutTrainingProgressInput, TrainingModuleUncheckedCreateWithoutTrainingProgressInput>
  }

  export type TrainingModuleUpdateWithoutTrainingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingModuleUncheckedUpdateWithoutTrainingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionCreateWithoutTierInput = {
    id?: string
    points: number
    type: TransactionType
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type LoyaltyTransactionUncheckedCreateWithoutTierInput = {
    id?: string
    userId: string
    points: number
    type: TransactionType
    createdAt?: Date | string
  }

  export type LoyaltyTransactionCreateOrConnectWithoutTierInput = {
    where: LoyaltyTransactionWhereUniqueInput
    create: XOR<LoyaltyTransactionCreateWithoutTierInput, LoyaltyTransactionUncheckedCreateWithoutTierInput>
  }

  export type LoyaltyTransactionCreateManyTierInputEnvelope = {
    data: Enumerable<LoyaltyTransactionCreateManyTierInput>
    skipDuplicates?: boolean
  }

  export type LoyaltyTransactionUpsertWithWhereUniqueWithoutTierInput = {
    where: LoyaltyTransactionWhereUniqueInput
    update: XOR<LoyaltyTransactionUpdateWithoutTierInput, LoyaltyTransactionUncheckedUpdateWithoutTierInput>
    create: XOR<LoyaltyTransactionCreateWithoutTierInput, LoyaltyTransactionUncheckedCreateWithoutTierInput>
  }

  export type LoyaltyTransactionUpdateWithWhereUniqueWithoutTierInput = {
    where: LoyaltyTransactionWhereUniqueInput
    data: XOR<LoyaltyTransactionUpdateWithoutTierInput, LoyaltyTransactionUncheckedUpdateWithoutTierInput>
  }

  export type LoyaltyTransactionUpdateManyWithWhereWithoutTierInput = {
    where: LoyaltyTransactionScalarWhereInput
    data: XOR<LoyaltyTransactionUpdateManyMutationInput, LoyaltyTransactionUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type LoyaltyTierCreateWithoutTransactionsInput = {
    id?: string
    name: string
    requiredPoints: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyTierUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    requiredPoints: number
    discount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyTierCreateOrConnectWithoutTransactionsInput = {
    where: LoyaltyTierWhereUniqueInput
    create: XOR<LoyaltyTierCreateWithoutTransactionsInput, LoyaltyTierUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LoyaltyTierUpsertWithoutTransactionsInput = {
    update: XOR<LoyaltyTierUpdateWithoutTransactionsInput, LoyaltyTierUncheckedUpdateWithoutTransactionsInput>
    create: XOR<LoyaltyTierCreateWithoutTransactionsInput, LoyaltyTierUncheckedCreateWithoutTransactionsInput>
  }

  export type LoyaltyTierUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    requiredPoints?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTierUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    requiredPoints?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSubscriptionsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAnalyticsEventsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnalyticsEventsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnalyticsEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnalyticsEventsInput, UserUncheckedCreateWithoutAnalyticsEventsInput>
  }

  export type UserUpsertWithoutAnalyticsEventsInput = {
    update: XOR<UserUpdateWithoutAnalyticsEventsInput, UserUncheckedUpdateWithoutAnalyticsEventsInput>
    create: XOR<UserCreateWithoutAnalyticsEventsInput, UserUncheckedCreateWithoutAnalyticsEventsInput>
  }

  export type UserUpdateWithoutAnalyticsEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnalyticsEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPaymentTransactionsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentTransactionsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentTransactionsInput, UserUncheckedCreateWithoutPaymentTransactionsInput>
  }

  export type ServiceCreateWithoutPaymentTransactionsInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    bookings?: BookingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutPaymentTransactionsInput = {
    id?: string
    providerId: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutPaymentTransactionsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutPaymentTransactionsInput, ServiceUncheckedCreateWithoutPaymentTransactionsInput>
  }

  export type UserUpsertWithoutPaymentTransactionsInput = {
    update: XOR<UserUpdateWithoutPaymentTransactionsInput, UserUncheckedUpdateWithoutPaymentTransactionsInput>
    create: XOR<UserCreateWithoutPaymentTransactionsInput, UserUncheckedCreateWithoutPaymentTransactionsInput>
  }

  export type UserUpdateWithoutPaymentTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceUpsertWithoutPaymentTransactionsInput = {
    update: XOR<ServiceUpdateWithoutPaymentTransactionsInput, ServiceUncheckedUpdateWithoutPaymentTransactionsInput>
    create: XOR<ServiceCreateWithoutPaymentTransactionsInput, ServiceUncheckedCreateWithoutPaymentTransactionsInput>
  }

  export type ServiceUpdateWithoutPaymentTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    bookings?: BookingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutPaymentTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserCreateWithoutGoogleCalendarTokenInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGoogleCalendarTokenInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGoogleCalendarTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGoogleCalendarTokenInput, UserUncheckedCreateWithoutGoogleCalendarTokenInput>
  }

  export type UserUpsertWithoutGoogleCalendarTokenInput = {
    update: XOR<UserUpdateWithoutGoogleCalendarTokenInput, UserUncheckedUpdateWithoutGoogleCalendarTokenInput>
    create: XOR<UserCreateWithoutGoogleCalendarTokenInput, UserUncheckedCreateWithoutGoogleCalendarTokenInput>
  }

  export type UserUpdateWithoutGoogleCalendarTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGoogleCalendarTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOutlookCalendarTokenInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOutlookCalendarTokenInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOutlookCalendarTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOutlookCalendarTokenInput, UserUncheckedCreateWithoutOutlookCalendarTokenInput>
  }

  export type UserUpsertWithoutOutlookCalendarTokenInput = {
    update: XOR<UserUpdateWithoutOutlookCalendarTokenInput, UserUncheckedUpdateWithoutOutlookCalendarTokenInput>
    create: XOR<UserCreateWithoutOutlookCalendarTokenInput, UserUncheckedCreateWithoutOutlookCalendarTokenInput>
  }

  export type UserUpdateWithoutOutlookCalendarTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOutlookCalendarTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FormSubmissionCreateWithoutDefinitionInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    submittedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutSubmissionInput
  }

  export type FormSubmissionUncheckedCreateWithoutDefinitionInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    submittedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type FormSubmissionCreateOrConnectWithoutDefinitionInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutDefinitionInput, FormSubmissionUncheckedCreateWithoutDefinitionInput>
  }

  export type FormSubmissionCreateManyDefinitionInputEnvelope = {
    data: Enumerable<FormSubmissionCreateManyDefinitionInput>
    skipDuplicates?: boolean
  }

  export type FormSubmissionUpsertWithWhereUniqueWithoutDefinitionInput = {
    where: FormSubmissionWhereUniqueInput
    update: XOR<FormSubmissionUpdateWithoutDefinitionInput, FormSubmissionUncheckedUpdateWithoutDefinitionInput>
    create: XOR<FormSubmissionCreateWithoutDefinitionInput, FormSubmissionUncheckedCreateWithoutDefinitionInput>
  }

  export type FormSubmissionUpdateWithWhereUniqueWithoutDefinitionInput = {
    where: FormSubmissionWhereUniqueInput
    data: XOR<FormSubmissionUpdateWithoutDefinitionInput, FormSubmissionUncheckedUpdateWithoutDefinitionInput>
  }

  export type FormSubmissionUpdateManyWithWhereWithoutDefinitionInput = {
    where: FormSubmissionScalarWhereInput
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyWithoutSubmissionsInput>
  }

  export type FormSubmissionScalarWhereInput = {
    AND?: Enumerable<FormSubmissionScalarWhereInput>
    OR?: Enumerable<FormSubmissionScalarWhereInput>
    NOT?: Enumerable<FormSubmissionScalarWhereInput>
    id?: StringFilter | string
    definitionId?: StringFilter | string
    data?: JsonFilter
    submittedAt?: DateTimeFilter | Date | string
  }

  export type FormDefinitionCreateWithoutSubmissionsInput = {
    id?: string
    name: string
    fields: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormDefinitionUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    name: string
    fields: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormDefinitionCreateOrConnectWithoutSubmissionsInput = {
    where: FormDefinitionWhereUniqueInput
    create: XOR<FormDefinitionCreateWithoutSubmissionsInput, FormDefinitionUncheckedCreateWithoutSubmissionsInput>
  }

  export type DocumentCreateWithoutSubmissionInput = {
    id?: string
    url: string
    type: string
    createdAt?: Date | string
  }

  export type DocumentUncheckedCreateWithoutSubmissionInput = {
    id?: string
    url: string
    type: string
    createdAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutSubmissionInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutSubmissionInput, DocumentUncheckedCreateWithoutSubmissionInput>
  }

  export type DocumentCreateManySubmissionInputEnvelope = {
    data: Enumerable<DocumentCreateManySubmissionInput>
    skipDuplicates?: boolean
  }

  export type FormDefinitionUpsertWithoutSubmissionsInput = {
    update: XOR<FormDefinitionUpdateWithoutSubmissionsInput, FormDefinitionUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<FormDefinitionCreateWithoutSubmissionsInput, FormDefinitionUncheckedCreateWithoutSubmissionsInput>
  }

  export type FormDefinitionUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormDefinitionUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fields?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutSubmissionInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutSubmissionInput, DocumentUncheckedUpdateWithoutSubmissionInput>
    create: XOR<DocumentCreateWithoutSubmissionInput, DocumentUncheckedCreateWithoutSubmissionInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutSubmissionInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutSubmissionInput, DocumentUncheckedUpdateWithoutSubmissionInput>
  }

  export type DocumentUpdateManyWithWhereWithoutSubmissionInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: Enumerable<DocumentScalarWhereInput>
    OR?: Enumerable<DocumentScalarWhereInput>
    NOT?: Enumerable<DocumentScalarWhereInput>
    id?: StringFilter | string
    url?: StringFilter | string
    type?: StringFilter | string
    submissionId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type FormSubmissionCreateWithoutDocumentsInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    submittedAt?: Date | string
    definition: FormDefinitionCreateNestedOneWithoutSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateWithoutDocumentsInput = {
    id?: string
    definitionId: string
    data: JsonNullValueInput | InputJsonValue
    submittedAt?: Date | string
  }

  export type FormSubmissionCreateOrConnectWithoutDocumentsInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutDocumentsInput, FormSubmissionUncheckedCreateWithoutDocumentsInput>
  }

  export type FormSubmissionUpsertWithoutDocumentsInput = {
    update: XOR<FormSubmissionUpdateWithoutDocumentsInput, FormSubmissionUncheckedUpdateWithoutDocumentsInput>
    create: XOR<FormSubmissionCreateWithoutDocumentsInput, FormSubmissionUncheckedCreateWithoutDocumentsInput>
  }

  export type FormSubmissionUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    definition?: FormDefinitionUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    definitionId?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentAssignmentCreateWithoutEquipmentInput = {
    id?: string
    assignedAt?: Date | string
    returnedAt?: Date | string | null
    assignedToUser: UserCreateNestedOneWithoutAssignmentsInput
  }

  export type EquipmentAssignmentUncheckedCreateWithoutEquipmentInput = {
    id?: string
    assignedTo: string
    assignedAt?: Date | string
    returnedAt?: Date | string | null
  }

  export type EquipmentAssignmentCreateOrConnectWithoutEquipmentInput = {
    where: EquipmentAssignmentWhereUniqueInput
    create: XOR<EquipmentAssignmentCreateWithoutEquipmentInput, EquipmentAssignmentUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentAssignmentCreateManyEquipmentInputEnvelope = {
    data: Enumerable<EquipmentAssignmentCreateManyEquipmentInput>
    skipDuplicates?: boolean
  }

  export type EquipmentAssignmentUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentAssignmentWhereUniqueInput
    update: XOR<EquipmentAssignmentUpdateWithoutEquipmentInput, EquipmentAssignmentUncheckedUpdateWithoutEquipmentInput>
    create: XOR<EquipmentAssignmentCreateWithoutEquipmentInput, EquipmentAssignmentUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentAssignmentUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentAssignmentWhereUniqueInput
    data: XOR<EquipmentAssignmentUpdateWithoutEquipmentInput, EquipmentAssignmentUncheckedUpdateWithoutEquipmentInput>
  }

  export type EquipmentAssignmentUpdateManyWithWhereWithoutEquipmentInput = {
    where: EquipmentAssignmentScalarWhereInput
    data: XOR<EquipmentAssignmentUpdateManyMutationInput, EquipmentAssignmentUncheckedUpdateManyWithoutAssignmentsInput>
  }

  export type EquipmentItemCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    description?: string | null
    serialNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentItemUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    description?: string | null
    serialNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentItemCreateOrConnectWithoutAssignmentsInput = {
    where: EquipmentItemWhereUniqueInput
    create: XOR<EquipmentItemCreateWithoutAssignmentsInput, EquipmentItemUncheckedCreateWithoutAssignmentsInput>
  }

  export type UserCreateWithoutAssignmentsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignmentsInput, UserUncheckedCreateWithoutAssignmentsInput>
  }

  export type EquipmentItemUpsertWithoutAssignmentsInput = {
    update: XOR<EquipmentItemUpdateWithoutAssignmentsInput, EquipmentItemUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<EquipmentItemCreateWithoutAssignmentsInput, EquipmentItemUncheckedCreateWithoutAssignmentsInput>
  }

  export type EquipmentItemUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentItemUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutAssignmentsInput = {
    update: XOR<UserUpdateWithoutAssignmentsInput, UserUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<UserCreateWithoutAssignmentsInput, UserUncheckedCreateWithoutAssignmentsInput>
  }

  export type UserUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPostsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    content: string
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: Enumerable<CommentCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type PostCreateWithoutCommentsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSocialPostsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSocialPostsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSocialPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSocialPostsInput, UserUncheckedCreateWithoutSocialPostsInput>
  }

  export type PostCommentCreateWithoutPostInput = {
    id?: string
    content: string
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutPostCommentsInput
  }

  export type PostCommentUncheckedCreateWithoutPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type PostCommentCreateOrConnectWithoutPostInput = {
    where: PostCommentWhereUniqueInput
    create: XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput>
  }

  export type PostCommentCreateManyPostInputEnvelope = {
    data: Enumerable<PostCommentCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSocialPostsInput = {
    update: XOR<UserUpdateWithoutSocialPostsInput, UserUncheckedUpdateWithoutSocialPostsInput>
    create: XOR<UserCreateWithoutSocialPostsInput, UserUncheckedCreateWithoutSocialPostsInput>
  }

  export type UserUpdateWithoutSocialPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSocialPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostCommentUpsertWithWhereUniqueWithoutPostInput = {
    where: PostCommentWhereUniqueInput
    update: XOR<PostCommentUpdateWithoutPostInput, PostCommentUncheckedUpdateWithoutPostInput>
    create: XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput>
  }

  export type PostCommentUpdateWithWhereUniqueWithoutPostInput = {
    where: PostCommentWhereUniqueInput
    data: XOR<PostCommentUpdateWithoutPostInput, PostCommentUncheckedUpdateWithoutPostInput>
  }

  export type PostCommentUpdateManyWithWhereWithoutPostInput = {
    where: PostCommentScalarWhereInput
    data: XOR<PostCommentUpdateManyMutationInput, PostCommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type SocialPostCreateWithoutCommentsInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutSocialPostsInput
  }

  export type SocialPostUncheckedCreateWithoutCommentsInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialPostCreateOrConnectWithoutCommentsInput = {
    where: SocialPostWhereUniqueInput
    create: XOR<SocialPostCreateWithoutCommentsInput, SocialPostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutPostCommentsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostCommentsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostCommentsInput, UserUncheckedCreateWithoutPostCommentsInput>
  }

  export type SocialPostUpsertWithoutCommentsInput = {
    update: XOR<SocialPostUpdateWithoutCommentsInput, SocialPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<SocialPostCreateWithoutCommentsInput, SocialPostUncheckedCreateWithoutCommentsInput>
  }

  export type SocialPostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutSocialPostsNestedInput
  }

  export type SocialPostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutPostCommentsInput = {
    update: XOR<UserUpdateWithoutPostCommentsInput, UserUncheckedUpdateWithoutPostCommentsInput>
    create: XOR<UserCreateWithoutPostCommentsInput, UserUncheckedCreateWithoutPostCommentsInput>
  }

  export type UserUpdateWithoutPostCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventRegistrationCreateWithoutEventInput = {
    id?: string
    registeredAt?: Date | string
    user: UserCreateNestedOneWithoutEventRegistrationsInput
  }

  export type EventRegistrationUncheckedCreateWithoutEventInput = {
    id?: string
    userId: string
    registeredAt?: Date | string
  }

  export type EventRegistrationCreateOrConnectWithoutEventInput = {
    where: EventRegistrationWhereUniqueInput
    create: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput>
  }

  export type EventRegistrationCreateManyEventInputEnvelope = {
    data: Enumerable<EventRegistrationCreateManyEventInput>
    skipDuplicates?: boolean
  }

  export type EventRegistrationUpsertWithWhereUniqueWithoutEventInput = {
    where: EventRegistrationWhereUniqueInput
    update: XOR<EventRegistrationUpdateWithoutEventInput, EventRegistrationUncheckedUpdateWithoutEventInput>
    create: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput>
  }

  export type EventRegistrationUpdateWithWhereUniqueWithoutEventInput = {
    where: EventRegistrationWhereUniqueInput
    data: XOR<EventRegistrationUpdateWithoutEventInput, EventRegistrationUncheckedUpdateWithoutEventInput>
  }

  export type EventRegistrationUpdateManyWithWhereWithoutEventInput = {
    where: EventRegistrationScalarWhereInput
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyWithoutRegistrationsInput>
  }

  export type EventCreateWithoutRegistrationsInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUncheckedCreateWithoutRegistrationsInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutRegistrationsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
  }

  export type UserCreateWithoutEventRegistrationsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEventRegistrationsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEventRegistrationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventRegistrationsInput, UserUncheckedCreateWithoutEventRegistrationsInput>
  }

  export type EventUpsertWithoutRegistrationsInput = {
    update: XOR<EventUpdateWithoutRegistrationsInput, EventUncheckedUpdateWithoutRegistrationsInput>
    create: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
  }

  export type EventUpdateWithoutRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateWithoutRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutEventRegistrationsInput = {
    update: XOR<UserUpdateWithoutEventRegistrationsInput, UserUncheckedUpdateWithoutEventRegistrationsInput>
    create: XOR<UserCreateWithoutEventRegistrationsInput, UserUncheckedCreateWithoutEventRegistrationsInput>
  }

  export type UserUpdateWithoutEventRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutForumThreadsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutForumThreadsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutForumThreadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutForumThreadsInput, UserUncheckedCreateWithoutForumThreadsInput>
  }

  export type ForumPostCreateWithoutThreadInput = {
    id?: string
    content: string
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutForumPostsInput
  }

  export type ForumPostUncheckedCreateWithoutThreadInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type ForumPostCreateOrConnectWithoutThreadInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutThreadInput, ForumPostUncheckedCreateWithoutThreadInput>
  }

  export type ForumPostCreateManyThreadInputEnvelope = {
    data: Enumerable<ForumPostCreateManyThreadInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutForumThreadsInput = {
    update: XOR<UserUpdateWithoutForumThreadsInput, UserUncheckedUpdateWithoutForumThreadsInput>
    create: XOR<UserCreateWithoutForumThreadsInput, UserUncheckedCreateWithoutForumThreadsInput>
  }

  export type UserUpdateWithoutForumThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutForumThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ForumPostUpsertWithWhereUniqueWithoutThreadInput = {
    where: ForumPostWhereUniqueInput
    update: XOR<ForumPostUpdateWithoutThreadInput, ForumPostUncheckedUpdateWithoutThreadInput>
    create: XOR<ForumPostCreateWithoutThreadInput, ForumPostUncheckedCreateWithoutThreadInput>
  }

  export type ForumPostUpdateWithWhereUniqueWithoutThreadInput = {
    where: ForumPostWhereUniqueInput
    data: XOR<ForumPostUpdateWithoutThreadInput, ForumPostUncheckedUpdateWithoutThreadInput>
  }

  export type ForumPostUpdateManyWithWhereWithoutThreadInput = {
    where: ForumPostScalarWhereInput
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyWithoutPostsInput>
  }

  export type ForumThreadCreateWithoutPostsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutForumThreadsInput
  }

  export type ForumThreadUncheckedCreateWithoutPostsInput = {
    id?: string
    title: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumThreadCreateOrConnectWithoutPostsInput = {
    where: ForumThreadWhereUniqueInput
    create: XOR<ForumThreadCreateWithoutPostsInput, ForumThreadUncheckedCreateWithoutPostsInput>
  }

  export type UserCreateWithoutForumPostsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutForumPostsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutForumPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
  }

  export type ForumThreadUpsertWithoutPostsInput = {
    update: XOR<ForumThreadUpdateWithoutPostsInput, ForumThreadUncheckedUpdateWithoutPostsInput>
    create: XOR<ForumThreadCreateWithoutPostsInput, ForumThreadUncheckedCreateWithoutPostsInput>
  }

  export type ForumThreadUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutForumThreadsNestedInput
  }

  export type ForumThreadUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutForumPostsInput = {
    update: XOR<UserUpdateWithoutForumPostsInput, UserUncheckedUpdateWithoutForumPostsInput>
    create: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
  }

  export type UserUpdateWithoutForumPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutForumPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBenefitClaimsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBenefitClaimsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBenefitClaimsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBenefitClaimsInput, UserUncheckedCreateWithoutBenefitClaimsInput>
  }

  export type UserUpsertWithoutBenefitClaimsInput = {
    update: XOR<UserUpdateWithoutBenefitClaimsInput, UserUncheckedUpdateWithoutBenefitClaimsInput>
    create: XOR<UserCreateWithoutBenefitClaimsInput, UserUncheckedCreateWithoutBenefitClaimsInput>
  }

  export type UserUpdateWithoutBenefitClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBenefitClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPayrollRecordsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPayrollRecordsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPayrollRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPayrollRecordsInput, UserUncheckedCreateWithoutPayrollRecordsInput>
  }

  export type UserUpsertWithoutPayrollRecordsInput = {
    update: XOR<UserUpdateWithoutPayrollRecordsInput, UserUncheckedUpdateWithoutPayrollRecordsInput>
    create: XOR<UserCreateWithoutPayrollRecordsInput, UserUncheckedCreateWithoutPayrollRecordsInput>
  }

  export type UserUpdateWithoutPayrollRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPayrollRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBookingsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type ServiceCreateWithoutBookingsInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutBookingsInput = {
    id?: string
    providerId: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutBookingsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceUpsertWithoutBookingsInput = {
    update: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
  }

  export type ServiceUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserCreateWithoutTwoFactorAuthInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTwoFactorAuthInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTwoFactorAuthInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTwoFactorAuthInput, UserUncheckedCreateWithoutTwoFactorAuthInput>
  }

  export type UserUpsertWithoutTwoFactorAuthInput = {
    update: XOR<UserUpdateWithoutTwoFactorAuthInput, UserUncheckedUpdateWithoutTwoFactorAuthInput>
    create: XOR<UserCreateWithoutTwoFactorAuthInput, UserUncheckedCreateWithoutTwoFactorAuthInput>
  }

  export type UserUpdateWithoutTwoFactorAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTwoFactorAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutWebAuthnCredentialsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWebAuthnCredentialsInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
    referredById?: string | null
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    analyticsEvents?: AnalyticsEventUncheckedCreateNestedManyWithoutUserInput
    paymentTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    trainingProgress?: TrainingProgressUncheckedCreateNestedManyWithoutUserInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedCreateNestedOneWithoutUserInput
    assignments?: EquipmentAssignmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutAuthorInput
    postComments?: PostCommentUncheckedCreateNestedManyWithoutAuthorInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    forumThreads?: ForumThreadUncheckedCreateNestedManyWithoutAuthorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    benefitClaims?: BenefitClaimUncheckedCreateNestedManyWithoutUserInput
    payrollRecords?: PayrollRecordUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    twoFactorAuth?: TwoFactorAuthUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWebAuthnCredentialsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWebAuthnCredentialsInput, UserUncheckedCreateWithoutWebAuthnCredentialsInput>
  }

  export type UserUpsertWithoutWebAuthnCredentialsInput = {
    update: XOR<UserUpdateWithoutWebAuthnCredentialsInput, UserUncheckedUpdateWithoutWebAuthnCredentialsInput>
    create: XOR<UserCreateWithoutWebAuthnCredentialsInput, UserUncheckedCreateWithoutWebAuthnCredentialsInput>
  }

  export type UserUpdateWithoutWebAuthnCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWebAuthnCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
  }

  export type LoyaltyTransactionCreateManyUserInput = {
    id?: string
    tierId?: string | null
    points: number
    type: TransactionType
    createdAt?: Date | string
  }

  export type SubscriptionCreateManyUserInput = {
    id?: string
    stripeSubscriptionId: string
    priceId: string
    status: string
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyReferredByInput = {
    id?: string
    auth0Id?: string | null
    email: string
    name?: string | null
    avatar?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: string
  }

  export type AnalyticsEventCreateManyUserInput = {
    id?: string
    event: string
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PaymentTransactionCreateManyUserInput = {
    id?: string
    amount: number
    currency: string
    mode: string
    createdAt?: Date | string
    serviceId?: string | null
  }

  export type TrainingProgressCreateManyUserInput = {
    id?: string
    moduleId: string
    completedAt?: Date | string
  }

  export type EquipmentAssignmentCreateManyAssignedToUserInput = {
    id?: string
    equipmentId: string
    assignedAt?: Date | string
    returnedAt?: Date | string | null
  }

  export type SocialPostCreateManyAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCommentCreateManyAuthorInput = {
    id?: string
    postId: string
    content: string
    createdAt?: Date | string
  }

  export type EventRegistrationCreateManyUserInput = {
    id?: string
    eventId: string
    registeredAt?: Date | string
  }

  export type ForumThreadCreateManyAuthorInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumPostCreateManyAuthorInput = {
    id?: string
    threadId: string
    content: string
    createdAt?: Date | string
  }

  export type BenefitClaimCreateManyUserInput = {
    id?: string
    type: string
    status: string
    amount?: number | null
    requestedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type PayrollRecordCreateManyUserInput = {
    id?: string
    salary: number
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyUserInput = {
    id?: string
    serviceId: string
    appointmentDate: Date | string
    duration: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    googleEventId?: string | null
    outlookEventId?: string | null
  }

  export type PostCreateManyAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    postId: string
    content: string
    createdAt?: Date | string
  }

  export type WebAuthnCredentialCreateManyUserInput = {
    id?: string
    credentialId: string
    publicKey: string
    counter: number
    transports?: WebAuthnCredentialCreatetransportsInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyTransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: LoyaltyTierUpdateOneWithoutTransactionsNestedInput
  }

  export type LoyaltyTransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierId?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionUncheckedUpdateManyWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierId?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    priceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    priceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: StringFieldUpdateOperationsInput | string
    priceId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutReferredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    analyticsEvents?: AnalyticsEventUncheckedUpdateManyWithoutUserNestedInput
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    trainingProgress?: TrainingProgressUncheckedUpdateManyWithoutUserNestedInput
    googleCalendarToken?: GoogleCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    outlookCalendarToken?: OutlookCalendarTokenUncheckedUpdateOneWithoutUserNestedInput
    assignments?: EquipmentAssignmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutAuthorNestedInput
    postComments?: PostCommentUncheckedUpdateManyWithoutAuthorNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    forumThreads?: ForumThreadUncheckedUpdateManyWithoutAuthorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    benefitClaims?: BenefitClaimUncheckedUpdateManyWithoutUserNestedInput
    payrollRecords?: PayrollRecordUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    twoFactorAuth?: TwoFactorAuthUncheckedUpdateOneWithoutUserNestedInput
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushTokens?: JsonNullValueInput | InputJsonValue
    notificationSettings?: JsonNullValueInput | InputJsonValue
    referralCode?: StringFieldUpdateOperationsInput | string
  }

  export type AnalyticsEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateManyWithoutAnalyticsEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutPaymentTransactionsNestedInput
  }

  export type PaymentTransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutPaymentTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrainingProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: TrainingModuleUpdateOneRequiredWithoutTrainingProgressNestedInput
  }

  export type TrainingProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingProgressUncheckedUpdateManyWithoutTrainingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentAssignmentUpdateWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: EquipmentItemUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type EquipmentAssignmentUncheckedUpdateWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EquipmentAssignmentUncheckedUpdateManyWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SocialPostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: PostCommentUpdateManyWithoutPostNestedInput
  }

  export type SocialPostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: PostCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type SocialPostUncheckedUpdateManyWithoutSocialPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: SocialPostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type PostCommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCommentUncheckedUpdateManyWithoutPostCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutRegistrationsNestedInput
  }

  export type EventRegistrationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationUncheckedUpdateManyWithoutEventRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumThreadUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: ForumPostUpdateManyWithoutThreadNestedInput
  }

  export type ForumThreadUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: ForumPostUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ForumThreadUncheckedUpdateManyWithoutForumThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: ForumThreadUpdateOneRequiredWithoutPostsNestedInput
  }

  export type ForumPostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostUncheckedUpdateManyWithoutForumPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BenefitClaimUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BenefitClaimUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BenefitClaimUncheckedUpdateManyWithoutBenefitClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayrollRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    salary?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    salary?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollRecordUncheckedUpdateManyWithoutPayrollRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    salary?: FloatFieldUpdateOperationsInput | number
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUncheckedUpdateManyWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebAuthnCredentialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: WebAuthnCredentialUpdatetransportsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebAuthnCredentialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: WebAuthnCredentialUpdatetransportsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebAuthnCredentialUncheckedUpdateManyWithoutWebAuthnCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    transports?: WebAuthnCredentialUpdatetransportsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyProviderInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessCreateManyProviderInput = {
    id?: string
    name: string
    address?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTransactions?: PaymentTransactionUpdateManyWithoutServiceNestedInput
    bookings?: BookingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTransactions?: PaymentTransactionUncheckedUpdateManyWithoutServiceNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: BusinessHourUpdateManyWithoutBusinessNestedInput
    staff?: StaffUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: BusinessHourUncheckedUpdateManyWithoutBusinessNestedInput
    staff?: StaffUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateManyWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionCreateManyServiceInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    mode: string
    createdAt?: Date | string
  }

  export type BookingCreateManyServiceInput = {
    id?: string
    userId: string
    appointmentDate: Date | string
    duration: number
    specialRequests?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    googleEventId?: string | null
    outlookEventId?: string | null
  }

  export type PaymentTransactionUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentTransactionsNestedInput
  }

  export type PaymentTransactionUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    googleEventId?: NullableStringFieldUpdateOperationsInput | string | null
    outlookEventId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessHourCreateManyBusinessInput = {
    id?: string
    dayOfWeek: number
    openTime: string
    closeTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffCreateManyBusinessInput = {
    id?: string
    name: string
    role: string
    email?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessHourUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessHourUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessHourUncheckedUpdateManyWithoutHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: StaffScheduleUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: StaffScheduleUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffScheduleCreateManyStaffInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffScheduleUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceRecords?: AttendanceRecordUpdateManyWithoutScheduleNestedInput
  }

  export type StaffScheduleUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type StaffScheduleUncheckedUpdateManyWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordCreateManyScheduleInput = {
    id?: string
    status: string
    timestamp?: Date | string
  }

  export type AttendanceRecordUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingProgressCreateManyModuleInput = {
    id?: string
    userId: string
    completedAt?: Date | string
  }

  export type TrainingProgressUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrainingProgressNestedInput
  }

  export type TrainingProgressUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionCreateManyTierInput = {
    id?: string
    userId: string
    points: number
    type: TransactionType
    createdAt?: Date | string
  }

  export type LoyaltyTransactionUpdateWithoutTierInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type LoyaltyTransactionUncheckedUpdateWithoutTierInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | TransactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSubmissionCreateManyDefinitionInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    submittedAt?: Date | string
  }

  export type FormSubmissionUpdateWithoutDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutSubmissionNestedInput
  }

  export type FormSubmissionUncheckedUpdateWithoutDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type FormSubmissionUncheckedUpdateManyWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManySubmissionInput = {
    id?: string
    url: string
    type: string
    createdAt?: Date | string
  }

  export type DocumentUpdateWithoutSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateWithoutSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentAssignmentCreateManyEquipmentInput = {
    id?: string
    assignedTo: string
    assignedAt?: Date | string
    returnedAt?: Date | string | null
  }

  export type EquipmentAssignmentUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedToUser?: UserUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type EquipmentAssignmentUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentCreateManyPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCommentCreateManyPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type PostCommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostCommentsNestedInput
  }

  export type PostCommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCommentUncheckedUpdateManyWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationCreateManyEventInput = {
    id?: string
    userId: string
    registeredAt?: Date | string
  }

  export type EventRegistrationUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEventRegistrationsNestedInput
  }

  export type EventRegistrationUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationUncheckedUpdateManyWithoutRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostCreateManyThreadInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
  }

  export type ForumPostUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutForumPostsNestedInput
  }

  export type ForumPostUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}